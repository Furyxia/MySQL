# 查询数据

## 1.基本查询语句

MySQL从数据表中查询数据的基本语句为SELECT语句。SELECT语句的基本格式为：

```
SELECT
	{*|<字段列表>}
	[
		FROM <表1>,<表2>,...
		[WHERE <表达式>]
		[GROUP BY <group by definition>]
		[HAVING <expression> [{<operation><expression>}...]]
		[ODER BY <order by definition>]
		[LIMIT [<offset>,] <row count>]
	]
SELECT [字段1,字段2,……,字段n]
FROM [表或视图]
WHERE [查询条件 ]
```

其中，各条子句的含义如下：
* {\*|<字段列表>}包含星号通配符选择字段列表，表示查询的字段，其中字段列至少包含一个字段名称，如果需要查询多个字段，多个字段之间用**逗号**隔开，最后一个字段后不要加逗号；
* FROM<表1>,<表2>,... 表1和表2表示查询数据的来源，可以是单个或者多个；
* WHERE子句是可选项，如果选择该项，将限定查询行必须满足的查询条件；
* GROUP BY<字段> 该子句告诉MySQL如何显示查询出来的数据，并按照指定的字段分组；
* [ORDER BY<字段>] 该子句告诉MySQL按什么样的顺序显示查询出来的数据，可以进行的排序有：升序(ASC)、降序(DESC)；
* [LIMIT[<offset>,]<row count>] 该子句告诉MySQL每次显示查询出来的数据条数；

**示例：** 下面以例子说明如何使用SELECT从单个表中获取数据：

首先定义数据表：

```
mysql> CREATE TABLE fruits
    -> (
    -> f_id CHAR(10) NOT NULL,
    -> s_id INT NOT NULL,
    -> f_name CHAR(255) NOT NULL,
    -> f_price DECIMAL(8,2) NOT NULL,
    -> PRIMARY KEY(f_id)
    -> );
Query OK, 0 rows affected (0.05 sec)
```

向表中插入数据：

```
mysql> INSERT INTO fruits (f_id, s_id, f_name, f_price)
    -> VALUES('a1',101,'apple',5.2),
    -> ('b1',101,'blackberry',10.2),
    -> ('bs1',102,'orange',11.2),
    -> ('bs2',105,'melon',8.2),
    -> ('t1',102,'banana',10.3),
    -> ('t2',102,'grape',5.3),
    -> ('o2',103,'coconut',9.2),
    -> ('c0',101,'cherry',3.2),
    -> ('a2',103,'apricot',2.2),
    -> ('l2',104,'lemon',6.4),
    -> ('b2',104,'berry',7.6),
    -> ('m1',106,'mango',15.7),
    -> ('m2',105,'xbabay',3.6),
    -> ('t4',107,'xbababa',3.6),
    -> ('m3',105,'xxtt',11.6),
    -> ('b5',107,'xxxx',3.6);
Query OK, 16 rows affected (0.05 sec)
Records: 16  Duplicates: 0  Warnings: 0
```

使用SELECT语句查询f_id和f_name字段的数据：

```
mysql> SELECT f_id,f_name FROM fruits;
+------+------------+
| f_id | f_name     |
+------+------------+
| a1   | apple      |
| a2   | apricot    |
| b1   | blackberry |
| b2   | berry      |
| b5   | xxxx       |
| bs1  | orange     |
| bs2  | melon      |
| c0   | cherry     |
| l2   | lemon      |
| m1   | mango      |
| m2   | xbabay     |
| m3   | xxtt       |
| o2   | coconut    |
| t1   | banana     |
| t2   | grape      |
| t4   | xbababa    |
+------+------------+
16 rows in set (0.05 sec)
```

该语句的执行过程是，SELECT语句决定了要查询的列值，在这里查询f_id和f_name两个字段的值，FROM子句指定了数据的来源，这里指定数据fruits，因此返回结果为fruits表中f_id和f_name两个字段下所有的数据。其显示顺序为添加到表中的顺序。

---

## 2.单表查询

单表查询是指从一张表中查询所需的数据。基本的单表查询方式主要有：
1. 查询所有字段；
2. 查询指定字段；
3. 查询指定记录；
4. 查询空值；
5. 多条件查询；
6. 对查询结果进行排序；
7. ……

### 2.1 查询所有字段

**1. 在SELECT语句中使用星号(\*)通配符查询所有字段**

SELECT查询记录最简单的形式就是从一个表达式中检索所有记录，实现的方法是使用星号(\*)通配符指定查找所有列的名称。语法格式为：`SELECT * FROM 表名;`

**示例：** 从fruits表中检索所有字段的数据

```
mysql> SELECT * FROM fruits;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| b5   |  107 | xxxx       |    3.60 |
| bs1  |  102 | orange     |   11.20 |
| bs2  |  105 | melon      |    8.20 |
| c0   |  101 | cherry     |    3.20 |
| l2   |  104 | lemon      |    6.40 |
| m1   |  106 | mango      |   15.70 |
| m2   |  105 | xbabay     |    3.60 |
| m3   |  105 | xxtt       |   11.60 |
| o2   |  103 | coconut    |    9.20 |
| t1   |  102 | banana     |   10.30 |
| t2   |  102 | grape      |    5.30 |
| t4   |  107 | xbababa    |    3.60 |
+------+------+------------+---------+
```

可以看到，使用星号(*)通配符时，将返回所有列，列按照定义表时的顺序显示。


**2. 在SELECT语句中指定所有字段**

根据SELECT语句的格式，SELECT关键字后面的字段名为将要查找的数据，因此可以见表中所有字段的名称跟在SELECT子句之后。若忘记字段名称，可以使用DESC命令查看表的结构。（

#### 提示：

一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符'*'。通配符虽然可以节省输入查询语句的时间，但获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。

<br>

### 2.2 查询指定字段

**1. 查询单个字段**

查询表中的某一个字段，语法格式为：`SELECT 列明 FROM 表名;`

**示例：** 查询fruits表中f_name列所有水果名

```
mysql> SELECT f_name FROM fruits;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| blackberry |
| berry      |
| xxxx       |
| orange     |
| melon      |
| cherry     |
| lemon      |
| mango      |
| xbabay     |
| xxtt       |
| coconut    |
| banana     |
| grape      |
| xbababa    |
+------------+
```

**2. 查询多个字段**

使用SELECT声明，可以获取多个字段下的数据，只需要在关键字SELECT后面指定要查找的字段的名称，不同字段名称之间使用逗号(,)分隔开，最后一个字段后面不需要加逗号，。

语法格式为：`SELECT 字段名1,字段名2,……,字段名n FROM 表名;`

**示例：** 从fruits表中获取f_name和f_price两列

```
mysql> SELECT f_name,f_price FROM fruits;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| blackberry |   10.20 |
| berry      |    7.60 |
| xxxx       |    3.60 |
| orange     |   11.20 |
| melon      |    8.20 |
| cherry     |    3.20 |
| lemon      |    6.40 |
| mango      |   15.70 |
| xbabay     |    3.60 |
| xxtt       |   11.60 |
| coconut    |    9.20 |
| banana     |   10.30 |
| grape      |    5.30 |
| xbababa    |    3.60 |
+------------+---------+
```

<br>

### 2.3 查询指定记录

数据库中包含大量的数据，根据特殊要求，可能只需要查询表中的指定数据，即对数据进行过滤。在SELECT语句中，通过WHERE子句可以对数据进行过滤。

语法格式为：

```
SELECT 字段名1,字段名2,……,字段名n
FROM 表名
WHERE 查询条件;
```

在WHERE子句中，MySQL提供了一系列的条件判断：

**WHERE条件判断符**

|操作符|说明|
|:---|:---|
|=|相等|
|<>,!=|不相等|
|<|小于|
|<=|小于或等于|
|>|大于|
|>=|大于或等于|
|BETWEEN&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|位于两者之间&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|

**示例1：** 查询价格为10.2元的水果的名称

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price=10.2;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| blackberry |   10.20 |
+------------+---------+
```

**示例2：** 查找名称为"apple"的水果的价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_name='apple';
+--------+---------+
| f_name | f_price |
+--------+---------+
| apple  |    5.20 |
+--------+---------+
```

**示例3：** 查找价格小于10的水果的名称

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price<10;
+---------+---------+
| f_name  | f_price |
+---------+---------+
| apple   |    5.20 |
| apricot |    2.20 |
| berry   |    7.60 |
| xxxx    |    3.60 |
| melon   |    8.20 |
| cherry  |    3.20 |
| lemon   |    6.40 |
| xbabay  |    3.60 |
| coconut |    9.20 |
| grape   |    5.30 |
| xbababa |    3.60 |
+---------+---------+
```

<br>

### 2.4 带IN关键字的查询

IN操作符用来查询满足指定范围内的条件的记录，使用IN操作符，将所有检索条件用括号括起来，检索条件之间用逗号分隔开，只需要满足条件范围内的一个指即为匹配项。

**示例：** 查询s_id为101和102的记录

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id IN (101,102) ORDER BY f_name;
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  102 | banana     |   10.30 |
|  101 | blackberry |   10.20 |
|  101 | cherry     |    3.20 |
|  102 | grape      |    5.30 |
|  102 | orange     |   11.20 |
+------+------------+---------+
```

相反的，可以使用关键字NOT来检索不在条件范围内的记录

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id NOT IN (101,102) ORDER BY f_name;
+------+---------+---------+
| s_id | f_name  | f_price |
+------+---------+---------+
|  103 | apricot |    2.20 |
|  104 | berry   |    7.60 |
|  103 | coconut |    9.20 |
|  104 | lemon   |    6.40 |
|  106 | mango   |   15.70 |
|  105 | melon   |    8.20 |
|  107 | xbababa |    3.60 |
|  105 | xbabay  |    3.60 |
|  105 | xxtt    |   11.60 |
|  107 | xxxx    |    3.60 |
+------+---------+---------+
```

<br>

### 2.5 带BETWEEN AND的范围查询

BETWEEN AND 用来查询某个范围内的值，该操作符需要两个参数，即范围的开始值和结束值，若字段满足指定的范围查询条件，则这些记录被返回。

**示例：** 查询价格在2.00元到10.20元之间的水果的名称和价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price BETWEEN 2.00 AND 10.20;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| blackberry |   10.20 |
| berry      |    7.60 |
| xxxx       |    3.60 |
| melon      |    8.20 |
| cherry     |    3.20 |
| lemon      |    6.40 |
| xbabay     |    3.60 |
| coconut    |    9.20 |
| grape      |    5.30 |
| xbababa    |    3.60 |
+------------+---------+
```

BETWEEN AND操作符前也可以加关键字NOT，表示指定范围外的值，若字段值不满足指定的范围内的值，则这些记录被返回。

**示例：** 查询价格在2.00元到10.20元之外的水果名称和价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price NOT BETWEEN 2.00 AND 10.20;
+--------+---------+
| f_name | f_price |
+--------+---------+
| orange |   11.20 |
| mango  |   15.70 |
| xxtt   |   11.60 |
| banana |   10.30 |
+--------+---------+
```

<br>

### 2.6 带LIKE的字符匹配查询

在MySQL中，可以使用LIKE关键字对通配符尽心匹配查找，通过创建查找模式对表中的数据进行比较。

通配符时一种在SQL的WHERE条件子句中拥有特殊意思的字符，SQL语句中支持多种通配符，可以和LIKE一起使用的通配符有'%'和'_'。

**1. 百分号通配符'%'，匹配任意长的字符，甚至包括零字符**

**示例：** 查找所有以'b'字母开头的水果

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE 'b%';
+------+------------+
| f_id | f_name     |
+------+------------+
| b1   | blackberry |
| b2   | berry      |
| t1   | banana     |
+------+------------+
```

该语句查询的结果返回所有以'b'开头的水果的id和name，'%'告诉MySQL，返回所有以字母'b'开头的记录，不管'b'后面有多少个字符。

在搜索匹配时通配符'%'可以放在不同的位置

**示例：** 在fruits表中，查询f_name中包含字母'g'的记录

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE '%g%';
+------+--------+
| f_id | f_name |
+------+--------+
| bs1  | orange |
| m1   | mango  |
| t2   | grape  |
+------+--------+
```

**示例：** 查询以'b'开头，并以'y'结尾的水果的名称

```
mysql> SELECT f_name FROM fruits WHERE f_name LIKE 'b%y';
+------------+
| f_name     |
+------------+
| blackberry |
| berry      |
+------------+
```

通过以上查询结果，可以看到，'%'用于匹配在指定的位置的任意数目的字符。

**2.下划线通配符'_'，一次只能匹配任意一个字符**

下划线通配符'_'用法和'%'相同，区别是'%'可以匹配多个字符，而'_'只能匹配任意单个字符，若需要匹配多个字符，则需要使用相同个数的'_'。

**示例：** 在fruits表中，查询以字母'y'结尾，且'y'前面只有4个字母的记录

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE '____y';
+------+--------+
| f_id | f_name |
+------+--------+
| b2   | berry  |
+------+--------+
```

从结果可以看到，以'y'结尾且前面只有4个字母的记录只有一条。其他记录的f_name字段也有以'y'结尾的，但其总的字符串长度不为5，因此不在返回结果中。

<br>

### 2.7查询空值

数据表创建的时候，设计者可以指定某列中是否可以包含空值(NULL)。空值不同于0，也不同于空字符串。空值一般表示数据未知、不适用或将在以后添加数据。

在SELECT语句中使用IS NULL子句，可以查询某字段内容为空的记录。

下面创建数据表customers，并插入数据：

```
mysql> CREATE TABLE customers
    -> (
    -> c_id INT NOT NULL AUTO_INCREMENT,
    -> c_name CHAR(50) NOT NULL,
    -> c_address CHAR(50) NULL,
    -> c_city CHAR(50) NULL,
    -> c_zip CHAR(50) NULL,
    -> c_contact CHAR(50) NULL,
    -> c_email CHAR(255) NULL,
    -> PRIMARY KEY (c_id)
    -> );
Query OK, 0 rows affected (0.17 sec)

mysql> INSERT INTO customers(c_id,c_name,c_address,c_city,c_zip,c_contact,c_email)
    -> VALUES(10001,'RedHook','200 Street','Tianjin','300000','LiMing','LMing@163.com'),
    -> (10002,'Stars','333 Fromage Lane','Dalian','116000','Zhangbo','Jerry@hotmail.com'),
    -> (10003,'Netbhood','1 Sunny Place','Qingdao','266000','LuoCong',NULL),
    -> (10004,'JOTO','829 Riverside Drive','Haikou','5700000','YangShan','sam@hotmail.com');
Query OK, 4 rows affected (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

**示例：** 查询customers表中c_email不为空的记录的c_id、c_name和c_email字段值

```
mysql> SELECT c_id,c_name,c_email FROM customers WHERE c_email IS NOT NULL;
+-------+---------+-------------------+
| c_id  | c_name  | c_email           |
+-------+---------+-------------------+
| 10001 | RedHook | LMing@163.com     |
| 10002 | Stars   | Jerry@hotmail.com |
| 10004 | JOTO    | sam@hotmail.com   |
+-------+---------+-------------------+
```

<br>

### 2.8 带AND的多条件查询

使用SELECT查询时，可以增加查询的限制条件，这样可以使查询的结果更加精确。MySQL在WHERE子句中使用AND操作符限定只有满足所有查询条件的记录才会被返回。可以使用AND连接连个甚至多个查询条件，多个表达式之间用AND分开。

**示例1：** 在fruits表中查询s_id=101，并且f_price大于等于5的水果价格和名

```
mysql> SELECT f_id,f_price,f_name FROM fruits WHERE s_id='101' AND f_price>=5;
+------+---------+------------+
| f_id | f_price | f_name     |
+------+---------+------------+
| a1   |    5.20 | apple      |
| b1   |   10.20 | blackberry |
+------+---------+------------+
```

**示例2：** 在fruits表中查询s_id=101或者102，且f_price大于5，并且f_name='apple'的水果价格和名称

```
mysql> SELECT f_id,f_price,f_name FROM fruits WHERE s_id IN('101','102') AND f_price>=5 AND f_name='apple';
+------+---------+--------+
| f_id | f_price | f_name |
+------+---------+--------+
| a1   |    5.20 | apple  |
+------+---------+--------+
```

<br>

### 2.9 带OR的所条件查询

与AND相反，在WHERE声明中使用OR操作符，表示只需要满足其中一个条件的记录即可返回。OR也可以连续两个甚至多个查询条件，多个条件表达式之间用OR分开。

**示例：** 查询s_id=101或102的水果供应商的f_price和f_name

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id=101 OR s_id=102;
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  101 | blackberry |   10.20 |
|  102 | orange     |   11.20 |
|  101 | cherry     |    3.20 |
|  102 | banana     |   10.30 |
|  102 | grape      |    5.30 |
+------+------------+---------+
```

这里也可以使用IN操作符使实现与OR相同的功能：

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id IN (101,102);
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  101 | blackberry |   10.20 |
|  102 | orange     |   11.20 |
|  101 | cherry     |    3.20 |
|  102 | banana     |   10.30 |
|  102 | grape      |    5.30 |
+------+------------+---------+
```

这里可以看到，OR操作符和IN操作符使用后的结果是一样的，它们可以实现相同的功能。但是使用IN操作符是的检索语句更加简洁明了，并且IN执行的速度高于OR。更重要的是，IN操作符可以执行更加复杂的嵌套查询。

#### 提示：

OR可以和AND一起使用，但在使用时要注意两者的优先级，由于AND的优先级高于OR，因此对AND两边的操作数进行操作，再与OR中的操作数集合。

<br>

### 2.10 查询结果不重复

从前面的例子可以看到，SELECT查询返回所有匹配的行。例如，在查询fruits表中所有的s_id，其结果为：

```
mysql> SELECT s_id FROM fruits;
+------+
| s_id |
+------+
|  101 |
|  103 |
|  101 |
|  104 |
|  107 |
|  102 |
|  105 |
|  101 |
|  104 |
|  106 |
|  105 |
|  105 |
|  103 |
|  102 |
|  102 |
|  107 |
+------+
```

可以看到，查询返回的记录有重复的s_id。若需要消除重复的记录值，可以使用DISTINCT关键字指示MySQL消除重复的记录。

语法格式为：`SELECT DISTINCT 字段名 FROM 表名;`

**示例：** 查询fruits表中s_id字段的值，返回s_id字段值不得重复

```
mysql> SELECT DISTINCT s_id FROM fruits;
+------+
| s_id |
+------+
|  101 |
|  103 |
|  104 |
|  107 |
|  102 |
|  105 |
|  106 |
+------+
```

<br>

### 2.11 对查询结果排序

从前面的查询结果可以看到，有些字段的值是没有任何顺序的。MySQL可以通过在SELECT语句中使用ORDER BY子句对查询结果进行排序。

**1. 单列排序**

查询f_name字段，结果如下：

```
mysql> SELECT f_name FROM fruits;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| blackberry |
| berry      |
| xxxx       |
| orange     |
| melon      |
| cherry     |
| lemon      |
| mango      |
| xbabay     |
| xxtt       |
| coconut    |
| banana     |
| grape      |
| xbababa    |
+------------+
```

可以看到，查询的数据并没有一个特定的顺序显示，若没有对它们进行拍寻，它们将按照插入数据表中的顺序来显示。

下面使用ORDER BY子句对执行的列进行数据排序。

**示例：** 查询fruits表的f_name字段值，并对其进行排序

```
mysql> SELECT f_name FROM fruits ORDER BY f_name;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| banana     |
| berry      |
| blackberry |
| cherry     |
| coconut    |
| grape      |
| lemon      |
| mango      |
| melon      |
| orange     |
| xbababa    |
| xbabay     |
| xxtt       |
| xxxx       |
+------------+
```

通过指定ORDER BY子句，MySQL对查询的name列的数据，按字母表的顺序进行了升序排序。

**2. 多列排序**

对多列数据进行排序，须将排序的列之间用逗号隔开。

**示例：** 查询fruits表中的f_name和f_price字段，先按f_name排序，再按f_price排序

```
mysql> SELECT f_name,f_price FROM fruits ORDER BY f_name,f_price;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| banana     |   10.30 |
| berry      |    7.60 |
| blackberry |   10.20 |
| cherry     |    3.20 |
| coconut    |    9.20 |
| grape      |    5.30 |
| lemon      |    6.40 |
| mango      |   15.70 |
| melon      |    8.20 |
| orange     |   11.20 |
| xbababa    |    3.60 |
| xbabay     |    3.60 |
| xxtt       |   11.60 |
| xxxx       |    3.60 |
+------------+---------+
```

#### 提示：

在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。若第一列数据中的所有值都是唯一的，将不再对第二列进行排序。

**3. 指定排序方向**

默认情况下，查询数据按字母升序进行排序(从A~Z)，但数据的排序并不仅限于此，还可以使用ORDER BY对查询结果进行降序排序(从Z~A)，这可以通过关键字DESC实现。

与DESC相反的是ASC（升序排序）

**示例：** 查询fruits表中的f_name和f_price字段，对结果按f_price降序方式排序

```
mysql> SELECT f_name,f_price FROM fruits ORDER BY f_price DESC;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| mango      |   15.70 |
| xxtt       |   11.60 |
| orange     |   11.20 |
| banana     |   10.30 |
| blackberry |   10.20 |
| coconut    |    9.20 |
| melon      |    8.20 |
| berry      |    7.60 |
| lemon      |    6.40 |
| grape      |    5.30 |
| apple      |    5.20 |
| xxxx       |    3.60 |
| xbabay     |    3.60 |
| xbababa    |    3.60 |
| cherry     |    3.20 |
| apricot    |    2.20 |
+------------+---------+
```

**示例：** 查询fruits表，先按f_price降序排序，再按f_name字段升序排序

```
mysql> SELECT f_price,f_name FROM fruits ORDER BY f_price DESC, f_name;
+---------+------------+
| f_price | f_name     |
+---------+------------+
|   15.70 | mango      |
|   11.60 | xxtt       |
|   11.20 | orange     |
|   10.30 | banana     |
|   10.20 | blackberry |
|    9.20 | coconut    |
|    8.20 | melon      |
|    7.60 | berry      |
|    6.40 | lemon      |
|    5.30 | grape      |
|    5.20 | apple      |
|    3.60 | xbababa    |
|    3.60 | xbabay     |
|    3.60 | xxxx       |
|    3.20 | cherry     |
|    2.20 | apricot    |
+---------+------------+
```

DESC关键字只对其前面的列进行降序排序，在这里只对f_price排序，而没有对f_name尽心排序，因此，f_price按降序排序，而f_name列仍按升序排序。

若想对多列都进行降序排序，必须要在每一列的列名后面加DESC关键字。

<br>

### 2.12 分组查询

分组查询是对数据按照某个或多个字段进行分组，MySQL中使用GROUP BY关键字对数据进行分组，基本语法形式为：`[GROUP BY 字段][HAVING <条件表达式>]`

字段值为进行分组时所依据的列名称；

"HAVING <条件表达式>"指定满足表达式限定条件的结果将被显示。

**1. 创建分组**

GROUP BY关键字通常和集合函数一起使用，例如：MAX()、MIN()、COUNT()、SUN()、AVG()。

**示例1：** 根据s_id对fruits表中的数据进行分组

```
mysql> SELECT s_id, COUNT(*) AS TOTAL FROM fruits GROUP BY s_id;
+------+-------+
| s_id | TOTAL |
+------+-------+
|  101 |     3 |
|  103 |     2 |
|  104 |     2 |
|  107 |     2 |
|  102 |     3 |
|  105 |     3 |
|  106 |     1 |
+------+-------+
```

查询结果显示，s_id表示供应商的ID，TOTAL字段使用COUNT()函数计算得出。GROUP BY子句按照s_id排序对数据分组。

若要查看每个供应商提供的水果的种类的名称，MySQL提供了GROUP_CONCAT()函数，将每个分组中各个字段的值显示出来。

**示例：** 根据s_id对fruits表中的数据进行分组，将每个供应商的水果名称显示出来

```
mysql> SELECT s_id,GROUP_CONCAT(f_name) AS Names FROM fruits GROUP BY s_id;
+------+-------------------------+
| s_id | Names                   |
+------+-------------------------+
|  101 | apple,blackberry,cherry |
|  102 | orange,banana,grape     |
|  103 | apricot,coconut         |
|  104 | berry,lemon             |
|  105 | melon,xbabay,xxtt       |
|  106 | mango                   |
|  107 | xxxx,xbababa            |
+------+-------------------------+
```

由结果可以看到，GROUP_CONCAT()函数将每个分组中的名称都显示出来了，其名称的个数与COUNT()函数计算出来的相同。

**2. 使用HAVING过滤分组**

GROUP BY可以和HAVING一起限定显示记录所需满足的条件，只有满足条件的分组才会被显示。

**示例：** 根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息

```
mysql> SELECT s_id,GROUP_CONCAT(f_name) AS Names
    -> FROM fruits
    -> GROUP BY s_id HAVING COUNT(f_name)>1;
+------+-------------------------+
| s_id | Names                   |
+------+-------------------------+
|  101 | apple,blackberry,cherry |
|  102 | orange,banana,grape     |
|  103 | apricot,coconut         |
|  104 | berry,lemon             |
|  105 | melon,xbabay,xxtt       |
|  107 | xxxx,xbababa            |
+------+-------------------------+
```

#### 提示：

HAVING关键字和WHERE关键字都用来过滤数据。两者的区别在于，HAVING再数据分组之后进行过滤来选择分组，而WHERE再分组之前用来选择记录。

**3. 在GROUP BY子句中使用WITH ROLLUP**

使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算出查询出的所有记录的综合，即统计记录数量。

**示例：** 根据s_id对fruits表中的数据进行分组，并显示记录数量

```
mysql> SELECT s_id,COUNT(*) AS Total
    -> FROM fruits
    -> GROUP BY s_id WITH ROLLUP;
+------+-------+
| s_id | Total |
+------+-------+
|  101 |     3 |
|  102 |     3 |
|  103 |     2 |
|  104 |     2 |
|  105 |     3 |
|  106 |     1 |
|  107 |     2 |
| NULL |    16 |
+------+-------+
```

**4. 多字段分组**

使用GROUP BY可以对多个字段进行分组，GROUP BY关键字后面跟需要分组的字段，MySQL根据多字段的值来进行层次分组，分组层次从左到右，即先按第一个字段分组，然后在第一个字段值相同的记录中，再根据第二个字段的值进行分组……以此类推。

**示例：** 根据s_id和f_name字段对fruits表中的数据进行分组

```
mysql> SELECT * FROM fruits GROUP BY s_id,f_name;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| b5   |  107 | xxxx       |    3.60 |
| bs1  |  102 | orange     |   11.20 |
| bs2  |  105 | melon      |    8.20 |
| c0   |  101 | cherry     |    3.20 |
| l2   |  104 | lemon      |    6.40 |
| m1   |  106 | mango      |   15.70 |
| m2   |  105 | xbabay     |    3.60 |
| m3   |  105 | xxtt       |   11.60 |
| o2   |  103 | coconut    |    9.20 |
| t1   |  102 | banana     |   10.30 |
| t2   |  102 | grape      |    5.30 |
| t4   |  107 | xbababa    |    3.60 |
+------+------+------------+---------+
```

由结果可以看到，查询记录先按照s_id进行分组，再对f_name字段按不同的值进行分组。

**5. GROUP BY和ORDER BY一起使用**

在某些情况下需要对分组进行排序，ORDER BY用来对查询的记录排序，和GROUP BY一起使用可以完成对分组的排序。

首先创建表orderitems，并向表中插入数据

```
mysql> CREATE TABLE orderitems
    -> (
    -> o_num INT NOT NULL,
    -> o_item INT NOT NULL,
    -> f_id CHAR(10) NOT NULL,
    -> quantity INT NOT NULL,
    -> item_price DECIMAL(8,2) NOT NULL,
    -> PRIMARY KEY (o_num,o_item)
    -> );
Query OK, 0 rows affected (0.11 sec)

mysql> INSERT INTO orderitems(o_num,o_item,f_id,quantity,item_price)
    -> VALUES(30001,1,'a1',10,5.2),
    -> (30001,2,'b2',3,7.6),
    -> (30001,3,'bs1',5,11.2),
    -> (30001,4,'bs2',15,9.2),
    -> (30002,1,'b3',2,20.0),
    -> (30003,1,'c0',100,10),
    -> (30004,1,'o2',50,2.50),
    -> (30005,1,'c0',5,10),
    -> (30005,2,'b1',10,8.99),
    -> (30005,3,'a2',10,2.2),
    -> (30005,4,'m1',5,14.99);
Query OK, 11 rows affected (0.05 sec)
Records: 11  Duplicates: 0  Warnings: 0
```

**示例：** 查询订单价格大于100的订单号和总订单价格

```
mysql> SELECT o_num,SUM(quantity * item_price) AS orderTotal
    -> FROM orderitems
    -> GROUP BY o_num
    -> HAVING SUM(quantity * item_price)>=100;
+-------+------------+
| o_num | orderTotal |
+-------+------------+
| 30001 |     268.80 |
| 30003 |    1000.00 |
| 30004 |     125.00 |
| 30005 |     236.85 |
+-------+------------+
```

可以看到，返回结果中的orderTotal列的总订单价格并没有按照一定顺序来显示，接下来，使用ORDER BY关键字按照总订单价格排序显示：

```
mysql> SELECT o_num,SUM(quantity*item_price) AS orderTotal
    -> FROM orderitems
    -> GROUP BY o_num
    -> HAVING SUM(quantity*item_price)>=100
    -> ORDER BY orderTotal;
+-------+------------+
| o_num | orderTotal |
+-------+------------+
| 30004 |     125.00 |
| 30005 |     236.85 |
| 30001 |     268.80 |
| 30003 |    1000.00 |
+-------+------------+
```

#### 提示：

当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序。即ORDER BY和ROLLUP时相互排斥的。

<br>

### 2.13 使用LIMIT限制查询结果的数量

SELECT返回所有匹配的行，有可能时表中所有的行，若仅仅需要返回第一行或者前几行，可以使用LIMIT关键字。

基本语法格式为：`LIMIT [位置偏移量,] 行数`

其中，“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，若不指定“位置偏移量”，将会从表中的第一条记录开始；第二个参数“行数”指示返回的记录条数。

**示例1：** 显示fruits表查询结果的前4行

```
mysql> SELECT * FROM fruits LIMIT 4;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
+------+------+------------+---------+
```

由结果剋有看到，该语句没有指定返回记录的"位置偏移量"参数，显示结果从第一行开始，“行数”参数为4，因此返回的结果为表中的前4行记录。

**示例2：** 在fruits表中，使用LIMIT子句，返回从第5个记录开始的，行数长度为3的记录

```
mysql> SELECT * FROM fruits LIMIT 4, 3;
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b5   |  107 | xxxx   |    3.60 |
| bs1  |  102 | orange |   11.20 |
| bs2  |  105 | melon  |    8.20 |
+------+------+--------+---------+
```

由结果可以看到，第一个数字'4'表示从第5行开始（位置偏移量从0开始），第二个数字3表示返回的行数。

所以，带一个参数的LIMIT指定从查询结果中的首行开始，唯一的参数表示返回的行数。带两个参数的LIMIT可以返回从任何一个位置开始的指定的行数。

也可以使用`LIMIT m OFFSET n`，表示偏移量为m，行数为n：

```
mysql> SELECT * FROM fruits LIMIT 4 OFFSET 3;
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b2   |  104 | berry  |    7.60 |
| b5   |  107 | xxxx   |    3.60 |
| bs1  |  102 | orange |   11.20 |
| bs2  |  105 | melon  |    8.20 |
+------+------+--------+---------+
```

---

## 3.使用聚合函数查询

MySQL提供一些查询功能，可以对获取的数据进行分析和报告。这些函数的功能有：
* 计算数据表中记录行数的总数；
* 计算某个字段列下数据的总和；
* 计算表中某个字段下的最大值、最小值或平均值；

**MySQL聚合函数**

|函数|作用|
|:---|:---|
|ACG()|返回某列的平均值|
|COUNT()&#160;&#160;&#160;&#160;&#160;&#160;|返回某列的行数|
|MAX()|返回某列的最大值&#160;&#160;&#160;&#160;&#160;&#160;|
|MIN()|返回某列的最小值|
|SUM()|返回某列值的和|

<br>

### 3.1 COUNT()函数

COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数。其使用方法有两种：
* COUNT(*)：计算表中总的行数，不管某列有数值或者为空值；
* COUNT(字段名)：计算指定列下总的行数，计算时忽略空值的行；

**示例1：** 查询customers表中总的行数

```
mysql> SELECT COUNT(*) AS cust_num FROM customers;
+----------+
| cust_num |
+----------+
|        4 |
+----------+
```

由查询结果可以看到，COUNT(*)返回customers表中记录的总行数，不管其值时什么，返回总数的名称为cust_num。

**示例2：** 查询customers表中由电子邮箱的顾客的总数

```
mysql> SELECT COUNT(c_email) AS email_num FROM customers;
+-----------+
| email_num |
+-----------+
|         3 |
+-----------+
```

由查询结果可以看到，表中4个customer只有3个有email，customer的email为空值NULL的记录不会被COUNT()函数计算。

**示例3：** 在orderitems表中，使用COUNT()函数统计不同订单号中订购的水果种类

```
mysql> SELECT o_num,COUNT(f_id)
    -> FROM orderitems
    -> GROUP BY o_num;
+-------+-------------+
| o_num | COUNT(f_id) |
+-------+-------------+
| 30001 |           4 |
| 30002 |           1 |
| 30003 |           1 |
| 30004 |           1 |
| 30005 |           4 |
+-------+-------------+
```

可以看到，GROUP BY关键字先按照订单进行分组，然后计算每个分组中的总记录数。

<br>

### 3.2 SUM()函数

SUM()是一个求总和的函数，返回指定列值的总和。

**示例1：** 在orderitems表中查询30005号订单一共购买的水果总量

```
mysql> SELECT SUM(quantity) AS items_total
    -> FROM orderitems
    -> WHERE o_num=30005;
+-------------+
| items_total |
+-------------+
|          30 |
+-------------+
```

SUM()可以与GROUP BY一起使用，来计算每个分组的总和。

**示例2：** 在orderitems表中，使用SUM()函数统计不同订单号中订购的水果总和

```
mysql> SELECT o_num,SUM(quantity) AS items_total
    -> FROM orderitems
    -> GROUP BY o_num;
+-------+-------------+
| o_num | items_total |
+-------+-------------+
| 30001 |          33 |
| 30002 |           2 |
| 30003 |         100 |
| 30004 |          50 |
| 30005 |          30 |
+-------+-------------+
```

#### 提示：

SUM()函数在计算中，忽略列值为NULL的行。

<br>

### 3.3 AVG()函数

AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。

**示例1：** 在fruits表中，查询s_id=103的供应商的水果价格的平均值

```
mysql> SELECT AVG(f_price) AS avg_price
    -> FROM fruits
    -> WHERE s_id=103;
+-----------+
| avg_price |
+-----------+
|  5.700000 |
+-----------+
```

AVG()可以与GROUP BY一起使用，来计算每个分组的平均值

**示例2：** 在fruits表中，查询每一个供应商的水果价格的平均值

```
mysql> SELECT s_id,AVG(f_price) AS avg_price
    -> FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | avg_price |
+------+-----------+
|  101 |  6.200000 |
|  103 |  5.700000 |
|  104 |  7.000000 |
|  107 |  3.600000 |
|  102 |  8.933333 |
|  105 |  7.800000 |
|  106 | 15.700000 |
+------+-----------+
```

#### 提示：

AVG()函数使用时，其参数为要计算的列的名称，如果要得到多个列的多个平均值，则需要在每一列上都使用AVG()函数。

<br>

### 3.4 MAX()函数

MAX()函数返回指定列中的最大值。

**示例1：** 在fruits表中查市场上价格最高的水果值

```
mysql> SELECT MAX(f_price) AS max_price FROM fruits;
+-----------+
| max_price |
+-----------+
|     15.70 |
+-----------+
```

**示例2：** 在fruits表中查找不同供应商提供的价格最高的水果值

```
mysql> SELECT s_id,MAX(f_price) AS max_price FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | max_price |
+------+-----------+
|  101 |     10.20 |
|  103 |      9.20 |
|  104 |      7.60 |
|  107 |      3.60 |
|  102 |     11.20 |
|  105 |     11.60 |
|  106 |     15.70 |
+------+-----------+
```

MAX()函数不仅适用于查找数值类型，也可以用于字符类型。

**示例3：** 在fruits表中查找f_name的最大值

```
mysql> SELECT MAX(f_name) FROM fruits;
+-------------+
| MAX(f_name) |
+-------------+
| xxxx        |
+-------------+
```

由结果可以看到，MAX()函数可以对字母进行大小判断，并返回最大的字符或者字符串值。

<br>

### 3.5 MIN()函数

MIN()返回查询列表中的最小值

**示例1：** 在fruits表中查找市场上价格最低的水果值

```
mysql> SELECT MIN(f_price) AS min_price FROM fruits;
+-----------+
| min_price |
+-----------+
|      2.20 |
+-----------+
```

MIN()也可以和GROUP BY关键字一起使用

**示例2：** 在fruits表中查询不同供应商提供的价格最低的水果值

```
mysql> SELECT s_id,MIN(f_price) AS min_price
    -> FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | min_price |
+------+-----------+
|  101 |      3.20 |
|  103 |      2.20 |
|  104 |      6.40 |
|  107 |      3.60 |
|  102 |      5.30 |
|  105 |      3.60 |
|  106 |     15.70 |
+------+-----------+
```

同样，MIN()函数有MAX()函数类似，不仅使用与查找数值类型，也可应用于字符串类型。

---

## 4.连接查询

连接是关系数据库模型的主要特点。连接查询时关系型数据库中最主要的查询，主要包括内连接、外连接等。

### 4.1 内连接查询

内连接(INNER JOIN)使用比较运算符进行表间某（些）列数据的比较操作，并列出表中与连接条件相匹配的数据行，组合成新记录。也就是说，在内连接查询中，只有满足条件的记录才能出现在结果关系中。

首先创建数据表suppliers并插入数据：

```
mysql> CREATE TABLE suppliers
    -> (
    -> s_id INT NOT NULL AUTO_INCREMENT,
    -> s_name CHAR(50) NOT NULL,
    -> s_city CHAR(50) NULL,
    -> s_zip CHAR(50) NULL,
    -> s_call CHAR(50) NOT NULL,
    -> PRIMARY KEY (s_id)
    -> );
Query OK, 0 rows affected (0.13 sec)

mysql> INSERT INTO suppliers (s_id,s_name,s_city,s_zip,s_call)
    -> VALUES(101,'FastFruit Inc.','Tianjin','300000','48075'),
    -> (102,'LT Supplies','Chongqing','400000','44333'),
    -> (103,'ACME','Shanghi','200000','90046'),
    -> (104,'FNK Inc.','Zhongshan','528437','11111'),
    -> (105,'Good Set','Taiyuang','030000','22222'),
    -> (106,'Just Eat Ours','Beijing','010','45678'),
    -> (107,'DK Inc.','Zhengzhou','450000','33332');
Query OK, 7 rows affected (0.06 sec)
Records: 7  Duplicates: 0  Warnings: 0
```

**示例：** 在fruits表和suppliers表之间使用内连接查询

首先查看两个表的结构：

```
mysql> DESC fruits;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| f_id    | char(10)     | NO   | PRI | NULL    |       |
| s_id    | int(11)      | NO   |     | NULL    |       |
| f_name  | char(255)    | NO   |     | NULL    |       |
| f_price | decimal(8,2) | NO   |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql> DESC suppliers;
+--------+----------+------+-----+---------+----------------+
| Field  | Type     | Null | Key | Default | Extra          |
+--------+----------+------+-----+---------+----------------+
| s_id   | int(11)  | NO   | PRI | NULL    | auto_increment |
| s_name | char(50) | NO   |     | NULL    |                |
| s_city | char(50) | YES  |     | NULL    |                |
| s_zip  | char(50) | YES  |     | NULL    |                |
| s_call | char(50) | NO   |     | NULL    |                |
+--------+----------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
```

由结果可以看到，fruits表和suppliers表中都有相同数据类型的字段s_id，两个表通过s_id字段建立联系。

接下来从fruits表中查询f_name，f_price字段，从suppliers表中查询s_id，s_name：

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price FROM fruits, suppliers
    -> WHERE fruits.s_id = suppliers.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  103 | ACME           | apricot    |    2.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  102 | LT Supplies    | orange     |   11.20 |
|  105 | Good Set       | melon      |    8.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  103 | ACME           | coconut    |    9.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

这里，SELECT语句与前面所介绍的一个最大的差别是：SELECT后面指定的列分别属于两个不同的表，(f_name,f_price)在表fruits中，(s_name,s_id)在表表suppliers表中；同时FROM子句列出了两个表fruits和suppliers。WHERE子句子啊这里作为过滤条件，指明只有两个表中的s_id字段值相等的时候才符合连接查询的条件。返回结果中可以看到，显示的记录是由两个表中不同列值组成的新记录。

#### 提示：

因为fruits表和suppliers表中有相同的字段s_id，因此在比较的时候，需要完全限定表名（格式为："表名.列名"），若只给出s_id，MySQL将不知道指的是哪一个，并返回错误信息。

**示例：** 在fruits表和suppliers表之间，使用INNER JOIN语法进行内连接查询

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price
    -> FROM fruits INNER JOIN suppliers
    -> ON fruits.s_id = suppliers.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  103 | ACME           | apricot    |    2.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  102 | LT Supplies    | orange     |   11.20 |
|  105 | Good Set       | melon      |    8.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  103 | ACME           | coconut    |    9.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

这里的查询语句，两表之间的关系通过INNER JOIN指定。使用这种语法的时候，连接条件用**ON**子句给出而不是WHERE，ON和WHERE后面指定的条件相同。

若在一个连接查询中，涉及的两个表都是同一个表，这种查询称为**自连接查询**。

自连接是一种特殊的内连接，它指相互连接的表在物理上同为一张表，但可以在逻辑上分为两张表。

**示例：** 查询供应f_id='a1'的水果供应商提供的水果种类

```
mysql> SELECT f1.f_id,f1.f_name FROM fruits AS f1, fruits AS f2
    -> WHERE f1.s_id=f2.s_id AND f2.f_id='a1';
+------+------------+
| f_id | f_name     |
+------+------------+
| a1   | apple      |
| b1   | blackberry |
| c0   | cherry     |
+------+------------+
```

<br>

### 4.2 外连接查询

外连接查询将查询多个表中相关联的行，内连接时，返回查询结果集合中的仅是符合查询条件和连接条件的行。

但有时候需要包含没有关联的行中数据，即返回查询结果集合中的不仅包含符合连接条件的行，而且还包括左表（左外连接或左连接）、右表（右外连接或右连接）或两个连接表（全外连接）中所有数据行。

外连接分为左外连接和右外连接：
* LEFT JOIN（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录；
* RIGHT JOIN（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录；


**1. LEFT JOIN（左连接）**

左连接的结果包括LEFT OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。若左表的某行在右表中没有匹配行，则在相关联的结果行中，右表的所有选择列表列均为空值。

首先创建表orders，并插入数据

```
mysql> CREATE TABLE orders
    -> (
    -> o_num INT NOT NULL AUTO_INCREMENT,
    -> o_date DATETIME NOT NULL,
    -> c_id INT NOT NULL,
    -> PRIMARY KEY (o_num)
    -> );
Query OK, 0 rows affected (0.12 sec)

mysql> INSERT INTO orders(o_num,o_date,c_id)
    -> VALUES(3001,'2008=09=12',10001),
    -> (3002,'2008');
ERROR 1136 (21S01): Column count doesn't match value count at row 2
mysql> INSERT INTO orders(o_num,o_date,c_id)
    -> VALUES(30001,'2008-09-01',10001),
    -> (30002,'2008-09-12',10003),
    -> (30003,'2008-09-30',10004),
    -> (30004,'2008-10-03',10005),
    -> (30005,'2008-10-08',10001);
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0
```

**示例：** 在customers表和orders表中，查询所有客户，包括没有订单的客户

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers LEFT OUTER JOIN orders
    -> ON customers.c_id=orders.c_id;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10003 | 30002 |
| 10004 | 30003 |
| 10001 | 30005 |
| 10002 |  NULL |
+-------+-------+
```

结果显示了5条记录，ID等于10002的客户目前并没有下订单，所以对应的orders表中并没有该客户的订单信息，所以该条记录只读出了customers表中相应的值，而从orders表中取出的值为NULL。

**2.RIGHT JOIN（右连接）**

右连接是左连接的反向连接，将返回右表的所有行。如果右表的某行在左表中没有匹配行，左表将返回空值。

**示例：** 在customer表和orders表中，查询所有订单，包括没有客户的订单

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers RIGHT OUTER JOIN orders
    -> ON customers.c_id=orders.c_id;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10003 | 30002 |
| 10004 | 30003 |
|  NULL | 30004 |
| 10001 | 30005 |
+-------+-------+
```

结果显示了5条记录，订单号等于30004的订单的客户可能由于某种原因取消了该订单，对应的customers表中并没有该客户的信息，所以该条记录只取出了orders表中相应的值，而从customers表中取出的值为NULL。

### 4.3 复合条件连接查询

复合条件连接查询是在连接查询的过程中，通过添加过滤条件，显示查询的结果，使查询的结果更加准确。

**示例：** 在customers表和orders表中，使用INNER JOIN语法查询customers表中ID为10001的客户的订单信息

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers INNER JOIN orders
    -> ON customers.c_id=orders.c_id AND customers.c_id=10001;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10001 | 30005 |
+-------+-------+
```

结果显示，在连接查询时指定查询客户ID为10001的订单信息，添加了过滤条件之后返回的结果将会变少，因此返回结果只有两条记录。

**示例：** 在fruits表和suppliers表之间，使用INNER JOIN语法进行内连接查询，并对查询结果排序

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price
    -> FROM fruits INNER JOIN suppliers
    -> ON fruits.s_id=suppliers.s_id
    -> ORDER BY fruits.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  102 | LT Supplies    | orange     |   11.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  103 | ACME           | apricot    |    2.20 |
|  103 | ACME           | coconut    |    9.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  105 | Good Set       | melon      |    8.20 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

---

## 5.子查询

子查询指一个查询语句嵌套在另一个查询语句内部的查询。在SELECT子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。

子查询中常用的操作符有ANY(SOME)、ALL、IN、EXISTS。子查询可以添加到SELECT、UPDATE和DELETE语句中，而且可以进行多层嵌套。

子查询语句中也可以使用比较运算符，如"<"、"<="、">"、">="和"!="等。

### 5.1 带ANY、SOME关键字的子查询

ANY和SOME关键字是同义词，表示满足其中任一条件，它们允许创建一个表达式对子查询的返回值列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件。

下面定义两个表tbl1和tbl2并分别插入数据

```
mysql> CREATE TABLE tbl1 (num1 INT NOT NULL);
Query OK, 0 rows affected (0.07 sec)

mysql> CREATE TABLE tbl2 (num2 INT NOT NULL);
Query OK, 0 rows affected (0.14 sec)

mysql> INSERT INTO tbl1 VALUES (1),(5),(13),(27);
Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> INSERT INTO tbl2 VALUES (6),(14),(11),(20);
Query OK, 4 rows affected (0.05 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

ANY关键字接在一个比较操作符的后面，表示若与子查询返回的任何值比较为TRUE，则返回TRUE。

**示例：** 返回tbl2表的所有num2列，然后将tbl1中的num1的值与之进行比较，只要大于num2的任何1个值，即为符合查询条件的结果。

```
mysql> SELECT num1 FROM tbl1 WHERE num1>ANY(SELECT num2 FROM tbl2);
+------+
| num1 |
+------+
|   13 |
|   27 |
+------+

mysql> SELECT num1 FROM tbl1 WHERE num1>SOME(SELECT num2 FROM tbl2);
+------+
| num1 |
+------+
|   13 |
|   27 |
+------+
```

在子查询中，返回的tbl2表所有num2列结果为（6,14,11,20），然后tbl1中的num1列（1,5,13,27）与之进行比较，只要大于num2列的任意一个数即为符合条件的结果。

<br>

### 5.2 带ALL关键字的子查询

ALL关键字与ANY和SOME不同，使用ALL时需要同时满足所有内层查询的条件。

ALL关键字接在一个比较操作符后面，表示与子查询返回的所有值比较为TRUE，则返回TRUE。

```
mysql> SELECT num1 FROM tbl1 WHERE num1>ALL(SELECT num2 FROM tbl2);
+------+
| num1 |
+------+
|   27 |
+------+
```

<br>

### 5.3 带EXISTS关键字的查询

EXISTS关键字后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行，若至少返回一行，那么EXISTS的结果为TRUE，此时外层查询语句将进行查询；若没有返回任何行，那么EXISTS返回的结果为FALSE，此时外层语句将不进行查询。

**示例：** 查询suppliers表中是否存在s_id=107的供应商，若存在，则查询fruits表中的记录

```
mysql> SELECT * FROM fruits WHERE EXISTS (SELECT s_name FROM suppliers WHERE s_id=107);
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| b5   |  107 | xxxx       |    3.60 |
| bs1  |  102 | orange     |   11.20 |
| bs2  |  105 | melon      |    8.20 |
| c0   |  101 | cherry     |    3.20 |
| l2   |  104 | lemon      |    6.40 |
| m1   |  106 | mango      |   15.70 |
| m2   |  105 | xbabay     |    3.60 |
| m3   |  105 | xxtt       |   11.60 |
| o2   |  103 | coconut    |    9.20 |
| t1   |  102 | banana     |   10.30 |
| t2   |  102 | grape      |    5.30 |
| t4   |  107 | xbababa    |    3.60 |
+------+------+------------+---------+
```

EXISTS关键字可以和条件表达式一起使用。

**示例：** 查询suppliers表中是否存在s_id=107的供应商，若存在，则查询fruits表中的f_price大于10.20的记录

```
mysql> SELECT * FROM fruits
    -> WHERE f_price>10.20 AND EXISTS
    -> (SELECT s_name FROM suppliers WHERE s_id=107);
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| bs1  |  102 | orange |   11.20 |
| m1   |  106 | mango  |   15.70 |
| m3   |  105 | xxtt   |   11.60 |
| t1   |  102 | banana |   10.30 |
+------+------+--------+---------+
```

NOT EXISTS与EXISTS使用方法相同，但返回的结果相反。子查询若至少返回一行，那么NOT EXISTS的结果为FALSE，此时外层查询将不进行查询；若子查询中没有返回任何行，那么NOT EXISTS返回的结果为TRUE，此时外层语句将进行查询。

**示例：** 查询suppliers表中是否存在s_id=107的供应商，若不存在则查询fruits表中的记录

```
mysql> SELECT * FROM fruits
    -> WHERE NOT EXISTS
    -> (SELECT s_name FROM suppliers WHERE s_id=107);
Empty set (0.05 sec)
```

#### 提示：

EXISTS和NOT EXISTS的结果只取决于是否会返回行，而不取决于这些行的内容，所以这个子查询输入列表通常是无关紧要的。

<br>

### 5.4 带IN关键字的子查询

IN关键字进行子查询时，内层查询语句仅仅返回一个数据列，这个数据列的值将提供给外层查询语句进行比较操作。

**示例：** 在orderitems表中查询f_id为c0的订单号，并根据订单号查询具有订单号的客户c_id

```
mysql> SELECT * FROM fruits
    -> WHERE NOT EXISTS
    -> (SELECT s_name FROM suppliers WHERE s_id=107);
Empty set (0.05 sec)

mysql> SELECT c_id FROM orders WHERE o_num IN
    -> (SELECT o_num FROM orderitems WHERE f_id='c0');
+-------+
| c_id  |
+-------+
| 10004 |
| 10001 |
+-------+
```

SELECT语句中可以使用NOT IN关键字，其作用与IN正好相反。

**示例：** 与前一个例子类似，但是在SELECT语句中使用NOT IN关键字

```
mysql> SELECT c_id FROM orders WHERE o_num NOT IN
    -> (SELECT o_num FROM orderitems WHERE f_id='c0');
+-------+
| c_id  |
+-------+
| 10001 |
| 10003 |
| 10005 |
+-------+
```

<br>

### 5.5 带比较运算符的子查询

除了前面使用的">"比较运算符，子查询可以使用其他比较运算符，如"<"，"<="，"="，">="和"!="等。

**示例1：** 在suppliers表中查询s_city等于"Tianjin"的供应商的s_id，然后在fruits表中查询所有该提供商的水果的种类

```
mysql> SELECT s_id,f_name FROM fruits
    -> WHERE s_id=
    -> (SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city='Tianjin');
+------+------------+
| s_id | f_name     |
+------+------------+
|  101 | apple      |
|  101 | blackberry |
|  101 | cherry     |
+------+------------+
```

**示例2：** 在suppliers表中查询s_city等于"Tianjin"的供应商的s_id，然后在fruits表中查询所有非该提供商的水果的种类

```
mysql> SELECT s_id,f_name FROM fruits
    -> WHERE s_id <>
    -> (SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city='Tianjin');
+------+---------+
| s_id | f_name  |
+------+---------+
|  103 | apricot |
|  104 | berry   |
|  107 | xxxx    |
|  102 | orange  |
|  105 | melon   |
|  104 | lemon   |
|  106 | mango   |
|  105 | xbabay  |
|  105 | xxtt    |
|  103 | coconut |
|  102 | banana  |
|  102 | grape   |
|  107 | xbababa |
+------+---------+
```

---

## 6.合并查询结果

利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。UNION不适用关键字ALL，执行的时候删除重复的记录，所有返回的行都是唯一的；使用关键字ALL的作用是不删除重复行也不对结果进行自动排序。

基本语法格式如下：

```
SELECT colunm,... FROM table1
UNION [ALL]
SELECT column,... FROM table2
```

**示例：** 查询所有价格小于9的水果的信息，查询s_id等于101和103所有水果的信息，使用UNION连接查询结果

```
mysql> SELECT s_id,f_name,f_price
    -> FROM fruits
    -> WHERE f_price<9.0
    -> UNION
    -> SELECT s_id,f_name,f_price
    -> FROM fruits
    -> WHERE s_id IN (101,103);
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  103 | apricot    |    2.20 |
|  104 | berry      |    7.60 |
|  107 | xxxx       |    3.60 |
|  105 | melon      |    8.20 |
|  101 | cherry     |    3.20 |
|  104 | lemon      |    6.40 |
|  105 | xbabay     |    3.60 |
|  102 | grape      |    5.30 |
|  107 | xbababa    |    3.60 |
|  101 | blackberry |   10.20 |
|  103 | coconut    |    9.20 |
+------+------------+---------+
```

UNION将多个SELECT语句的结果组合成一个结果集合。可以分开查询每个SELECT语句：

```
mysql> SELECT s_id,f_name,f_price FROM fruits
    -> WHERE f_price<9.0;
+------+---------+---------+
| s_id | f_name  | f_price |
+------+---------+---------+
|  101 | apple   |    5.20 |
|  103 | apricot |    2.20 |
|  104 | berry   |    7.60 |
|  107 | xxxx    |    3.60 |
|  105 | melon   |    8.20 |
|  101 | cherry  |    3.20 |
|  104 | lemon   |    6.40 |
|  105 | xbabay  |    3.60 |
|  102 | grape   |    5.30 |
|  107 | xbababa |    3.60 |
+------+---------+---------+

mysql> SELECT s_id,f_name,f_price FROM fruits
    -> WHERE s_id IN (101,103);
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  103 | apricot    |    2.20 |
|  101 | blackberry |   10.20 |
|  101 | cherry     |    3.20 |
|  103 | coconut    |    9.20 |
+------+------------+---------+
```

使用UNION ALL包含重复的行，在前面的例子中，分开查询时，两个返回结果中有相同的记录。UNION从查询结果集中自动去除了重复的行，若要返回所有匹配行，而不进行删除，可以使用UNION ALL。

**示例：** 查询所有价格小于9的水果的信息，查询s_id等于101和103的所有水果的信息，使用UNION ALL连接查询

```
mysql> SELECT s_id,f_name,f_price FROM fruits
    -> WHERE f_price<9.0
    -> UNION ALL
    -> SELECT s_id,f_name,f_price FROM fruits
    -> WHERE s_id IN (101,103);
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  103 | apricot    |    2.20 |
|  104 | berry      |    7.60 |
|  107 | xxxx       |    3.60 |
|  105 | melon      |    8.20 |
|  101 | cherry     |    3.20 |
|  104 | lemon      |    6.40 |
|  105 | xbabay     |    3.60 |
|  102 | grape      |    5.30 |
|  107 | xbababa    |    3.60 |
|  101 | apple      |    5.20 |
|  103 | apricot    |    2.20 |
|  101 | blackberry |   10.20 |
|  101 | cherry     |    3.20 |
|  103 | coconut    |    9.20 |
+------+------------+---------+
```

---

## 7.为表和字段取名

### 7.1 为表取别名

当表名很长或者执行一些特殊查询时，为了方便操作或者需要多次使用相同的表时，可以为表指定别名，用这个别名代替原来的名称。

为表取别名的基本语法格式为：`表名 [AS] 表别名 `

“表名”为数据库中存储的数据表的名称，“表别名”为查询时指定的表的新名称，AS关键字为可选参数。

**示例1：** 为orders表取别名o，查询30001订单的下单日期

```
mysql> SELECT * FROM orders AS o WHERE o.o_num=30001;
+-------+---------------------+-------+
| o_num | o_date              | c_id  |
+-------+---------------------+-------+
| 30001 | 2008-09-01 00:00:00 | 10001 |
+-------+---------------------+-------+
```

**示例2：** 为customers和orders表分别取别名，并进行连接查询

```
mysql> SELECT c.c_id,o.o_num
    -> FROM customers AS c LEFT OUTER JOIN orders AS o
    -> ON c.c_id=o.c_id;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10003 | 30002 |
| 10004 | 30003 |
| 10001 | 30005 |
| 10002 |  NULL |
+-------+-------+
```

由结果可以看到，MySQL可以同时为多个表取别名，而且表别名可以放在不同的位置，如WHERE子句、SELECT列表、ON子句以及ORDER BY子句。

#### 提示：

为表取别名时，要保证不能与数据库中的其他表的名称冲突。

<br>

### 7.2 为字段取别名

在有些情况下，显示的列的名称会很长或者名称不够直观，MySQL可以指定列别名，替换字段或表达式。

为字段取别名的基本语法格式为：`列名 [AS] 列别名`

“列名”为表中字段定义的名称，“列别名”为字段新的名称，AS关键字为可选参数。

**示例：** 查询fruits表，为f_name取名为fruit_name，f_price取名为fruit_price，为fruits表取名为f1，查询表中f_price<8的水果的名称

```
mysql> SELECT f1.f_name AS fruit_name,f1.f_price AS fruit_price
    -> FROM fruits AS f1
    -> WHERE f1.f_price<8.0;
+------------+-------------+
| fruit_name | fruit_price |
+------------+-------------+
| apple      |        5.20 |
| apricot    |        2.20 |
| berry      |        7.60 |
| xxxx       |        3.60 |
| cherry     |        3.20 |
| lemon      |        6.40 |
| xbabay     |        3.60 |
| grape      |        5.30 |
| xbababa    |        3.60 |
+------------+-------------+
```

也可以为SELECT子句中的计算字段取别名，例如，对使用COUNT聚合函数或者CONCAT等系统函数执行的结果字段取别名。

**示例：** 查询suppliers表中字段s_name和s_city，使用CONCAT函数连接这两个字段值，并取列名为suppliers_title。

```
mysql> SELECT CONCAT(TRIM(s_name), '(', TRIM(s_city),')')
    -> FROM suppliers
    -> ORDER BY s_name;
+---------------------------------------------+
| CONCAT(TRIM(s_name), '(', TRIM(s_city),')') |
+---------------------------------------------+
| ACME(Shanghi)                               |
| DK Inc.(Zhengzhou)                          |
| FastFruit Inc.(Tianjin)                     |
| FNK Inc.(Zhongshan)                         |
| Good Set(Taiyuang)                          |
| Just Eat Ours(Beijing)                      |
| LT Supplies(Chongqing)                      |
+---------------------------------------------+
```

由结果可以看到，显示结果的列名称为SELECT子句后面的计算字段，实际上计算之后的列是没有名字的，这样结果让人很不容易理解，因此可以为字段取一个别名：

```
mysql> SELECT CONCAT(TRIM(s_name),'(',TRIM(s_city),')')
    -> AS suppliers_title
    -> FROM suppliers
    -> ORDER BY s_name;
+-------------------------+
| suppliers_title         |
+-------------------------+
| ACME(Shanghi)           |
| DK Inc.(Zhengzhou)      |
| FastFruit Inc.(Tianjin) |
| FNK Inc.(Zhongshan)     |
| Good Set(Taiyuang)      |
| Just Eat Ours(Beijing)  |
| LT Supplies(Chongqing)  |
+-------------------------+
```

#### 提示：

表别名只在执行查询的时候使用，并不在返回结果中显示，而列别名定义之后，将返回给客户端显示，显示的结果字段为字段列的别名。

---

## 8 使用正则表达式查询

MySQL中使用REGEXP关键字指定正则表达式的字符串匹配模式。

**正则表达式常用字符匹配列表**

|选项|说明|例子|匹配值示例|
|:---|:---|:---|:---|
|^|匹配文本的开始字符|'^b'匹配以字母b开头的字符串|book,big,banana,bike|
|$|匹配文本的结束字符|'st$'匹配以st结尾的字符串|test,resist,persist|
|.|匹配任何单个字符|'b.t'匹配任何b和t直接按由一个字符|bit,but,bite,bat|
|*|匹配零个或多个在它面前的字符|'f\*n'匹配字符n前面由任意个字符f|fn,fan,faan,fabcn|
|+|匹配前面的字符1次或多次|'ba+'匹配以b开头后面紧跟至少一个a|ba,bay,bare,battle|
|<字符串>|匹配包含指定的字符串的文本|'fa'|fan,afa,faad|
|[字符集合]|匹配字符集合中的任何一个字符|'[xz]'匹配x或者z|dizzy,zebra,x-ray,extra&#160;&#160;|
|[^]|匹配不在括号中的任何字符|'[^abc]'匹配任何不包含a、b或c的字符串&#160;&#160;|desk,fox,f8ke|
|字符串{n,}|匹配前面的字符串至少n此|b{2}匹配2个或更多的b|bbb,bbbb,bbbbbb|
|字符串{n,m}&#160;&#160;|匹配前面的字符串至少n次，至多m次&#160;&#160;|b{2,4}匹配至少2个，至多4个b|bb,bbb,bbbb|

### 8.1 查询以特定字符或字符串开头的记录

字符'^'匹配以特定字符或者字符串开头的文本。

**示例1：** 在fruits表中，查询f_name字段以字母'b'开头的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP '^b';
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| t1   |  102 | banana     |   10.30 |
+------+------+------------+---------+
```

**示例2：** 在fruits表中，查询f_name字段以'be'开头的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP '^be';
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b2   |  104 | berry  |    7.60 |
+------+------+--------+---------+
```

<br>

### 8.2 查询以特定字符或字符串结尾的记录

字符'$'匹配以特定字符或字符串结尾的文本。

**示例1：** 在fruits表中，查询f_name字段以字母'y'结尾的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'y$';
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| c0   |  101 | cherry     |    3.20 |
| m2   |  105 | xbabay     |    3.60 |
+------+------+------------+---------+
```

**示例2：** 在fruits表中，查询f_name字段以字符串'rry'结尾的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'rry$';
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| c0   |  101 | cherry     |    3.20 |
+------+------+------------+---------+
```

<br>

### 8.3 用符号"."来替代字符串中的任意一个字符

字符"."匹配任意一个字符。

**示例1：** 在fruits表中，查询f_name字段值包含字母'a'与'g'且两字母之间只有一个字母的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'a.g';
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| bs1  |  102 | orange |   11.20 |
| m1   |  106 | mango  |   15.70 |
+------+------+--------+---------+
```

<br>

### 8.4 使用"*"和"+"来匹配多个字符

使用'*'匹配前面的字符任意多次，包括0次。加号'+'匹配前面的字符至少一次。

**示例1：** 在fruits表中，查询f_name字段值以字母'b'开头，且'b'后面出现字母'a'的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba*';
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| t1   |  102 | banana     |   10.30 |
+------+------+------------+---------+
```

**示例2：** 在fruits表中，查询f_name字段值以字母'b'开头，且'b'后面出现字母'a'至少一次的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba+';
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| t1   |  102 | banana |   10.30 |
+------+------+--------+---------+
```

<br>

### 8.5 匹配指定字符串

正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，若要匹配多个字符串，多个字符串之间使用分隔符'|'隔开。

**示例1：** 在fruits表中，查询f_name字段值包含字符串"on"的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'on';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| bs2  |  105 | melon   |    8.20 |
| l2   |  104 | lemon   |    6.40 |
| o2   |  103 | coconut |    9.20 |
+------+------+---------+---------+
```
**示例2：** 在fruits字段中，查询f_name字段值包含字符串"on"或者"ap"的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'on|ap';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| a1   |  101 | apple   |    5.20 |
| a2   |  103 | apricot |    2.20 |
| bs2  |  105 | melon   |    8.20 |
| l2   |  104 | lemon   |    6.40 |
| o2   |  103 | coconut |    9.20 |
| t2   |  102 | grape   |    5.30 |
+------+------+---------+---------+
```

#### 提示：

LIKE虽然也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串若在文本中出现，则找不到它，相应的行也不会返回。而REGEXP在文本内进行匹配，若被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回：

```
mysql> SELECT * FROM fruits WHERE f_name LIKE 'on';
Empty set (0.05 sec)
```

若想使用LIKE匹配文本中出现的字符串，得在字符串前后都加上'%'符号：

```
mysql> SELECT * FROM fruits WHERE f_name LIKE '%on%';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| bs2  |  105 | melon   |    8.20 |
| l2   |  104 | lemon   |    6.40 |
| o2   |  103 | coconut |    9.20 |
+------+------+---------+---------+
```

<br>

### 8.6 匹配指定字符中的任意一个

方括号"[]"指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。

**示例：** 在fruits表中，查找f_name字段中包含字母'o'或者't'的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP '[ot]';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| a2   |  103 | apricot |    2.20 |
| bs1  |  102 | orange  |   11.20 |
| bs2  |  105 | melon   |    8.20 |
| l2   |  104 | lemon   |    6.40 |
| m1   |  106 | mango   |   15.70 |
| m3   |  105 | xxtt    |   11.60 |
| o2   |  103 | coconut |    9.20 |
+------+------+---------+---------+
```

方括号"[]"还可以指定数值集合

**示例：** 在fruits表中，查询s_id字段中数值中包含4、5或者6的记录

```
mysql> SELECT * FROM fruits WHERE s_id REGEXP '[456]';
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b2   |  104 | berry  |    7.60 |
| bs2  |  105 | melon  |    8.20 |
| l2   |  104 | lemon  |    6.40 |
| m1   |  106 | mango  |   15.70 |
| m2   |  105 | xbabay |    3.60 |
| m3   |  105 | xxtt   |   11.60 |
+------+------+--------+---------+
```

匹配集合'[456]'也可以写成'[4-6]'，即指定集合区间。

<br>

### 8.7 匹配指定字符意以外的字符

"[^字符集]"匹配不在指定集合中的任何字符。

**示例：** 在fruits表中，查询f_id字段包含字母a~e和数字1~2以外的字符的记录

```
mysql> SELECT * FROM fruits WHERE f_id REGEXP '[^a-e1-2]';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| b5   |  107 | xxxx    |    3.60 |
| bs1  |  102 | orange  |   11.20 |
| bs2  |  105 | melon   |    8.20 |
| c0   |  101 | cherry  |    3.20 |
| l2   |  104 | lemon   |    6.40 |
| m1   |  106 | mango   |   15.70 |
| m2   |  105 | xbabay  |    3.60 |
| m3   |  105 | xxtt    |   11.60 |
| o2   |  103 | coconut |    9.20 |
| t1   |  102 | banana  |   10.30 |
| t2   |  102 | grape   |    5.30 |
| t4   |  107 | xbababa |    3.60 |
+------+------+---------+---------+
```

<br>

### 8.8 使用{n,}或者{n,m}来指定字符串连续出现的次数

"字符串{n,}"表示至少匹配n次前面的字符；"字符串{n,m}"表示匹配前面的字符串不少于n次，不多于m次。

**示例1：** 在fruits表中，查询f_name字段出现字母'x'至少2次的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'x{2,}';
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b5   |  107 | xxxx   |    3.60 |
| m3   |  105 | xxtt   |   11.60 |
+------+------+--------+---------+
```

**示例2：** 在fruits表中，查询f_name字段值出现字符串"ba"最少1次，最多3次的记录

```
mysql> SELECT * FROM fruits WHERE f_name REGEXP 'ba{1,3}';
+------+------+---------+---------+
| f_id | s_id | f_name  | f_price |
+------+------+---------+---------+
| m2   |  105 | xbabay  |    3.60 |
| t1   |  102 | banana  |   10.30 |
| t4   |  107 | xbababa |    3.60 |
+------+------+---------+---------+
```
---

## 9 综合案例

**employee表结构**

|字段名|字段说明|数据类型|主键&#160;&#160;&#160;&#160;|外键&#160;&#160;&#160;&#160;|非空&#160;&#160;&#160;&#160;|唯一&#160;&#160;&#160;&#160;|自增&#160;&#160;&#160;&#160;|
|:---|:---|:---|:---|:---|:---|:---|:---|
|e_no|员工编号|INT(11)|是|否|是|是|否|
|e_name|员工姓名|VARCHAR(50)|否|否|是|否|否|
|e_gender|员工性别|CHAR(2)|否|否|否|否|否|
|dept_no|部门编号|INT(11)|否|否|是|否|否|
|e_job|职位|VARCHAR(50)&#160;&#160;&#160;&#160;|否|否|是|否|否|
|e_salary|薪水|INT(11)|否|否|是|否|否|
|hireDate&#160;&#160;&#160;&#160;|入职日期&#160;&#160;&#160;&#160;|DATE|否|否|是|否|否|

**dept表结构**

|字段名|字段说明|数据类型|主键&#160;&#160;&#160;&#160;|外键&#160;&#160;&#160;&#160;|非空&#160;&#160;&#160;&#160;|唯一&#160;&#160;&#160;&#160;|自增&#160;&#160;&#160;&#160;|
|:---|:---|:---|:---|:---|:---|:---|:---|
|d_no|部门编号|INT(11)|是|是|是|是|是|
|d_name|部门名称|VARCHAR(50)|否|否|是|否|否|
|d_location&#160;&#160;&#160;&#160;|部门地址&#160;&#160;&#160;&#160;|VARCHAR(100)&#160;&#160;&#160;&#160;|否|否|否|否|否|

<br>

首先，创建数据表employee和dept：

```
mysql> CREATE TABLE dept
    -> (
    -> d_no INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,
    -> d_name VARCHAR(50) NOT NULL,
    -> d_location VARCHAR(100)
    -> );
Query OK, 0 rows affected, 1 warning (0.12 sec)

mysql> CREATE TABLE employee
    -> (
    -> e_no INT(11) NOT NULL PRIMARY KEY,
    -> e_name VARCHAR(50) NOT NULL,
    -> e_gender CHAR(2),
    -> dept_no INT(11) NOT NULL,
    -> e_job VARCHAR(50) NOT NULL,
    -> e_salary INT(11) NOT NULL,
    -> hireDate DATE NOT NULL,
    -> CONSTRAINT dno_fk FOREIGN KEY(dept_no) REFERENCES dept(d_no)
    -> );
Query OK, 0 rows affected, 3 warnings (0.17 sec)
```

分别向dept和employee表中插入数据：

```
mysql> INSERT INTO dept VALUES
    -> (10,'ACCOUNTING','ShangHai'),
    -> (20,'RESEARCH','Beijing'),
    -> (30,'SALES','ShenZhen'),
    -> (40,'OPERATIONS','FuJian');
Query OK, 4 rows affected (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> INSERT INTO employee VALUES
    -> (1001,'SMITH','m',20,'CLERK',800,'2005-11-12'),
    -> (1002,'ALLEN','f',30,'SALESMAN',1600,'2003-05-12'),
    -> (1003,'WARD','f',30,'SALESMAN',1250,'2003-05-12'),
    -> (1004,'JONES','m',20,'MANAGER',2975,'1998-05-18'),
    -> (1005,'MARTIN','m',30,'SALESMAN',1250,'2001-06-12'),
    -> (1006,'BLAKE','f',30,'MANAGER',2850,'1997-02-15'),
    -> (1007,'CLARK','m','10','MANAGER',2450,'2002-09-12'),
    -> (1008,'SCOTT','m',20,'ANALYST',3000,'2003-05-12'),
    -> (1009,'KING','f',10,'PRESIDENT',5000,'1995-01-01'),
    -> (1010,'TURNER','f',30,'SALESMAN',1500,'1997-10-12'),
    -> (1011,'ADAMS','m',20,'CLERK',1100,'1999-10-05'),
    -> (1012,'JAMES','m',30,'CLERK',950,'2008-06-15');
Query OK, 12 rows affected (0.05 sec)
Records: 12  Duplicates: 0  Warnings: 0
```

在employee表中查询所有e_no、e_name和e_salary字段的值：

```
mysql> SELECT e_no,e_name,e_salary FROM employee;
+------+--------+----------+
| e_no | e_name | e_salary |
+------+--------+----------+
| 1001 | SMITH  |      800 |
| 1002 | ALLEN  |     1600 |
| 1003 | WARD   |     1250 |
| 1004 | JONES  |     2975 |
| 1005 | MARTIN |     1250 |
| 1006 | BLAKE  |     2850 |
| 1007 | CLARK  |     2450 |
| 1008 | SCOTT  |     3000 |
| 1009 | KING   |     5000 |
| 1010 | TURNER |     1500 |
| 1011 | ADAMS  |     1100 |
| 1012 | JAMES  |      950 |
+------+--------+----------+
```

在employee表中，查询dept_no等于10和20的所有记录：

```
mysql> SELECT * FROM employee WHERE dept_no IN (10,20);
+------+--------+----------+---------+-----------+----------+------------+
| e_no | e_name | e_gender | dept_no | e_job     | e_salary | hireDate   |
+------+--------+----------+---------+-----------+----------+------------+
| 1007 | CLARK  | m        |      10 | MANAGER   |     2450 | 2002-09-12 |
| 1009 | KING   | f        |      10 | PRESIDENT |     5000 | 1995-01-01 |
| 1001 | SMITH  | m        |      20 | CLERK     |      800 | 2005-11-12 |
| 1004 | JONES  | m        |      20 | MANAGER   |     2975 | 1998-05-18 |
| 1008 | SCOTT  | m        |      20 | ANALYST   |     3000 | 2003-05-12 |
| 1011 | ADAMS  | m        |      20 | CLERK     |     1100 | 1999-10-05 |
+------+--------+----------+---------+-----------+----------+------------+
```

在employee表中，查询工资范围在800~2500的员工信息：

```
mysql> SELECT * FROM employee WHERE e_salary BETWEEN 800 AND 2500;
+------+--------+----------+---------+----------+----------+------------+
| e_no | e_name | e_gender | dept_no | e_job    | e_salary | hireDate   |
+------+--------+----------+---------+----------+----------+------------+
| 1001 | SMITH  | m        |      20 | CLERK    |      800 | 2005-11-12 |
| 1002 | ALLEN  | f        |      30 | SALESMAN |     1600 | 2003-05-12 |
| 1003 | WARD   | f        |      30 | SALESMAN |     1250 | 2003-05-12 |
| 1005 | MARTIN | m        |      30 | SALESMAN |     1250 | 2001-06-12 |
| 1007 | CLARK  | m        |      10 | MANAGER  |     2450 | 2002-09-12 |
| 1010 | TURNER | f        |      30 | SALSEMAN |     1500 | 1997-10-12 |
| 1011 | ADAMS  | m        |      20 | CLERK    |     1100 | 1999-10-05 |
| 1012 | JAMES  | m        |      30 | CLERK    |      950 | 2008-06-15 |
+------+--------+----------+---------+----------+----------+------------+
```

在employee表中，查询部门编号为20的部门中的员工信息：

```
mysql> SELECT * FROM employee WHERE dept_no=20;
+------+--------+----------+---------+---------+----------+------------+
| e_no | e_name | e_gender | dept_no | e_job   | e_salary | hireDate   |
+------+--------+----------+---------+---------+----------+------------+
| 1001 | SMITH  | m        |      20 | CLERK   |      800 | 2005-11-12 |
| 1004 | JONES  | m        |      20 | MANAGER |     2975 | 1998-05-18 |
| 1008 | SCOTT  | m        |      20 | ANALYST |     3000 | 2003-05-12 |
| 1011 | ADAMS  | m        |      20 | CLERK   |     1100 | 1999-10-05 |
+------+--------+----------+---------+---------+----------+------------+
```

在employee表中，查询每个部门最高工资的员工信息：

```
mysql> SELECT dept_no,MAX(e_salary) FROM employee GROUP BY dept_no;
+---------+---------------+
| dept_no | MAX(e_salary) |
+---------+---------------+
|      10 |          5000 |
|      20 |          3000 |
|      30 |          2850 |
+---------+---------------+
```

查询员工BLACK所在部门和部门所在地：

```
mysql> SELECT d_name,d_location FROM dept WHERE d_no=
    -> (SELECT dept_no FROM employee WHERE e_name='BLAKE');
+--------+------------+
| d_name | d_location |
+--------+------------+
| SALES  | ShenZhen   |
+--------+------------+
```

使用连接查询，查询所有员工的部门和部门信息：

```
mysql> SELECT e_no,e_name,dept_no,d_name,d_location FROM employee,dept WHERE employee.dept_no=dept.d_no;
+------+--------+---------+------------+------------+
| e_no | e_name | dept_no | d_name     | d_location |
+------+--------+---------+------------+------------+
| 1007 | CLARK  |      10 | ACCOUNTING | ShangHai   |
| 1009 | KING   |      10 | ACCOUNTING | ShangHai   |
| 1001 | SMITH  |      20 | RESEARCH   | Beijing    |
| 1004 | JONES  |      20 | RESEARCH   | Beijing    |
| 1008 | SCOTT  |      20 | RESEARCH   | Beijing    |
| 1011 | ADAMS  |      20 | RESEARCH   | Beijing    |
| 1002 | ALLEN  |      30 | SALES      | ShenZhen   |
| 1003 | WARD   |      30 | SALES      | ShenZhen   |
| 1005 | MARTIN |      30 | SALES      | ShenZhen   |
| 1006 | BLAKE  |      30 | SALES      | ShenZhen   |
| 1010 | TURNER |      30 | SALES      | ShenZhen   |
| 1012 | JAMES  |      30 | SALES      | ShenZhen   |
+------+--------+---------+------------+------------+
```

在employee表中，计算每个部门各有多少名员工：

```
mysql> SELECT dept_no,COUNT(*) FROM employee GROUP BY dept_no;
+---------+----------+
| dept_no | COUNT(*) |
+---------+----------+
|      10 |        2 |
|      20 |        4 |
|      30 |        6 |
+---------+----------+
```

在employee表中，计算不同类型职工的总工资数：

```
mysql> SELECT e_job,SUM(e_salary) FROM employee GROUP BY e_job;
+-----------+---------------+
| e_job     | SUM(e_salary) |
+-----------+---------------+
| CLERK     |          2850 |
| SALESMAN  |          5600 |
| MANAGER   |          8275 |
| ANALYST   |          3000 |
| PRESIDENT |          5000 |
+-----------+---------------+
```

在employee表中，计算不同部门的平均工资：

```
mysql> SELECT dept_no,AVG(e_salary) FROM employee GROUP BY dept_no;
+---------+---------------+
| dept_no | AVG(e_salary) |
+---------+---------------+
|      10 |     3725.0000 |
|      20 |     1968.7500 |
|      30 |     1566.6667 |
+---------+---------------+
```

在employee表中，查询员工姓名以字母'A'或'S'开头的员工的信息：

```
mysql> SELECT * FROM employee WHERE e_name REGEXP '^[AS]';
+------+--------+----------+---------+----------+----------+------------+
| e_no | e_name | e_gender | dept_no | e_job    | e_salary | hireDate   |
+------+--------+----------+---------+----------+----------+------------+
| 1001 | SMITH  | m        |      20 | CLERK    |      800 | 2005-11-12 |
| 1002 | ALLEN  | f        |      30 | SALESMAN |     1600 | 2003-05-12 |
| 1008 | SCOTT  | m        |      20 | ANALYST  |     3000 | 2003-05-12 |
| 1011 | ADAMS  | m        |      20 | CLERK    |     1100 | 1999-10-05 |
+------+--------+----------+---------+----------+----------+------------+
```

在employee表中，查询到目前位置，工龄大于等于18年的员工的信息：

```
mysql> SELECT * FROM employee WHERE YEAR(CURDATE())-YEAR(hireDate)>=18;
+------+--------+----------+---------+-----------+----------+------------+
| e_no | e_name | e_gender | dept_no | e_job     | e_salary | hireDate   |
+------+--------+----------+---------+-----------+----------+------------+
| 1004 | JONES  | m        |      20 | MANAGER   |     2975 | 1998-05-18 |
| 1005 | MARTIN | m        |      30 | SALESMAN  |     1250 | 2001-06-12 |
| 1006 | BLAKE  | f        |      30 | MANAGER   |     2850 | 1997-02-15 |
| 1009 | KING   | f        |      10 | PRESIDENT |     5000 | 1995-01-01 |
| 1010 | TURNER | f        |      30 | SALESMAN  |     1500 | 1997-10-12 |
| 1011 | ADAMS  | m        |      20 | CLERK     |     1100 | 1999-10-05 |
+------+--------+----------+---------+-----------+----------+------------+
```

---
