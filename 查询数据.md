# 查询数据

## 1.基本查询语句

MySQL从数据表中查询数据的基本语句为SELECT语句。SELECT语句的基本格式为：

```
SELECT
	{*|<字段列表>}
	[
		FROM <表1>,<表2>,...
		[WHERE <表达式>]
		[GROUP BY <group by definition>]
		[HAVING <expression> [{<operation><expression>}...]]
		[ODER BY <order by definition>]
		[LIMIT [<offset>,] <row count>]
	]
SELECT [字段1,字段2,……,字段n]
FROM [表或视图]
WHERE [查询条件 ]
```

其中，各条子句的含义如下：
* {\*|<字段列表>}包含星号通配符选择字段列表，表示查询的字段，其中字段列至少包含一个字段名称，如果需要查询多个字段，多个字段之间用**逗号**隔开，最后一个字段后不要加逗号；
* FROM<表1>,<表2>,... 表1和表2表示查询数据的来源，可以是单个或者多个；
* WHERE子句是可选项，如果选择该项，将限定查询行必须满足的查询条件；
* GROUP BY<字段> 该子句告诉MySQL如何显示查询出来的数据，并按照指定的字段分组；
* [ORDER BY<字段>] 该子句告诉MySQL按什么样的顺序显示查询出来的数据，可以进行的排序有：升序(ASC)、降序(DESC)；
* [LIMIT[<offset>,]<row count>] 该子句告诉MySQL每次显示查询出来的数据条数；

**示例：** 下面以例子说明如何使用SELECT从单个表中获取数据：

首先定义数据表：

```
mysql> CREATE TABLE fruits
    -> (
    -> f_id CHAR(10) NOT NULL,
    -> s_id INT NOT NULL,
    -> f_name CHAR(255) NOT NULL,
    -> f_price DECIMAL(8,2) NOT NULL,
    -> PRIMARY KEY(f_id)
    -> );
Query OK, 0 rows affected (0.05 sec)
```

向表中插入数据：

```
mysql> INSERT INTO fruits (f_id, s_id, f_name, f_price)
    -> VALUES('a1',101,'apple',5.2),
    -> ('b1',101,'blackberry',10.2),
    -> ('bs1',102,'orange',11.2),
    -> ('bs2',105,'melon',8.2),
    -> ('t1',102,'banana',10.3),
    -> ('t2',102,'grape',5.3),
    -> ('o2',103,'coconut',9.2),
    -> ('c0',101,'cherry',3.2),
    -> ('a2',103,'apricot',2.2),
    -> ('l2',104,'lemon',6.4),
    -> ('b2',104,'berry',7.6),
    -> ('m1',106,'mango',15.7),
    -> ('m2',105,'xbabay',3.6),
    -> ('t4',107,'xbababa',3.6),
    -> ('m3',105,'xxtt',11.6),
    -> ('b5',107,'xxxx',3.6);
Query OK, 16 rows affected (0.05 sec)
Records: 16  Duplicates: 0  Warnings: 0
```

使用SELECT语句查询f_id和f_name字段的数据：

```
mysql> SELECT f_id,f_name FROM fruits;
+------+------------+
| f_id | f_name     |
+------+------------+
| a1   | apple      |
| a2   | apricot    |
| b1   | blackberry |
| b2   | berry      |
| b5   | xxxx       |
| bs1  | orange     |
| bs2  | melon      |
| c0   | cherry     |
| l2   | lemon      |
| m1   | mango      |
| m2   | xbabay     |
| m3   | xxtt       |
| o2   | coconut    |
| t1   | banana     |
| t2   | grape      |
| t4   | xbababa    |
+------+------------+
16 rows in set (0.05 sec)
```

该语句的执行过程是，SELECT语句决定了要查询的列值，在这里查询f_id和f_name两个字段的值，FROM子句指定了数据的来源，这里指定数据fruits，因此返回结果为fruits表中f_id和f_name两个字段下所有的数据。其显示顺序为添加到表中的顺序。

---

## 2.单表查询

单表查询是指从一张表中查询所需的数据。基本的单表查询方式主要有：
1. 查询所有字段；
2. 查询指定字段；
3. 查询指定记录；
4. 查询空值；
5. 多条件查询；
6. 对查询结果进行排序；
7. ……

### 2.1 查询所有字段

**1. 在SELECT语句中使用星号(\*)通配符查询所有字段**

SELECT查询记录最简单的形式就是从一个表达式中检索所有记录，实现的方法是使用星号(\*)通配符指定查找所有列的名称。语法格式为：`SELECT * FROM 表名;`

**示例：** 从fruits表中检索所有字段的数据

```
mysql> SELECT * FROM fruits;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| b5   |  107 | xxxx       |    3.60 |
| bs1  |  102 | orange     |   11.20 |
| bs2  |  105 | melon      |    8.20 |
| c0   |  101 | cherry     |    3.20 |
| l2   |  104 | lemon      |    6.40 |
| m1   |  106 | mango      |   15.70 |
| m2   |  105 | xbabay     |    3.60 |
| m3   |  105 | xxtt       |   11.60 |
| o2   |  103 | coconut    |    9.20 |
| t1   |  102 | banana     |   10.30 |
| t2   |  102 | grape      |    5.30 |
| t4   |  107 | xbababa    |    3.60 |
+------+------+------------+---------+
```

可以看到，使用星号(*)通配符时，将返回所有列，列按照定义表时的顺序显示。


**2. 在SELECT语句中指定所有字段**

根据SELECT语句的格式，SELECT关键字后面的字段名为将要查找的数据，因此可以见表中所有字段的名称跟在SELECT子句之后。若忘记字段名称，可以使用DESC命令查看表的结构。（

#### 提示：

一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符'*'。通配符虽然可以节省输入查询语句的时间，但获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。

<br>

### 2.2 查询指定字段

**1. 查询单个字段**

查询表中的某一个字段，语法格式为：`SELECT 列明 FROM 表名;`

**示例：** 查询fruits表中f_name列所有水果名

```
mysql> SELECT f_name FROM fruits;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| blackberry |
| berry      |
| xxxx       |
| orange     |
| melon      |
| cherry     |
| lemon      |
| mango      |
| xbabay     |
| xxtt       |
| coconut    |
| banana     |
| grape      |
| xbababa    |
+------------+
```

**2. 查询多个字段**

使用SELECT声明，可以获取多个字段下的数据，只需要在关键字SELECT后面指定要查找的字段的名称，不同字段名称之间使用逗号(,)分隔开，最后一个字段后面不需要加逗号，。

语法格式为：`SELECT 字段名1,字段名2,……,字段名n FROM 表名;`

**示例：** 从fruits表中获取f_name和f_price两列

```
mysql> SELECT f_name,f_price FROM fruits;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| blackberry |   10.20 |
| berry      |    7.60 |
| xxxx       |    3.60 |
| orange     |   11.20 |
| melon      |    8.20 |
| cherry     |    3.20 |
| lemon      |    6.40 |
| mango      |   15.70 |
| xbabay     |    3.60 |
| xxtt       |   11.60 |
| coconut    |    9.20 |
| banana     |   10.30 |
| grape      |    5.30 |
| xbababa    |    3.60 |
+------------+---------+
```

<br>

### 2.3 查询指定记录

数据库中包含大量的数据，根据特殊要求，可能只需要查询表中的指定数据，即对数据进行过滤。在SELECT语句中，通过WHERE子句可以对数据进行过滤。

语法格式为：

```
SELECT 字段名1,字段名2,……,字段名n
FROM 表名
WHERE 查询条件;
```

在WHERE子句中，MySQL提供了一系列的条件判断：

**WHERE条件判断符**

|操作符|说明|
|:---|:---|
|=|相等|
|<>,!=|不相等|
|<|小于|
|<=|小于或等于|
|>|大于|
|>=|大于或等于|
|BETWEEN&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|位于两者之间&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|

**示例1：** 查询价格为10.2元的水果的名称

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price=10.2;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| blackberry |   10.20 |
+------------+---------+
```

**示例2：** 查找名称为"apple"的水果的价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_name='apple';
+--------+---------+
| f_name | f_price |
+--------+---------+
| apple  |    5.20 |
+--------+---------+
```

**示例3：** 查找价格小于10的水果的名称

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price<10;
+---------+---------+
| f_name  | f_price |
+---------+---------+
| apple   |    5.20 |
| apricot |    2.20 |
| berry   |    7.60 |
| xxxx    |    3.60 |
| melon   |    8.20 |
| cherry  |    3.20 |
| lemon   |    6.40 |
| xbabay  |    3.60 |
| coconut |    9.20 |
| grape   |    5.30 |
| xbababa |    3.60 |
+---------+---------+
```

<br>

### 2.4 带IN关键字的查询

IN操作符用来查询满足指定范围内的条件的记录，使用IN操作符，将所有检索条件用括号括起来，检索条件之间用逗号分隔开，只需要满足条件范围内的一个指即为匹配项。

**示例：** 查询s_id为101和102的记录

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id IN (101,102) ORDER BY f_name;
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  102 | banana     |   10.30 |
|  101 | blackberry |   10.20 |
|  101 | cherry     |    3.20 |
|  102 | grape      |    5.30 |
|  102 | orange     |   11.20 |
+------+------------+---------+
```

相反的，可以使用关键字NOT来检索不在条件范围内的记录

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id NOT IN (101,102) ORDER BY f_name;
+------+---------+---------+
| s_id | f_name  | f_price |
+------+---------+---------+
|  103 | apricot |    2.20 |
|  104 | berry   |    7.60 |
|  103 | coconut |    9.20 |
|  104 | lemon   |    6.40 |
|  106 | mango   |   15.70 |
|  105 | melon   |    8.20 |
|  107 | xbababa |    3.60 |
|  105 | xbabay  |    3.60 |
|  105 | xxtt    |   11.60 |
|  107 | xxxx    |    3.60 |
+------+---------+---------+
```

<br>

### 2.5 带BETWEEN AND的范围查询

BETWEEN AND 用来查询某个范围内的值，该操作符需要两个参数，即范围的开始值和结束值，若字段满足指定的范围查询条件，则这些记录被返回。

**示例：** 查询价格在2.00元到10.20元之间的水果的名称和价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price BETWEEN 2.00 AND 10.20;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| blackberry |   10.20 |
| berry      |    7.60 |
| xxxx       |    3.60 |
| melon      |    8.20 |
| cherry     |    3.20 |
| lemon      |    6.40 |
| xbabay     |    3.60 |
| coconut    |    9.20 |
| grape      |    5.30 |
| xbababa    |    3.60 |
+------------+---------+
```

BETWEEN AND操作符前也可以加关键字NOT，表示指定范围外的值，若字段值不满足指定的范围内的值，则这些记录被返回。

**示例：** 查询价格在2.00元到10.20元之外的水果名称和价格

```
mysql> SELECT f_name,f_price FROM fruits WHERE f_price NOT BETWEEN 2.00 AND 10.20;
+--------+---------+
| f_name | f_price |
+--------+---------+
| orange |   11.20 |
| mango  |   15.70 |
| xxtt   |   11.60 |
| banana |   10.30 |
+--------+---------+
```

<br>

### 2.6 带LIKE的字符匹配查询

在MySQL中，可以使用LIKE关键字对通配符尽心匹配查找，通过创建查找模式对表中的数据进行比较。

通配符时一种在SQL的WHERE条件子句中拥有特殊意思的字符，SQL语句中支持多种通配符，可以和LIKE一起使用的通配符有'%'和'_'。

**1. 百分号通配符'%'，匹配任意长的字符，甚至包括零字符**

**示例：** 查找所有以'b'字母开头的水果

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE 'b%';
+------+------------+
| f_id | f_name     |
+------+------------+
| b1   | blackberry |
| b2   | berry      |
| t1   | banana     |
+------+------------+
```

该语句查询的结果返回所有以'b'开头的水果的id和name，'%'告诉MySQL，返回所有以字母'b'开头的记录，不管'b'后面有多少个字符。

在搜索匹配时通配符'%'可以放在不同的位置

**示例：** 在fruits表中，查询f_name中包含字母'g'的记录

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE '%g%';
+------+--------+
| f_id | f_name |
+------+--------+
| bs1  | orange |
| m1   | mango  |
| t2   | grape  |
+------+--------+
```

**示例：** 查询以'b'开头，并以'y'结尾的水果的名称

```
mysql> SELECT f_name FROM fruits WHERE f_name LIKE 'b%y';
+------------+
| f_name     |
+------------+
| blackberry |
| berry      |
+------------+
```

通过以上查询结果，可以看到，'%'用于匹配在指定的位置的任意数目的字符。

**2.下划线通配符'_'，一次只能匹配任意一个字符**

下划线通配符'_'用法和'%'相同，区别是'%'可以匹配多个字符，而'_'只能匹配任意单个字符，若需要匹配多个字符，则需要使用相同个数的'_'。

**示例：** 在fruits表中，查询以字母'y'结尾，且'y'前面只有4个字母的记录

```
mysql> SELECT f_id,f_name FROM fruits WHERE f_name LIKE '____y';
+------+--------+
| f_id | f_name |
+------+--------+
| b2   | berry  |
+------+--------+
```

从结果可以看到，以'y'结尾且前面只有4个字母的记录只有一条。其他记录的f_name字段也有以'y'结尾的，但其总的字符串长度不为5，因此不在返回结果中。

<br>

### 2.7查询空值

数据表创建的时候，设计者可以指定某列中是否可以包含空值(NULL)。空值不同于0，也不同于空字符串。空值一般表示数据未知、不适用或将在以后添加数据。

在SELECT语句中使用IS NULL子句，可以查询某字段内容为空的记录。

下面创建数据表customers，并插入数据：

```
mysql> CREATE TABLE customers
    -> (
    -> c_id INT NOT NULL AUTO_INCREMENT,
    -> c_name CHAR(50) NOT NULL,
    -> c_address CHAR(50) NULL,
    -> c_city CHAR(50) NULL,
    -> c_zip CHAR(50) NULL,
    -> c_contact CHAR(50) NULL,
    -> c_email CHAR(255) NULL,
    -> PRIMARY KEY (c_id)
    -> );
Query OK, 0 rows affected (0.17 sec)

mysql> INSERT INTO customers(c_id,c_name,c_address,c_city,c_zip,c_contact,c_email)
    -> VALUES(10001,'RedHook','200 Street','Tianjin','300000','LiMing','LMing@163.com'),
    -> (10002,'Stars','333 Fromage Lane','Dalian','116000','Zhangbo','Jerry@hotmail.com'),
    -> (10003,'Netbhood','1 Sunny Place','Qingdao','266000','LuoCong',NULL),
    -> (10004,'JOTO','829 Riverside Drive','Haikou','5700000','YangShan','sam@hotmail.com');
Query OK, 4 rows affected (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

**示例：** 查询customers表中c_email不为空的记录的c_id、c_name和c_email字段值

```
mysql> SELECT c_id,c_name,c_email FROM customers WHERE c_email IS NOT NULL;
+-------+---------+-------------------+
| c_id  | c_name  | c_email           |
+-------+---------+-------------------+
| 10001 | RedHook | LMing@163.com     |
| 10002 | Stars   | Jerry@hotmail.com |
| 10004 | JOTO    | sam@hotmail.com   |
+-------+---------+-------------------+
```

<br>

### 2.8 带AND的多条件查询

使用SELECT查询时，可以增加查询的限制条件，这样可以使查询的结果更加精确。MySQL在WHERE子句中使用AND操作符限定只有满足所有查询条件的记录才会被返回。可以使用AND连接连个甚至多个查询条件，多个表达式之间用AND分开。

**示例1：** 在fruits表中查询s_id=101，并且f_price大于等于5的水果价格和名

```
mysql> SELECT f_id,f_price,f_name FROM fruits WHERE s_id='101' AND f_price>=5;
+------+---------+------------+
| f_id | f_price | f_name     |
+------+---------+------------+
| a1   |    5.20 | apple      |
| b1   |   10.20 | blackberry |
+------+---------+------------+
```

**示例2：** 在fruits表中查询s_id=101或者102，且f_price大于5，并且f_name='apple'的水果价格和名称

```
mysql> SELECT f_id,f_price,f_name FROM fruits WHERE s_id IN('101','102') AND f_price>=5 AND f_name='apple';
+------+---------+--------+
| f_id | f_price | f_name |
+------+---------+--------+
| a1   |    5.20 | apple  |
+------+---------+--------+
```

<br>

### 2.9 带OR的所条件查询

与AND相反，在WHERE声明中使用OR操作符，表示只需要满足其中一个条件的记录即可返回。OR也可以连续两个甚至多个查询条件，多个条件表达式之间用OR分开。

**示例：** 查询s_id=101或102的水果供应商的f_price和f_name

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id=101 OR s_id=102;
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  101 | blackberry |   10.20 |
|  102 | orange     |   11.20 |
|  101 | cherry     |    3.20 |
|  102 | banana     |   10.30 |
|  102 | grape      |    5.30 |
+------+------------+---------+
```

这里也可以使用IN操作符使实现与OR相同的功能：

```
mysql> SELECT s_id,f_name,f_price FROM fruits WHERE s_id IN (101,102);
+------+------------+---------+
| s_id | f_name     | f_price |
+------+------------+---------+
|  101 | apple      |    5.20 |
|  101 | blackberry |   10.20 |
|  102 | orange     |   11.20 |
|  101 | cherry     |    3.20 |
|  102 | banana     |   10.30 |
|  102 | grape      |    5.30 |
+------+------------+---------+
```

这里可以看到，OR操作符和IN操作符使用后的结果是一样的，它们可以实现相同的功能。但是使用IN操作符是的检索语句更加简洁明了，并且IN执行的速度高于OR。更重要的是，IN操作符可以执行更加复杂的嵌套查询。

#### 提示：

OR可以和AND一起使用，但在使用时要注意两者的优先级，由于AND的优先级高于OR，因此对AND两边的操作数进行操作，再与OR中的操作数集合。

<br>

### 2.10 查询结果不重复

从前面的例子可以看到，SELECT查询返回所有匹配的行。例如，在查询fruits表中所有的s_id，其结果为：

```
mysql> SELECT s_id FROM fruits;
+------+
| s_id |
+------+
|  101 |
|  103 |
|  101 |
|  104 |
|  107 |
|  102 |
|  105 |
|  101 |
|  104 |
|  106 |
|  105 |
|  105 |
|  103 |
|  102 |
|  102 |
|  107 |
+------+
```

可以看到，查询返回的记录有重复的s_id。若需要消除重复的记录值，可以使用DISTINCT关键字指示MySQL消除重复的记录。

语法格式为：`SELECT DISTINCT 字段名 FROM 表名;`

**示例：** 查询fruits表中s_id字段的值，返回s_id字段值不得重复

```
mysql> SELECT DISTINCT s_id FROM fruits;
+------+
| s_id |
+------+
|  101 |
|  103 |
|  104 |
|  107 |
|  102 |
|  105 |
|  106 |
+------+
```

<br>

### 2.11 对查询结果排序

从前面的查询结果可以看到，有些字段的值是没有任何顺序的。MySQL可以通过在SELECT语句中使用ORDER BY子句对查询结果进行排序。

**1. 单列排序**

查询f_name字段，结果如下：

```
mysql> SELECT f_name FROM fruits;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| blackberry |
| berry      |
| xxxx       |
| orange     |
| melon      |
| cherry     |
| lemon      |
| mango      |
| xbabay     |
| xxtt       |
| coconut    |
| banana     |
| grape      |
| xbababa    |
+------------+
```

可以看到，查询的数据并没有一个特定的顺序显示，若没有对它们进行拍寻，它们将按照插入数据表中的顺序来显示。

下面使用ORDER BY子句对执行的列进行数据排序。

**示例：** 查询fruits表的f_name字段值，并对其进行排序

```
mysql> SELECT f_name FROM fruits ORDER BY f_name;
+------------+
| f_name     |
+------------+
| apple      |
| apricot    |
| banana     |
| berry      |
| blackberry |
| cherry     |
| coconut    |
| grape      |
| lemon      |
| mango      |
| melon      |
| orange     |
| xbababa    |
| xbabay     |
| xxtt       |
| xxxx       |
+------------+
```

通过指定ORDER BY子句，MySQL对查询的name列的数据，按字母表的顺序进行了升序排序。

**2. 多列排序**

对多列数据进行排序，须将排序的列之间用逗号隔开。

**示例：** 查询fruits表中的f_name和f_price字段，先按f_name排序，再按f_price排序

```
mysql> SELECT f_name,f_price FROM fruits ORDER BY f_name,f_price;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| apple      |    5.20 |
| apricot    |    2.20 |
| banana     |   10.30 |
| berry      |    7.60 |
| blackberry |   10.20 |
| cherry     |    3.20 |
| coconut    |    9.20 |
| grape      |    5.30 |
| lemon      |    6.40 |
| mango      |   15.70 |
| melon      |    8.20 |
| orange     |   11.20 |
| xbababa    |    3.60 |
| xbabay     |    3.60 |
| xxtt       |   11.60 |
| xxxx       |    3.60 |
+------------+---------+
```

#### 提示：

在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。若第一列数据中的所有值都是唯一的，将不再对第二列进行排序。

**3. 指定排序方向**

默认情况下，查询数据按字母升序进行排序(从A~Z)，但数据的排序并不仅限于此，还可以使用ORDER BY对查询结果进行降序排序(从Z~A)，这可以通过关键字DESC实现。

与DESC相反的是ASC（升序排序）

**示例：** 查询fruits表中的f_name和f_price字段，对结果按f_price降序方式排序

```
mysql> SELECT f_name,f_price FROM fruits ORDER BY f_price DESC;
+------------+---------+
| f_name     | f_price |
+------------+---------+
| mango      |   15.70 |
| xxtt       |   11.60 |
| orange     |   11.20 |
| banana     |   10.30 |
| blackberry |   10.20 |
| coconut    |    9.20 |
| melon      |    8.20 |
| berry      |    7.60 |
| lemon      |    6.40 |
| grape      |    5.30 |
| apple      |    5.20 |
| xxxx       |    3.60 |
| xbabay     |    3.60 |
| xbababa    |    3.60 |
| cherry     |    3.20 |
| apricot    |    2.20 |
+------------+---------+
```

**示例：** 查询fruits表，先按f_price降序排序，再按f_name字段升序排序

```
mysql> SELECT f_price,f_name FROM fruits ORDER BY f_price DESC, f_name;
+---------+------------+
| f_price | f_name     |
+---------+------------+
|   15.70 | mango      |
|   11.60 | xxtt       |
|   11.20 | orange     |
|   10.30 | banana     |
|   10.20 | blackberry |
|    9.20 | coconut    |
|    8.20 | melon      |
|    7.60 | berry      |
|    6.40 | lemon      |
|    5.30 | grape      |
|    5.20 | apple      |
|    3.60 | xbababa    |
|    3.60 | xbabay     |
|    3.60 | xxxx       |
|    3.20 | cherry     |
|    2.20 | apricot    |
+---------+------------+
```

DESC关键字只对其前面的列进行降序排序，在这里只对f_price排序，而没有对f_name尽心排序，因此，f_price按降序排序，而f_name列仍按升序排序。

若想对多列都进行降序排序，必须要在每一列的列名后面加DESC关键字。

<br>

### 2.12 分组查询

分组查询是对数据按照某个或多个字段进行分组，MySQL中使用GROUP BY关键字对数据进行分组，基本语法形式为：`[GROUP BY 字段][HAVING <条件表达式>]`

字段值为进行分组时所依据的列名称；

"HAVING <条件表达式>"指定满足表达式限定条件的结果将被显示。

**1. 创建分组**

GROUP BY关键字通常和集合函数一起使用，例如：MAX()、MIN()、COUNT()、SUN()、AVG()。

**示例1：** 根据s_id对fruits表中的数据进行分组

```
mysql> SELECT s_id, COUNT(*) AS TOTAL FROM fruits GROUP BY s_id;
+------+-------+
| s_id | TOTAL |
+------+-------+
|  101 |     3 |
|  103 |     2 |
|  104 |     2 |
|  107 |     2 |
|  102 |     3 |
|  105 |     3 |
|  106 |     1 |
+------+-------+
```

查询结果显示，s_id表示供应商的ID，TOTAL字段使用COUNT()函数计算得出。GROUP BY子句按照s_id排序对数据分组。

若要查看每个供应商提供的水果的种类的名称，MySQL提供了GROUP_CONCAT()函数，将每个分组中各个字段的值显示出来。

**示例：** 根据s_id对fruits表中的数据进行分组，将每个供应商的水果名称显示出来

```
mysql> SELECT s_id,GROUP_CONCAT(f_name) AS Names FROM fruits GROUP BY s_id;
+------+-------------------------+
| s_id | Names                   |
+------+-------------------------+
|  101 | apple,blackberry,cherry |
|  102 | orange,banana,grape     |
|  103 | apricot,coconut         |
|  104 | berry,lemon             |
|  105 | melon,xbabay,xxtt       |
|  106 | mango                   |
|  107 | xxxx,xbababa            |
+------+-------------------------+
```

由结果可以看到，GROUP_CONCAT()函数将每个分组中的名称都显示出来了，其名称的个数与COUNT()函数计算出来的相同。

**2. 使用HAVING过滤分组**

GROUP BY可以和HAVING一起限定显示记录所需满足的条件，只有满足条件的分组才会被显示。

**示例：** 根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息

```
mysql> SELECT s_id,GROUP_CONCAT(f_name) AS Names
    -> FROM fruits
    -> GROUP BY s_id HAVING COUNT(f_name)>1;
+------+-------------------------+
| s_id | Names                   |
+------+-------------------------+
|  101 | apple,blackberry,cherry |
|  102 | orange,banana,grape     |
|  103 | apricot,coconut         |
|  104 | berry,lemon             |
|  105 | melon,xbabay,xxtt       |
|  107 | xxxx,xbababa            |
+------+-------------------------+
```

#### 提示：

HAVING关键字和WHERE关键字都用来过滤数据。两者的区别在于，HAVING再数据分组之后进行过滤来选择分组，而WHERE再分组之前用来选择记录。

**3. 在GROUP BY子句中使用WITH ROLLUP**

使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算出查询出的所有记录的综合，即统计记录数量。

**示例：** 根据s_id对fruits表中的数据进行分组，并显示记录数量

```
mysql> SELECT s_id,COUNT(*) AS Total
    -> FROM fruits
    -> GROUP BY s_id WITH ROLLUP;
+------+-------+
| s_id | Total |
+------+-------+
|  101 |     3 |
|  102 |     3 |
|  103 |     2 |
|  104 |     2 |
|  105 |     3 |
|  106 |     1 |
|  107 |     2 |
| NULL |    16 |
+------+-------+
```

**4. 多字段分组**

使用GROUP BY可以对多个字段进行分组，GROUP BY关键字后面跟需要分组的字段，MySQL根据多字段的值来进行层次分组，分组层次从左到右，即先按第一个字段分组，然后在第一个字段值相同的记录中，再根据第二个字段的值进行分组……以此类推。

**示例：** 根据s_id和f_name字段对fruits表中的数据进行分组

```
mysql> SELECT * FROM fruits GROUP BY s_id,f_name;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
| b5   |  107 | xxxx       |    3.60 |
| bs1  |  102 | orange     |   11.20 |
| bs2  |  105 | melon      |    8.20 |
| c0   |  101 | cherry     |    3.20 |
| l2   |  104 | lemon      |    6.40 |
| m1   |  106 | mango      |   15.70 |
| m2   |  105 | xbabay     |    3.60 |
| m3   |  105 | xxtt       |   11.60 |
| o2   |  103 | coconut    |    9.20 |
| t1   |  102 | banana     |   10.30 |
| t2   |  102 | grape      |    5.30 |
| t4   |  107 | xbababa    |    3.60 |
+------+------+------------+---------+
```

由结果可以看到，查询记录先按照s_id进行分组，再对f_name字段按不同的值进行分组。

**5. GROUP BY和ORDER BY一起使用**

在某些情况下需要对分组进行排序，ORDER BY用来对查询的记录排序，和GROUP BY一起使用可以完成对分组的排序。

首先创建表orderitems，并向表中插入数据

```
mysql> CREATE TABLE orderitems
    -> (
    -> o_num INT NOT NULL,
    -> o_item INT NOT NULL,
    -> f_id CHAR(10) NOT NULL,
    -> quantity INT NOT NULL,
    -> item_price DECIMAL(8,2) NOT NULL,
    -> PRIMARY KEY (o_num,o_item)
    -> );
Query OK, 0 rows affected (0.11 sec)

mysql> INSERT INTO orderitems(o_num,o_item,f_id,quantity,item_price)
    -> VALUES(30001,1,'a1',10,5.2),
    -> (30001,2,'b2',3,7.6),
    -> (30001,3,'bs1',5,11.2),
    -> (30001,4,'bs2',15,9.2),
    -> (30002,1,'b3',2,20.0),
    -> (30003,1,'c0',100,10),
    -> (30004,1,'o2',50,2.50),
    -> (30005,1,'c0',5,10),
    -> (30005,2,'b1',10,8.99),
    -> (30005,3,'a2',10,2.2),
    -> (30005,4,'m1',5,14.99);
Query OK, 11 rows affected (0.05 sec)
Records: 11  Duplicates: 0  Warnings: 0
```

**示例：** 查询订单价格大于100的订单号和总订单价格

```
mysql> SELECT o_num,SUM(quantity * item_price) AS orderTotal
    -> FROM orderitems
    -> GROUP BY o_num
    -> HAVING SUM(quantity * item_price)>=100;
+-------+------------+
| o_num | orderTotal |
+-------+------------+
| 30001 |     268.80 |
| 30003 |    1000.00 |
| 30004 |     125.00 |
| 30005 |     236.85 |
+-------+------------+
```

可以看到，返回结果中的orderTotal列的总订单价格并没有按照一定顺序来显示，接下来，使用ORDER BY关键字按照总订单价格排序显示：

```
mysql> SELECT o_num,SUM(quantity*item_price) AS orderTotal
    -> FROM orderitems
    -> GROUP BY o_num
    -> HAVING SUM(quantity*item_price)>=100
    -> ORDER BY orderTotal;
+-------+------------+
| o_num | orderTotal |
+-------+------------+
| 30004 |     125.00 |
| 30005 |     236.85 |
| 30001 |     268.80 |
| 30003 |    1000.00 |
+-------+------------+
```

#### 提示：

当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序。即ORDER BY和ROLLUP时相互排斥的。

<br>

### 2.13 使用LIMIT限制查询结果的数量

SELECT返回所有匹配的行，有可能时表中所有的行，若仅仅需要返回第一行或者前几行，可以使用LIMIT关键字。

基本语法格式为：`LIMIT [位置偏移量,] 行数`

其中，“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，若不指定“位置偏移量”，将会从表中的第一条记录开始；第二个参数“行数”指示返回的记录条数。

**示例1：** 显示fruits表查询结果的前4行

```
mysql> SELECT * FROM fruits LIMIT 4;
+------+------+------------+---------+
| f_id | s_id | f_name     | f_price |
+------+------+------------+---------+
| a1   |  101 | apple      |    5.20 |
| a2   |  103 | apricot    |    2.20 |
| b1   |  101 | blackberry |   10.20 |
| b2   |  104 | berry      |    7.60 |
+------+------+------------+---------+
```

由结果剋有看到，该语句没有指定返回记录的"位置偏移量"参数，显示结果从第一行开始，“行数”参数为4，因此返回的结果为表中的前4行记录。

**示例2：** 在fruits表中，使用LIMIT子句，返回从第5个记录开始的，行数长度为3的记录

```
mysql> SELECT * FROM fruits LIMIT 4, 3;
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b5   |  107 | xxxx   |    3.60 |
| bs1  |  102 | orange |   11.20 |
| bs2  |  105 | melon  |    8.20 |
+------+------+--------+---------+
```

由结果可以看到，第一个数字'4'表示从第5行开始（位置偏移量从0开始），第二个数字3表示返回的行数。

所以，带一个参数的LIMIT指定从查询结果中的首行开始，唯一的参数表示返回的行数。带两个参数的LIMIT可以返回从任何一个位置开始的指定的行数。

也可以使用`LIMIT m OFFSET n`，表示偏移量为m，行数为n：

```
mysql> SELECT * FROM fruits LIMIT 4 OFFSET 3;
+------+------+--------+---------+
| f_id | s_id | f_name | f_price |
+------+------+--------+---------+
| b2   |  104 | berry  |    7.60 |
| b5   |  107 | xxxx   |    3.60 |
| bs1  |  102 | orange |   11.20 |
| bs2  |  105 | melon  |    8.20 |
+------+------+--------+---------+
```

---

## 3.使用聚合函数查询

MySQL提供一些查询功能，可以对获取的数据进行分析和报告。这些函数的功能有：
* 计算数据表中记录行数的总数；
* 计算某个字段列下数据的总和；
* 计算表中某个字段下的最大值、最小值或平均值；

**MySQL聚合函数**

|函数|作用|
|:---|:---|
|ACG()|返回某列的平均值|
|COUNT()&#160;&#160;&#160;&#160;&#160;&#160;|返回某列的行数|
|MAX()|返回某列的最大值&#160;&#160;&#160;&#160;&#160;&#160;|
|MIN()|返回某列的最小值|
|SUM()|返回某列值的和|

<br>

### 3.1 COUNT()函数

COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数。其使用方法有两种：
* COUNT(*)：计算表中总的行数，不管某列有数值或者为空值；
* COUNT(字段名)：计算指定列下总的行数，计算时忽略空值的行；

**示例1：** 查询customers表中总的行数

```
mysql> SELECT COUNT(*) AS cust_num FROM customers;
+----------+
| cust_num |
+----------+
|        4 |
+----------+
```

由查询结果可以看到，COUNT(*)返回customers表中记录的总行数，不管其值时什么，返回总数的名称为cust_num。

**示例2：** 查询customers表中由电子邮箱的顾客的总数

```
mysql> SELECT COUNT(c_email) AS email_num FROM customers;
+-----------+
| email_num |
+-----------+
|         3 |
+-----------+
```

由查询结果可以看到，表中4个customer只有3个有email，customer的email为空值NULL的记录不会被COUNT()函数计算。

**示例3：** 在orderitems表中，使用COUNT()函数统计不同订单号中订购的水果种类

```
mysql> SELECT o_num,COUNT(f_id)
    -> FROM orderitems
    -> GROUP BY o_num;
+-------+-------------+
| o_num | COUNT(f_id) |
+-------+-------------+
| 30001 |           4 |
| 30002 |           1 |
| 30003 |           1 |
| 30004 |           1 |
| 30005 |           4 |
+-------+-------------+
```

可以看到，GROUP BY关键字先按照订单进行分组，然后计算每个分组中的总记录数。

<br>

### 3.2 SUM()函数

SUM()是一个求总和的函数，返回指定列值的总和。

**示例1：** 在orderitems表中查询30005号订单一共购买的水果总量

```
mysql> SELECT SUM(quantity) AS items_total
    -> FROM orderitems
    -> WHERE o_num=30005;
+-------------+
| items_total |
+-------------+
|          30 |
+-------------+
```

SUM()可以与GROUP BY一起使用，来计算每个分组的总和。

**示例2：** 在orderitems表中，使用SUM()函数统计不同订单号中订购的水果总和

```
mysql> SELECT o_num,SUM(quantity) AS items_total
    -> FROM orderitems
    -> GROUP BY o_num;
+-------+-------------+
| o_num | items_total |
+-------+-------------+
| 30001 |          33 |
| 30002 |           2 |
| 30003 |         100 |
| 30004 |          50 |
| 30005 |          30 |
+-------+-------------+
```

#### 提示：

SUM()函数在计算中，忽略列值为NULL的行。

<br>

### 3.3 AVG()函数

AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。

**示例1：** 在fruits表中，查询s_id=103的供应商的水果价格的平均值

```
mysql> SELECT AVG(f_price) AS avg_price
    -> FROM fruits
    -> WHERE s_id=103;
+-----------+
| avg_price |
+-----------+
|  5.700000 |
+-----------+
```

AVG()可以与GROUP BY一起使用，来计算每个分组的平均值

**示例2：** 在fruits表中，查询每一个供应商的水果价格的平均值

```
mysql> SELECT s_id,AVG(f_price) AS avg_price
    -> FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | avg_price |
+------+-----------+
|  101 |  6.200000 |
|  103 |  5.700000 |
|  104 |  7.000000 |
|  107 |  3.600000 |
|  102 |  8.933333 |
|  105 |  7.800000 |
|  106 | 15.700000 |
+------+-----------+
```

#### 提示：

AVG()函数使用时，其参数为要计算的列的名称，如果要得到多个列的多个平均值，则需要在每一列上都使用AVG()函数。

<br>

### 3.4 MAX()函数

MAX()函数返回指定列中的最大值。

**示例1：** 在fruits表中查市场上价格最高的水果值

```
mysql> SELECT MAX(f_price) AS max_price FROM fruits;
+-----------+
| max_price |
+-----------+
|     15.70 |
+-----------+
```

**示例2：** 在fruits表中查找不同供应商提供的价格最高的水果值

```
mysql> SELECT s_id,MAX(f_price) AS max_price FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | max_price |
+------+-----------+
|  101 |     10.20 |
|  103 |      9.20 |
|  104 |      7.60 |
|  107 |      3.60 |
|  102 |     11.20 |
|  105 |     11.60 |
|  106 |     15.70 |
+------+-----------+
```

MAX()函数不仅适用于查找数值类型，也可以用于字符类型。

**示例3：** 在fruits表中查找f_name的最大值

```
mysql> SELECT MAX(f_name) FROM fruits;
+-------------+
| MAX(f_name) |
+-------------+
| xxxx        |
+-------------+
```

由结果可以看到，MAX()函数可以对字母进行大小判断，并返回最大的字符或者字符串值。

<br>

### 3.5 MIN()函数

MIN()返回查询列表中的最小值

**示例1：** 在fruits表中查找市场上价格最低的水果值

```
mysql> SELECT MIN(f_price) AS min_price FROM fruits;
+-----------+
| min_price |
+-----------+
|      2.20 |
+-----------+
```

MIN()也可以和GROUP BY关键字一起使用

**示例2：** 在fruits表中查询不同供应商提供的价格最低的水果值

```
mysql> SELECT s_id,MIN(f_price) AS min_price
    -> FROM fruits
    -> GROUP BY s_id;
+------+-----------+
| s_id | min_price |
+------+-----------+
|  101 |      3.20 |
|  103 |      2.20 |
|  104 |      6.40 |
|  107 |      3.60 |
|  102 |      5.30 |
|  105 |      3.60 |
|  106 |     15.70 |
+------+-----------+
```

同样，MIN()函数有MAX()函数类似，不仅使用与查找数值类型，也可应用于字符串类型。

---

## 4.连接查询

连接是关系数据库模型的主要特点。连接查询时关系型数据库中最主要的查询，主要包括内连接、外连接等。

### 4.1 内连接查询

内连接(INNER JOIN)使用比较运算符进行表间某（些）列数据的比较操作，并列出表中与连接条件相匹配的数据行，组合成新记录。也就是说，在内连接查询中，只有满足条件的记录才能出现在结果关系中。

首先创建数据表suppliers并插入数据：

```
mysql> CREATE TABLE suppliers
    -> (
    -> s_id INT NOT NULL AUTO_INCREMENT,
    -> s_name CHAR(50) NOT NULL,
    -> s_city CHAR(50) NULL,
    -> s_zip CHAR(50) NULL,
    -> s_call CHAR(50) NOT NULL,
    -> PRIMARY KEY (s_id)
    -> );
Query OK, 0 rows affected (0.13 sec)

mysql> INSERT INTO suppliers (s_id,s_name,s_city,s_zip,s_call)
    -> VALUES(101,'FastFruit Inc.','Tianjin','300000','48075'),
    -> (102,'LT Supplies','Chongqing','400000','44333'),
    -> (103,'ACME','Shanghi','200000','90046'),
    -> (104,'FNK Inc.','Zhongshan','528437','11111'),
    -> (105,'Good Set','Taiyuang','030000','22222'),
    -> (106,'Just Eat Ours','Beijing','010','45678'),
    -> (107,'DK Inc.','Zhengzhou','450000','33332');
Query OK, 7 rows affected (0.06 sec)
Records: 7  Duplicates: 0  Warnings: 0
```

**示例：** 在fruits表和suppliers表之间使用内连接查询

首先查看两个表的结构：

```
mysql> DESC fruits;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| f_id    | char(10)     | NO   | PRI | NULL    |       |
| s_id    | int(11)      | NO   |     | NULL    |       |
| f_name  | char(255)    | NO   |     | NULL    |       |
| f_price | decimal(8,2) | NO   |     | NULL    |       |
+---------+--------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql> DESC suppliers;
+--------+----------+------+-----+---------+----------------+
| Field  | Type     | Null | Key | Default | Extra          |
+--------+----------+------+-----+---------+----------------+
| s_id   | int(11)  | NO   | PRI | NULL    | auto_increment |
| s_name | char(50) | NO   |     | NULL    |                |
| s_city | char(50) | YES  |     | NULL    |                |
| s_zip  | char(50) | YES  |     | NULL    |                |
| s_call | char(50) | NO   |     | NULL    |                |
+--------+----------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
```

由结果可以看到，fruits表和suppliers表中都有相同数据类型的字段s_id，两个表通过s_id字段建立联系。

接下来从fruits表中查询f_name，f_price字段，从suppliers表中查询s_id，s_name：

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price FROM fruits, suppliers
    -> WHERE fruits.s_id = suppliers.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  103 | ACME           | apricot    |    2.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  102 | LT Supplies    | orange     |   11.20 |
|  105 | Good Set       | melon      |    8.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  103 | ACME           | coconut    |    9.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

这里，SELECT语句与前面所介绍的一个最大的差别是：SELECT后面指定的列分别属于两个不同的表，(f_name,f_price)在表fruits中，(s_name,s_id)在表表suppliers表中；同时FROM子句列出了两个表fruits和suppliers。WHERE子句子啊这里作为过滤条件，指明只有两个表中的s_id字段值相等的时候才符合连接查询的条件。返回结果中可以看到，显示的记录是由两个表中不同列值组成的新记录。

#### 提示：

因为fruits表和suppliers表中有相同的字段s_id，因此在比较的时候，需要完全限定表名（格式为："表名.列名"），若只给出s_id，MySQL将不知道指的是哪一个，并返回错误信息。

**示例：** 在fruits表和suppliers表之间，使用INNER JOIN语法进行内连接查询

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price
    -> FROM fruits INNER JOIN suppliers
    -> ON fruits.s_id = suppliers.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  103 | ACME           | apricot    |    2.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  102 | LT Supplies    | orange     |   11.20 |
|  105 | Good Set       | melon      |    8.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  103 | ACME           | coconut    |    9.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

这里的查询语句，两表之间的关系通过INNER JOIN指定。使用这种语法的时候，连接条件用**ON**子句给出而不是WHERE，ON和WHERE后面指定的条件相同。

若在一个连接查询中，涉及的两个表都是同一个表，这种查询称为**自连接查询**。

自连接是一种特殊的内连接，它指相互连接的表在物理上同为一张表，但可以在逻辑上分为两张表。

**示例：** 查询供应f_id='a1'的水果供应商提供的水果种类

```
mysql> SELECT f1.f_id,f1.f_name FROM fruits AS f1, fruits AS f2
    -> WHERE f1.s_id=f2.s_id AND f2.f_id='a1';
+------+------------+
| f_id | f_name     |
+------+------------+
| a1   | apple      |
| b1   | blackberry |
| c0   | cherry     |
+------+------------+
```

<br>

### 4.2 外连接查询

外连接查询将查询多个表中相关联的行，内连接时，返回查询结果集合中的仅是符合查询条件和连接条件的行。

但有时候需要包含没有关联的行中数据，即返回查询结果集合中的不仅包含符合连接条件的行，而且还包括左表（左外连接或左连接）、右表（右外连接或右连接）或两个连接表（全外连接）中所有数据行。

外连接分为左外连接和右外连接：
* LEFT JOIN（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录；
* RIGHT JOIN（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录；


**1. LEFT JOIN（左连接）**

左连接的结果包括LEFT OUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。若左表的某行在右表中没有匹配行，则在相关联的结果行中，右表的所有选择列表列均为空值。

首先创建表orders，并插入数据

```
mysql> CREATE TABLE orders
    -> (
    -> o_num INT NOT NULL AUTO_INCREMENT,
    -> o_date DATETIME NOT NULL,
    -> c_id INT NOT NULL,
    -> PRIMARY KEY (o_num)
    -> );
Query OK, 0 rows affected (0.12 sec)

mysql> INSERT INTO orders(o_num,o_date,c_id)
    -> VALUES(3001,'2008=09=12',10001),
    -> (3002,'2008');
ERROR 1136 (21S01): Column count doesn't match value count at row 2
mysql> INSERT INTO orders(o_num,o_date,c_id)
    -> VALUES(30001,'2008-09-01',10001),
    -> (30002,'2008-09-12',10003),
    -> (30003,'2008-09-30',10004),
    -> (30004,'2008-10-03',10005),
    -> (30005,'2008-10-08',10001);
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0
```

**示例：** 在customers表和orders表中，查询所有客户，包括没有订单的客户

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers LEFT OUTER JOIN orders
    -> ON customers.c_id=orders.c_id;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10003 | 30002 |
| 10004 | 30003 |
| 10001 | 30005 |
| 10002 |  NULL |
+-------+-------+
```

结果显示了5条记录，ID等于10002的客户目前并没有下订单，所以对应的orders表中并没有该客户的订单信息，所以该条记录只读出了customers表中相应的值，而从orders表中取出的值为NULL。

**2.RIGHT JOIN（右连接）**

右连接是左连接的反向连接，将返回右表的所有行。如果右表的某行在左表中没有匹配行，左表将返回空值。

**示例：** 在customer表和orders表中，查询所有订单，包括没有客户的订单

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers RIGHT OUTER JOIN orders
    -> ON customers.c_id=orders.c_id;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10003 | 30002 |
| 10004 | 30003 |
|  NULL | 30004 |
| 10001 | 30005 |
+-------+-------+
```

结果显示了5条记录，订单号等于30004的订单的客户可能由于某种原因取消了该订单，对应的customers表中并没有该客户的信息，所以该条记录只取出了orders表中相应的值，而从customers表中取出的值为NULL。

### 4.3 复合条件连接查询

复合条件连接查询是在连接查询的过程中，通过添加过滤条件，显示查询的结果，使查询的结果更加准确。

**示例：** 在customers表和orders表中，使用INNER JOIN语法查询customers表中ID为10001的客户的订单信息

```
mysql> SELECT customers.c_id,orders.o_num
    -> FROM customers INNER JOIN orders
    -> ON customers.c_id=orders.c_id AND customers.c_id=10001;
+-------+-------+
| c_id  | o_num |
+-------+-------+
| 10001 | 30001 |
| 10001 | 30005 |
+-------+-------+
```

结果显示，在连接查询时指定查询客户ID为10001的订单信息，添加了过滤条件之后返回的结果将会变少，因此返回结果只有两条记录。

**示例：** 在fruits表和suppliers表之间，使用INNER JOIN语法进行内连接查询，并对查询结果排序

```
mysql> SELECT suppliers.s_id,s_name,f_name,f_price
    -> FROM fruits INNER JOIN suppliers
    -> ON fruits.s_id=suppliers.s_id
    -> ORDER BY fruits.s_id;
+------+----------------+------------+---------+
| s_id | s_name         | f_name     | f_price |
+------+----------------+------------+---------+
|  101 | FastFruit Inc. | apple      |    5.20 |
|  101 | FastFruit Inc. | blackberry |   10.20 |
|  101 | FastFruit Inc. | cherry     |    3.20 |
|  102 | LT Supplies    | orange     |   11.20 |
|  102 | LT Supplies    | banana     |   10.30 |
|  102 | LT Supplies    | grape      |    5.30 |
|  103 | ACME           | apricot    |    2.20 |
|  103 | ACME           | coconut    |    9.20 |
|  104 | FNK Inc.       | berry      |    7.60 |
|  104 | FNK Inc.       | lemon      |    6.40 |
|  105 | Good Set       | melon      |    8.20 |
|  105 | Good Set       | xbabay     |    3.60 |
|  105 | Good Set       | xxtt       |   11.60 |
|  106 | Just Eat Ours  | mango      |   15.70 |
|  107 | DK Inc.        | xxxx       |    3.60 |
|  107 | DK Inc.        | xbababa    |    3.60 |
+------+----------------+------------+---------+
```

---














