## 表分区类型

可以使用分区将单个表的各部分分散到一个文件系统中。用户所选择的划分数据的规划被称为分区函数（partitioning function），它可以是模量（modulu），与一组范围或值列表、一个内部哈希函数或一个线性哈希函数简单匹配。

表的不同行可以被分配给不同的物理分区，称为**水平分区**；在**垂直分区**中，表的不同列被分配给不同的物理分区，MySQL不支持垂直分区。

对一个表做分区有很多种方法：
* RANGE：这种类型的分区根据落在给定范围内的列值，将行分配给分区；
* LIST：类似于按RANGE分区，不同的是其分区是基于与一组离散值匹配的列来选择的；
* HASH：在这种类型的分区操作中，一个分区时根据用户定义的表达式返回来的值来选择的，该表达式对插入到表的行中的列值进行操作。HASH函数可以包含任何在MySQL中具有非负整数值的有效表达式；
* KEY：这种类型的分区类似于HASH分区，只是它仅提供一个或多个列，而且MySQL服务器提供自己的哈希函数。这些列可以包含除整数值意外的其他值，因为MySQL提供的哈希函数保证不管列数据是什么类型，结果都是整数；

---

#### 1.RANGE分区

**示例：**

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN (21)
);
```

在这个例子中，所有在1~5号商场工作的员工将被分到p0分区；在6~10号商场工作的员工将被分到p1分区，依次类推。但是当插入一条商场编号大于20的数据时将会抛出错误，因为这里并没有分区可以覆盖到编号大于20的商场。我们可以用一个“捕获所有”的方法来处理小于最大数值的情况：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN  MAXVALUE
);
```

其中，**MAXVALUE**是一个永远大于可能的最大整数值的整数。

这样，所有商场编号大于16的员工的数据将被分配到p3分区。若商场数量增加到较大的数值，我们可以使用ALTER TABLE语句为21~25，26~30等的商场编号分区。

同样的，我们也可以根据职位编号范围来分区。假设，两位数的职位编号是普通员工的编号，三位数的职位编号对应的是办公室和人事部门的员工，四位数的职位编号是管理层的编号，这样，我们可以根据上述划分分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
	PARTITION p0 VALUES LESS THAN (100),
	PARTITION p1 VALUES LESS THAN (1000),
	PARTITION p2 VALUES LESS THAN (10000)
);
```

如果不想根据商店数量来划分分区，也可以根据时间来作为划分依据。例如，我们希望根据每个员工的离职年份作为划分依据，则我们可以这样划分：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (YEAR(separated)) (
	PARTITION p0 VALUES LESS THAN (1991),
	PARTITION p1 VALUES LESS THAN (1996),
	PARTITION p2 VALUES LESS THAN (2001),
	PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

在这种划分方案中，所有在1991年之前离职的员工将被分配到p0分区中；在1991年到1995年之间离职的员工将被分配到p1分区中；在1996年到2000年之间离职的员工将被分配到p2分区中，在2001年之后离职的员工将被分配到p3分区。

也可以用UNIX_TIMESTAMP()函数，根据数据类型为时间戳的列的值来划分分区，如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY VALUE (UNIX_TIMESTAMP(report_updated)) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
	PARTITION p0 VALUES LESS THAN ( MAXVALUE )
)
```

RANGE分区在以下几种情况下会十分高效：
* 当你想要或者需要删除一些“旧”数据。如果你之前在表上应用了分区方案，你只需要使用`ALTER TABLE xxxx DROP PARTITION xx;`语句就可以简单地将某个分区中的所有数据都删除。当某个表中的数据量很大时，使用分区会比`DELETE`语句更加高效；
* 当你想要使用包含日期或时间戳或者来自其他值；
* 你经常查询依赖于作为表分区依据的列。例如，当执行查询语句`EXPLAIN SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND '2000-12-31' GROUP BY store_id;`，MySQL会快速确定只需要扫描p2分区，因为剩下的分区没办法满足`WHERE`后面的条件；

RANGE分区的一个变型是RANGE COLUMNS分区。

RANGE COLUMNS分区可以使用多个列值来确定分区的范围，该范围即可以适用分区中行的放置，也可以用于执行分区整理时确定包含或排除特定分区。

**基于时间间隔的分区方案**

如果想在MySQL8.0中应用基于时间范围或时间间隔的分区方案，你有两个选择方案：

**1.** 用RANGE分区方法对表进行分区，对于分区表达式，可以使用一个函数处理DATE，TIME或者DATETIME列并且返回一个整数数值，例如：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY VALUE ( YEAR(joined) ) (
	PARTITION p0 VALUES LESS THAN (1960),
	PARTITION p1 VALUES LESS THAN (1970),
	PARTITION p2 VALUES LESS THAN (1980),
	PARTITION p3 VALUES LESS THAN (1990),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

在MySQL8.0中，也可以使UNIX_TIMESTAMP()函数处理时间戳列按RANGE分区对表进行分区，例如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
);
```

**2.** 用RANGE COLUMNS对表进行分区，用DATE或DATETIME列作为分区列。例如，members表可以直接用joined列作为分区的依据，如下所示：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS (joined) (
	PARTITION p0 VALUES LESS THAN ('1960-01-01'),
	PARTITION p1 VALUES LESS THAN ('1970-01-01'),
	PARTITION p2 VALUES LESS THAN ('1980-01-01'),
	PARTITION p3 VALUES LESS THAN ('1990-01-01'),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

---

#### 2.LIST分区

MySQL中的LIST分区和RANGE分区在很多方面的很相似。与RANGE分区一样，必须明确定义每一个分区。LIST分区和RANGE分区最主要的不同就是，在LIST分区方法中，每一个分区是基于一组列表中的列值元素而不是一组连续范围内的值来定义和选择的。

这些由`PARTITION BY LIST(expr)`语句来定义，其中expr是一个列的值或者是一个基于列值并且返回一个整数数值的表达式。然后通过`VALUES IN (value_list)`定义每一个分区，其中value_list是用逗号分隔的整数列表。

#### 提示： 

在MySQL8.0中，使用LIST分区时可以只与一列整数（或者是NULL）匹配。但在LIST COLUMNS分区时，值列表中也可以使用其他的列值类型。

与通过范围定义分区的情况不同，列表分区不需要定义任何明确的顺序。

在下面的例子中，我们假设要被分区的表的基础定义由以下的`CREATE TABLE`语句提供：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
);
```

假设一共由有20家影音商店分布在如下4个专营权中：

|地区|商店编号|
|:---|:---|
|NORTH|3,5,6,9,17|
|EAST|1,2,10,11,19,20&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|WEST|4,12,13,14,18|
|CENTRAL&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|7,8,15,16|

为了能将属于同一地区的商店的数据行存储到相同的分区中，可以使用如下的`CREATE TABLE`语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY LIST(store_id) (
	PARTITION pNORTH VALUES IN (3,5,6,9,17),
	PARTITION pEAST VALUES IN (1,2,10,11,19,20),
	PARTITION pWEST VALUES IN (4,12,13,14,18),
	PARTITION pCENTRAL VALUES IN (7,8,15,16)
);
```

这样就可以很容易地添加或删除与特定地区相关的某个员工的纪录。例如，假设所有西部地区的商店都被出售给另外一个公司。在MySQL8.0中，所有与在那个地区的商店中工作的员工的数据行都可以用`ALTER TABLE employees TRUNCATE PARTITION pWEST`语句删除，这比使用相应的DELETE语句`DELETE FROM employees WHERE store_id IN (4,12,13,14,18);`更加高效。（使用`ALTER TABLE employees DROP PARTITION pWEST`语句不仅会删除所有的西部商场员工的数据行，还会从表定义中删除pWEST这个分区，你还需要使用` ALTER TABLE ... ADD PARTITION`声明恢复表原始分区方案。）

与RANGE分区相同，可以将LIST分区与哈希或键分区结合起来产生复合分区（子分区）。

与RANGE分区不同的是，LIST分区没有类似MAXVALUE的"catch-all"语句。所有的分区表达式的期望值必须包含在`PARTITION...VALUES IN (...)`语句中。

如果一个INSERT语句包含了一个未匹配的分区列值将会抛出一个错误，如下：

```
mysql> CREATE TABLE h2 (
    -> c1 INT,
    -> c2 INT
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (1,4,7),
    -> PARTITION p1 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.13 sec)

mysql> INSERT INTO h2 VALUES (3,5);
ERROR 1526 (HY000): Table has no partition for value 3
```

当使用INSERT语句向InnoDB表中一次性插入多条数据时，InnoDB引擎会认为这个语句是单个事务，因此当出现任何未能匹配到的值都会使得这个语句的执行完全失败，不会插入任何行。

可以通过使用IGNORE关键字忽略这类错误。若这样操作，包含未能匹配到分区的列值的行将不会被插入到表中，但是会插入正常匹配到分区的行到表中，并且不会报任何错误：

```
mysql> TRUNCATE h2;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT * FROM h2;
Empty set (0.01 sec)

mysql> INSERT IGNORE INTO h2 VALUES (2,5), (6,10), (7,5), (3,1), (1,9);
Query OK, 3 rows affected, 2 warnings (0.05 sec)
Records: 5  Duplicates: 2  Warnings: 2

mysql> SELECT * FROM h2;
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
```

MySQL8.0也支持LIST COLUMNS分区，一种允许使用整数类型以外的其他列的类型作为分区，并且使用多个列作为分区键的LIST分区。

---

#### 3.COLUMNS分区

COLUMNS分区可以使用多个列作为分区键。为了能将行放置在分区中以及确定在分区修整时为了匹配行哪些分区需要检查，所有这些列都会被纳入考虑的范围。

此外，RANGE COLUMNS分区和LIST COLUMNS分区都支持使用非整数列来定义值范围或列元素。允许使用的数据类型如下所示：
* 所有整数类型：TINYINT，SMALLINT，MEDIUMINT，INT(INTEGER)和BIGINT。（这与RANGE和LIST分区相同）；
* DATE和DATETIME，使用其他日期或时间相关的列不能作为分区列；
* 如下的字符串类型：CHAR，VARCHAR，BINARY和VARBINARY，TEXT和BLOB类型的列不能作为分区列；

#### 3.1 RANGE COLUMNS分区

RANGE COLUMNS分区与RNAGE分区相似，但是允许使用基于多个列值的范围定义分区。另外，可以使用非整数类型的列来定义范围。

RANGE COLUMNS分区与RANGE分区显著的差别如下：
* RANGE COLUMNS不接受表达式，只接受列名；
* RANGE COLUMNS接受一个或多个列的列表；RANGE COLUMNS分区是基于元组（列值列表）之间的比较，而不是标量之间的比较。行在RANGE COLUMNS分区中的放置位置也是基于元组之间的比较；
* RANGE COLUMNS分区列不限于整数列，字符串，DATE和DATETIME列也可以被用作分区列；

创建由RANGE COLUMNS分区的表的基本语法如下所示：

```
CREATE TABLE table_name
PARTITION BY RANGE COLUMNS(column_list) （
	PARTITION partition_name VALUES LESS THAN (value_list)[,
	PARTITION partition_name VALUES LESS THAN (value_list)][,...]
)

column_list:
	column_name[, column_name][,...]

value_list:
	value[,value][,...]
```

其中，column_list是包含一个或多个列的列表（有时也称为分区列列表），value_list是值列表（也即分区定义值列表）。

必须为每个分区定义提供一个value_list，而且每个value_list必须拥有与column_list中的列相同数量的值。也就是说，假如在COLUMNS子句中使用N个列，那么VALUES LESS THAN子句中必须提供一个有N个值的列表。

分区定义中列表中的元素与值列表中的值顺序必须相同。另外，值列表中的每个元素必须与分区列列表中相应的拥有相同的数据类型。

但是，分区列列表中列名和值列表的顺序并不一定要与定义表的`CREATE TABLE`语句中的顺序相同。与按照RANGE分区的表相同，我们可以使用MAXVALUE代表一个使得所有插入到给定行的和合法值永远小于MAXVALUE的值。如：

```
mysql> CREATE TABLE rcx (
    -> a INT,
    -> b INT,
    -> c CHAR(3),
    -> d INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,d,c) (
    -> PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    -> PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
    -> PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
Query OK, 0 rows affected (0.14 sec)
```

rcx表包含了a，b，c，d列。提供给COLUMNS的分区列列表中使用了其中的3个值，顺序为a，d，c。每个用于定义分区的值列表也包含了这3个值，且顺序相同。也就是，每个值列表元组的形式都是(INT,INT,CHAR(3))，对应a，d，c列使用的数据类型（按此顺序）。

通过比较要被插入的行的满足COLUMNS子句中列列表匹配的元组与在`VALUES LESS THAN`子句中使用的用于定义表分组的元组来确定行在分区中的放置位置。因为我们是通过比较元组（也即是，列或者值的集合）而不是标量，RANGE COLUMNS分区中使用的`VALUES LESS THAN `语义与简单RANGE分区的情况有所不同。

在RANGE分区中，一行生成的等于VALUES LESS THAN的限制值的表达值永远不会被放到相应的分区中；然而，当使用RANGE COLUMNS分区时，有可能会将分区列列表中的第一个元素与VALUES LESS THAN值列表中的第一个元素相等的行放置到相应的分区中。

如果以下声明创建了RANGE分区表：

```
CREATE TABLE r1 (
	a INT,
	b INT
)
PARTITION BY RANGE (a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果向表中插入3行数据，每条数据中a的值都是5，所有的数据都会被放置到p1分区，因为3条数据行的a列值都不小于5。我们可以通过对INFORMATION_SCHEMA.PARTITIONS表执行适当的查询来查看分区：

```
mysql> INSERT INTO r1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='r1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```
现在考虑一个相似的表rc1，这个表使用了RANGE COLUMNS分区，在COLUMNS子句中引用了列a和b，创建语句为：

```
CREATE TABLE rc1 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (5,12),
	PARTITION p1 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

如果我们向rc1表中插入与r1表完全相同的数据，结果将会有所不同：

```
mysql> INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rc1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          2 |
| p1             |          1 |
+----------------+------------+
```

这是因为我们比较的是行而不是标量。我们可以将插入的行值与VALUES LESS THAN子句中用来限制rc1表中分区p0的行值进行比较，如：

```
mysql> SELECT (5,10)<(5,12),(5,11)<(5,12),(5,12)<(5,12);
+---------------+---------------+---------------+
| (5,10)<(5,12) | (5,11)<(5,12) | (5,12)<(5,12) |
+---------------+---------------+---------------+
|             1 |             1 |             0 |
+---------------+---------------+---------------+
```

(5,10)和(5,11)这两个元组比(5,12)小，所以它们被存放在分区p0中。又因为5不小于5，12不小于12，所以(5,12)被认为不小于(5,12)，因此被放置在分区p1中。

上面例子中的SELECT语句也可以使用显示行构造函数编写，如：

```
SELECT ROW(5,10)<ROW(5,12),ROW(5,11)<ROW(5,12),ROW(5,12)<ROW(5,12);
```

对于一个仅使用一个分区列的RANGE COLUMNS分区的表，分区中行的存储与由RANGE分区的等效表相同。如：

```
CREATE TABLE rx (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS(a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果我们向表中插入行(5,10)，(5,11)和(5,12)，可以看到它们的存放方式与表r1中的存放方式时相同的：

```
mysql> INSERT INTO rx VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rx';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```

也可以创建由RANGE COLUMNS分区的表，其中在连续的分区定义中重复一个或多个列的限制值。只要是用于定义分区的列值是严格递增的，就可以执行此操作。例如，以下的每个CREATE TABLE语句都是有效的：

```
CREATE TABLE rc2 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);

CREATE TABLE rc3 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p2 VALUES LESS THAN (10,35),
	PARTITION p2 VALUES LESS THAN (20,40),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

以下的声明语句也能成功，即使第一眼看到可能会认为它不能成功执行因为p0分区的b列的限制值是25，p1分区的限制值是20，p1分区的c列限制值是100而p2分区的限制值是50：

```
CREATE TABLE rc4 (
	a INT,
	b INT,
 	c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
	PARTITION p0 VALUES LESS THAN (0,25,50),
	PARTITION p1 VALUES LESS THAN (10,20,100),
	PARTITION p2 VALUES LESS THAN (10,30,50),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
```

当设计以RANGE COLUMNS分区的表，你始终可以使用mysql客户端比较所需的元组来测试连续的分区定义，就像：

```
mysql> SELECT (0,25,50)<(10,20,100),(10,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(10,20,100) | (10,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      1 |
+-----------------------+------------------------+
```

如果CREATE TABLE语句中包含的分区定义顺序不是严格递增，将失败并抛出错误，如：

```
mysql> CREATE TABLE rcf (
    -> a INT,
    -> b INT,
    -> c INT
    -> )
    -> PARTITION BY RANGE COLUMNS (a,b,c) (
    -> PARTITION p0 VALUES LESS THAN (0,25,50),
    -> PARTITION p1 VALUES LESS THAN (20,20,100),
    -> PARTITION p2 VALUES LESS THAN (10,30,50),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
```

若看到此类错误，可以通过在列列表中进行“小于”比较推断哪些分区定义语句是无效的。在上面情况下，问题在于p2分区的定义，因为用于定义的元组并不小于用于定义p3分区的元组：

```
mysql> SELECT (0,25,50)<(20,20,100), (20,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(20,20,100) | (20,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      0 |
+-----------------------+------------------------+
```

使用RANGE COLUMNS分区时，MAXVALUE可以多次出现在VALUES LESS THAN子句的同一列中。然而，连续分区定义中各个列的限制值也应该时增加的，在MAXVALUE被作为上限的所有列中不应该定义多个分区，且这种分区应该出现在`PARTITION ... VALUES LESS THAN`子句列的最后。此外，不能使用MAXVALUE作为多个分区定义第一列的限制值。

正如前面所说，可以在RANGE COLUMNS分区中使用非整数列作为分区列。

例如，使用RANGE COLUMNS分区时，可以创建一个可以根据员工的姓氏将每一行存储在四分区中之一的表：

```
COLUMNS TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

可以通过执行如下ALTER TABLE语句使用此方案修改已经创建的employee表的分区：

```
ALTER TABLE employee PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

同样的，你也可以用`ALTER TABLE`语句将employee表基于员工的雇佣年代将数据存放在不同的分区中，语法如下：

```
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired) (
	PARTITION p0 VALUES LESS THAN ('1970-01-01'),
	PARTITION p1 VALUES LESS THAN ('1980-01-01'),
	PARTITION p2 VALUES LESS THAN ('1990-01-01'),
	PARTITION p3 VALUES LESS THAN ('2000-01-01'),
	PARTITION p4 VALUES LESS THAN ('2010-01-01'),
	PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
```

<br>

#### 3.2 LIST COLUMNS分区

MySQL8.0支持LIST COLUMNS分区。这是一种LIST分区的变型，允许使用多个列作为分区键并且支持非整数类型的作为分区列，可以使用DATE和DATETIME列。

假设你的业务在12个城市拥有客户，出于销售或者市场营销的目的，你将它们分在为4个区域，每个区域有3个城市，如下表所示：

|Region&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|Cities|
|:---|:---|
|1|Oskarshamn,Högsby,Mönsterås|
|2|Vimmerby,Hultsfred,Västervik&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|3|Nässjö,Eksjö,Vetlanda|
|4|Uppvidinge,Alvesta,Växjo|

当用LIST COLUMNS分区时，你可以创建一个客户数据表，该表依据客户所在城市的名称将客户数据行分配给这四个区域中匹配的其中一个区域，如下所示：

```
CREATE TABLE customers_1 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
	PARTITION pRegion_1 VALUES IN ('Oskarshamn','Högsby','Mönsterås'),
	PARTITION pRegion_2 VALUES IN ('Vimmerby','Hultsfred','Västervik'),
	PARTITION pRegion_3 VALUES IN ('Nässjö','Eksjö','Vetlanda'),
	PARTITION pRegion_4 VALUES IN ('Uppvidinge','Alvesta','Växjo')
);
```

就像RANGE COLUMNS分区一样，你不需要在COLUMNS()子句中使用表达式将列值转化成为整数。（实际上，COLUMNS()不允许使用除列名之外的其他表达式）。

也可以使用DATE和DATETIME列，在下面的例子中使用与之前customers_1表一样的列和名称，但使用基于renewal列的LIST COLUMNS分区将行存储在4个分区中的其中一个，具体取决于客户账户在2010年2月第几周更新：

```
CREATE TABLE customers_2 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES IN ('2010-02-01','2010-02-02','2010-02-03','2010-02-04','2010-02-05','2010-02-06','2010-02-07'),
	PARTITION pWeek_2 VALUES IN ('2010-02-08','2010-02-09','2010-02-10','2010-02-11','2010-02-12','2010-02-13','2010-02-14'),
	PARTITION pWeek_3 VALUES IN ('2010-02-15','2010-02-16','2010-02-17,'2010-02-18','2010-02-19','2010-02-20','2010-02-21'),
	PARTITION pWeek_4 VALUES IN ('2010-02-22','2010-02-23','2010-02-24','2010-02-25','2010-02-26','2010-02-27','2010-02-28')
);
```

这是可行的，但是如果日期数量增加到很大的数值，则定义和维护这个表会变得很麻烦。这种情况下，更常用的是用RANGE或者RANGE COLUMNS分区方法。在上述例子中，由于希望用作分区键的是DATE列，所以使用RANGE COLUMNS分区方法，如下所示：

```
CREATE TABLE customers_3 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES LESS THAN ('2010-02-08'),
	PARTITION pWeek_2 VALUES LESS THAN ('2010-02-15'),
	PARTITION pWeek_3 VALUES LESS THAN ('2010-02-22'),
	PARTITION pWeek_4 VALUES LESS THAN ('2010-03-01')
);
```

另外，与RANGE COLUMNS分区相同，也可以在COLUMNS()子句中使用多个列。

---

#### 4.HASH分区

用HASH分区主要是为了确保在预定数量之间的分区能够使分数据均匀分布。对于RANGE和LIST分区，我们必须明确指定将给定某个列值或某组列值应该存放在哪个分区中，这个由我们决定，我们仅需要确定列值或基于要散列的列值以及要将划分的分区数的表达式。

使用HASH分区划分表，必须在CREATE TABLE语句后面添加一个PARTITION BY HASH(expr)子句，其中expr使一个能返回整数的表达式。这可以只是列的名，该列的类型是MySQL整数类型中的一种。

另外，你可能很希望在此之后增加一个PARTITIONS num，其中num是代表这个表将被划分为的分区数的正整数。

#### 提示：

为简单起见，下面例子中的表并没有使用任何键。你应该意识到，如果表中拥有唯一键，被用于这个表分区表达式中的每一列都必须是这些唯一键的一部分，包括主键。

下面创建一个在store_id列上使用哈希表的语句将表分成了4个分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(store_id)
PARTITION 4;
```

如果没有包含PARTITION子句，分区的数量将默认是1；使用PARTITION关键字但后面没带数字将出现语法错误。

你也可以使用一个返回整数的SQL表达式expr。例如，你想根据雇佣员工的年份进行分区。可用如下语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(YEAR(hired))
PARTITION 4;
```

其中，expr必须返回一个非恒定，非随机的整数值（也就是说，它应该是变化但是确定的），并且不得包含第6节中“分区的限制”中提到的任何禁止构造。你应该记住，每次插入或更新（或者删除）一行数据时，都会求这个表达式的值，这意味着过于复杂的表达式可能会造成性能问题，特别是在执行能一次性影响很多行数据的操作时（例如批量插入时）。

最高效的散列函数是对单个表的列进行操作的函数，其值与列值一致的增大或减小，因为这允许对分区范围进行“裁剪”。这也就是，表达式随着其所基于的列值的变化越紧密，MySQL越能高效地使用该表达式进行哈希分区。

例如，date_col是类型为DATE的列，则表达式`TO_DAYS(date_col)`随着date_col值的变化而变化，因为对于date_col值的每次更改，表达式的值也相应的做更改。表达式`YEAR(date_col)`相对于date_col的变动相对于`TO_DAYS(date_col)`对于date_col的变动并不是那么直接，因为并不是所有date_col的变动都会使`YEAR(date_col)`产生同样的改变。即便如此，`YEAR(date_col)`也是散列函数的理想选择，因为它能随着date_col的一部分变化而直接变化，并且date_col中的改变不可能在`YEAR(date_col)`中产生不成比例的变化。

相比之下，假如有一个名为int_col的列，数据类型为INT。考虑表达式`POW(5-int_col,3)+6`。这并不是散列方程的理想对象，因为int_col值的改变并不能保证表达式的值能做出相应的变化。用一个给定的数值改变int_col的值可能使得表达式的值产生很大的差别。例如，将int_col的值从5变为6，表达式的值会改变-1，但当int_col的值从6变为7时，表达式的值将改变-7-。

也就是说，列值与表达式值的曲线越接近方程`y=cx`（其中c时一个非零常数）所描绘的直线，表达式更适合作为哈希函数。这与以下事实有关，表达式越是非线性的，它所产生的数据在分区中的分布越不均匀。

理论上讲，也可以对包含多个列值的表达式进行修剪，但是确定哪个表达式更适合可能非常困难且耗时。因此，使用包含多个列的散列表达式并不是十分推荐。

当使用哈希分区时，存储引擎会依据表达式结果的模数来确定要使用num个分区中的哪个分区。也就是说，对于一个给定的表达式expr，记录被存储的分区号为N，其中`N=MOD(expr,num)`。假设表t1被如下语句定义，因此它有4个分区：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY HASH (YEAR(col3))
PARTITION 4;
```

如果向表t1中插入一条col3值为'2005-09-15'的记录，则它被存放的分区取决于以下函数：

```
 MOD(YEAR('2005-09-15'),4)
=MOD(2005,4)
=1
```

MySQL8.0还支持HASH分区一个变型，也就是linear hashing，它采用了更加复杂的算法以确定插入表中的新行应该被存储到哪个分区中。

每次插入或更新一条记录时，都会评估用户提供的表达式。当删除记录时，还可能依据情况对其进行评估。

#### 4.1 LINEAR HASH分区

MySQL也支持线性散列，与常规散列不同的是线性散列采用了线性二乘幂算法而普通散列使用散列函数值的模数。

从语法上讲，线性散列分区与普通散列分区唯一的不同之处仅是在`PARTITION BY`子句中增加了LINEAR关键字，如下所示：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	stored_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITION 4;
```

给定一个表达式expr，使用线性散列时存储记录的分区是num个分区中的N分区号，其中N是根据以下算法产生的：

1. 查找下一个比num大的2的幂值，我们称之为V，它可以由如下计算产生：

	```
	V = POWER(2,CEILING(LOG(2,num)))
	```
	（假设num的值是13，则`LOG(2,13)`的值是3.7004，`CEILING(3.7004)`的值是4，所以`V = POWER(2,4)`是16。）

2. 令`N = F(column_list)&(V-1)`；
3. 当N≥num：
	* 令`V = V/2`；
	* 令`N = N&(V-1)`

假设有表t1，该表使用线性散列分区并拥有6个分区，其创建语句为：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR HASH( YEAR(col3) )
PARTITION 6;
```

假设现在要插入两条记录到t1表中，且两条记录的col3列的值分别为'2003-04-14'和'1998-10-19'。第一条记录的分区号由如下语句定义：

```
V = POWER(2,CEILING(LOG(2,6))) = 8
N = YEAR('2003-04-14') & (8-1)
  = 2003 & 7 (位与运算)
  = 3

(3≥6为假，因此该条记录被分配到3号分区)
```

第二条记录的分区号由下面语句确定：

```
V = 8
N = YEAR('1998-10-19') & (8-1)
  = 1998 & 7
  = 6

(6≥6为真，需要进一步计算)

N = 6 & ((8/2)-1)
  = 6 & 3
  = 2

(2≥6为假，因此该条记录被分配到2号分区)
```

线性散列进行分区的优势在于添加、删除、合并和拆分分区更加快捷，这在于处理存储了极其庞大的数据的表时十分有用。缺点在于，比起常规散列分区，线性散列分区的数据在分区中的分布并不是那么均匀。

----

#### 5.KEY分区

键分区与哈希分区相似，除了哈希分区使用了用户自定义的表达式之外，键分区的散列函数是由MySQL服务器提供的。

`CREATE TABLE ... PARTITION BY KEY`的 语法规则与创建采用哈希分区的表的语法规则相似。最主要的区别是：
* 采用的是KEY而不是HASH；
* KEY只接受零个或多个列名的列表。如表含有一个主键，则任何作为分区键的列都必须包含部分或全部表的主键。如果没有任何指定任何列名作为分区键，则默认使用表的主键（如果含有主键）。下面的`CREATE TABLE`语句在MySQL8.0中是有效的：

	```
	CREATE TABLE k1 (
		id INT NOT NULL PRIMARY KEY,
		name VARCHAR(20)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```
	如果没有主键但拥有一个唯一键，则唯一键将被用作分区键：

	```
	CREATE TABLE k1 (
		id INT NOT NULL,
		name VARCHAR(20),
		UNIQUE KEY (id)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```

	然而，若唯一键列没有被定义为`NOT NULL`，则前面例子中的语句将执行失败。

在这两种情况下，分区键都是id列，即使没有在`SHOW CREATE TABLE`或者在`INFORMATION_SCHEMA.PARTITIONS`表的`PARTITION_EXPRESSION`列中显示出来。

不像其他分区类型，KEY分区使用的列并没有严格限制只能是整数或NULL值。例如，下面的`CREATE TABLE`语句是可行的：

```
CREATE TABLE tm1 (
	s1 CHAR(32) PRIMARY KEY
)
PARITION BY KEY(s1)
PARITION 10;
```

若指定其他分区类型，上述例子中的语句将是无效的。（在这种请款下，只使用`PARTITION BY KEY()`也是可行的，与使用`PARTITION BY KEY(s1)`效果一样，因为s1是表的主键。）

#### 重要：

对于一个使用键分区的表，不能执行`ALTER TABLE DROP PRIMARY KEY`，如果这样做会产生错误：`ERROR 1466 (HY000): Field in list of fields for partition function not found in table.`

也可以使用线性键对表进行分区。如下所示：

```
CREATE TABLE tk (
	col1 INT NOT NULL,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR KEY(col1)
PARTITION 3;
```

LINEAR关键字对KEY分区的作用与对HASH分区的作用一样，使用二乘幂算法而不是取模运算产生分区号。

---

#### 6.细分

细分，也成为复合分区，是对分区表中每个表的进一步划分。考虑如下`CREATE TABLE`语句：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased))
SUBPARTITION 2 (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

表ts有3个RANGE分区。p0，p1和p2分区都被进一步划分为2个子分区。实际上，整个表被划分成`3*2=6`个分区。然而，因为`PARTITION BY RANGE`子句的作用，其中的前两个值只存储那些purchased列的值小于1990的记录。

可以通过对使用RANGE或LIST分区的表进行细分。子分区可以使用HASH或KEY分区。这也就是复合分区。

#### 注意：

`SUBPARTITION BY HASH`和`SUBPARTITION BY KEY`通常分别遵循`PARTITION BY HASH`和`PARTITION BY KEY`的语法规则。唯一的区别就是`SUBPARTITION BY KEY`（不像`PARTITION BY KEY`）并不支持默认列，因此，即使表拥有显示的主键，也必须指定用于此语法的列。

可以是使用`SUBPARTITION`子句来明确定义子分区，以指定每个子分区的选项。例如，创建前面例子中的ts表的更加冗长的方式为：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased)) (
	PARTITION p0 VALUES LESS THAN (1990) (
		SUBPARTITION s0,
		SUBPARTITION s1
	),
	PARTITION p1 VALUES LESS THAN (2000) (
		SUBPARTITION s2,
		SUBPARTITION s3
	),
	PARTITION p2 VALUES LESS THAN MAXVALUE (
		SUBPARTITION s4,
		SUBPARTITION s5
	)
);
```

这里列出了一些语法上的注意事项：
* 每个分区都应拥有相同数量的子分区；
* 如果在一个分区表中明使用`SUBPARTITION`确定义了任何子分区，必须完整地定义它们。否则将失败：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s2,
			SUBPARTITION s3
		)
	);
	```
	如果使用到SUBPARTITIONS 2将会出错；
* 每个`SUBPARTITION`子句必须包含（至少）一个子分区的名称。否则，你可以为子分区设置任何所需的选项或者允许其采用该选项的默认设置；
* 子分区的名称在整个表中应该是唯一的。如下的`CREATE TABLE`语法是有效的：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000) (
			SUBPARTITION s2,
			SUBPARTITION s3
		),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s4,
			SUBPARTITION s5
		)
	);
	```

---

#### 7.MySQL分区如何处理NULL值

MySQL中的分区允许NULL作为分区表达式的值，不论它是列值还是用户提供的表达式的值。虽然允许使用NULL值作为其他必须产生整数的表达式的值，也必须记住NULL不是一个数字。MySQL的分区实现将NULL视为小于任何非NULL值的值，就如`ORDER BY`一样。

这意味着对NULL的处理随着分区类型的不同而变化，而且可能产生意想不到的结果。在这种情况下，我们将在本节中讨论在确定应存储行的分区时每种MySQL分区类型如何处理NULL值，并提供每种示例。


#### RANGE分区处理NULL值

如果向一个由RANGE分区的表中插入一行数据，其中决定分区的列值是NULL，则这行数据将被插入到最低的分区中。考虑以下两个在p数据库中的表：

```
mysql> CREATE TABLE t1
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (0),
    -> PARTITION p1 VALUES LESS THAN (10),
    -> PARTITION p2 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.40 sec)

mysql> CREATE TABLE t2
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (-5),
    -> PARTITION p1 VALUES LESS THAN (0),
    -> PARTITION p2 VALUES LESS THAN (10),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.31 sec)
```

可以使用如下查询语句查询INFORMATION_SCHEMA数据库中的PARTITIONS表，查看上述两`CREATE TABLE`语句创建的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          0 |              0 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.09 sec)
```

现在，向每个表中填充一行被用作分区键的列中带有NULL的数据，并使用`SELECT`语句验证数据行已被插入到表中：

```
mysql> INSERT INTO t1 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> INSERT INTO t2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> SELECT * FROM t1;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
```

可以通过前面查询INORMATIONS_SCHEMA.PARTITIONS表的语句查看那个分区被用来存储被插入的数据行：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          1 |          16384 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          1 |          16384 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
```

你也可以通过删除最低的分区以证明这两行数据都被存放在这些分区中，并重新执行`SELECT`语句：

```
mysql> ALTER TABLE t1 DROP PARTITION p0;
Query OK, 0 rows affected (0.14 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE t2 DROP PARTITION p0;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM t1;
Empty set (0.05 sec)

mysql> SELECT * FROM t2;
Empty set (0.05 sec)
```

使用SQL函数的分区表达式也这样处理NULL值。假设我们使用如下的`CREATE TABLE`语句定义一个表：

```
CREATE TABLE tndate (
	id INT,
	dt DATE
)
PARTITION BY RANGE(YEAR(dt)) (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

正如其他的MySQL函数，`YEAR(NULL)`返回NULL值。一行dt列值为NULL的数据被分区表达式认为是一个小于任何其他值的方式处理，因此这行数据被插入p0分区。

#### LIST分区处理NULL值

当且仅当分区定义中使用了包含NULL值的列表时，使用LIST分区的表才允许有NULL值。相反的，当一个使用LIST分区的表没有在值列表里明确使用了NULL值时，它将拒绝在分区表达式中会产生NULL值的数据行。例如：

```
mysql> CREATE TABLE ts1 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.25 sec)

mysql> INSERT INTO ts1 VALUES (9,'mothra');
ERROR 1526 (HY000): Table has no partition for value 9

mysql> INSERT INTO ts1 VALUES (NULL,'mothra');
ERROR 1526 (HY000): Table has no partition for value NULL
```

只有c1列的值在0到8之间的数据行可以被插入到表中ts1中。NULL在这个范围之外，就像数字9一样。我们可以创建值列表中包含NULL值的ts2和ts3表：

```
mysql> CREATE TABLE ts2 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8),
    -> PARTITION p3 VALUES IN (NULL)
    -> );
Query OK, 0 rows affected (0.23 sec)

mysql> CREATE TABLE ts3 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7,NULL),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.27 sec)
```

当定义分区列值时，可以（也应该）像处理其他值一样处理NULL值。例如，`VALUES IN (NULL)`和`VALUES IN (1,4,7,NULL)`是可行的，`VALUES IN (1,NULL,4,7)`、`VALUES IN (NULL,1,4,7)`等也同样有效。可以向ts2和ts3表中插入一行c1列带有NULL值的数据行：

```
mysql> INSERT INTO ts2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)

mysql> INSERT INTO ts3 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)
```

通过对INFORMATION_SCHEMA.PARTITIONS的查询，可以确定刚刚插入表中的数据行被存储在哪个分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME LIKE 'ts_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts1        | p0             |          0 |              0 |       16384 |
| ts1        | p1             |          0 |              0 |       16384 |
| ts1        | p2             |          0 |              0 |       16384 |
| ts2        | p0             |          0 |              0 |       16384 |
| ts2        | p1             |          0 |              0 |       16384 |
| ts2        | p2             |          0 |              0 |       16384 |
| ts2        | p3             |          1 |          16384 |       16384 |
| ts3        | p0             |          0 |              0 |       16384 |
| ts3        | p1             |          1 |          16384 |       16384 |
| ts3        | p2             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
10 rows in set (0.05 sec)
```

正如前面章节所示的那样，可以通过删除分区并使用`SELECT`语句来验证哪些分区用来存储数据行。

#### HASH分区和KEY分区处理NULL值

对于使用HASH分区和LIST分区的表，处理的NULL值的方法有所不同。在这些情况下，任何产生NULL值的分区表达式都将被视作其返回值为0。通过检测创建使用HASH分区的表和向其中填充包含适当值的记录的文件系统的影响可以验证这点。假设有一个表th使用如下语句创建：

```
mysql> CREATE TABLE th (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY HASH(c1)
    -> PARTITIONS 2;
Query OK, 0 rows affected (0.20 sec)
```

可是使用如下语句查询这个表的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.06 sec)
```

每个分区中的`TABLE_ROWS`列的值都是0。现在分别向th表中插入两条c1列的值为NULL和0的数据行，并且验证这两行数据都被插入到表中：

```
mysql> INSERT INTO th VALUES (NULL,'mothra'),(0,'gigan');
Query OK, 2 rows affected (0.05 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM th;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
|    0 | gigan  |
+------+--------+
2 rows in set (0.00 sec)
```

回想以下，对于任何整数N，`NULL MOD N`的值永远是NULL。对于使用HASH和KEY分区的表，将使用此结果来确定正确的分区应该是0。查看INFORMATION_SCHEMA.PARTITIONS表，可以看到两条数据都被插入到p0分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          2 |           8192 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
```

重复最后一个例子，但在定义表的语句中用`PARTITION BY KEY`代替`PARTITION BY HASH`，可以证明这种分区方式处理NULL值也如同处理0一样。













