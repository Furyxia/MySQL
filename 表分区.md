## 表分区类型

可以使用分区将单个表的各部分分散到一个文件系统中。用户所选择的划分数据的规划被称为分区函数（partitioning function），它可以是模量（modulu），与一组范围或值列表、一个内部哈希函数或一个线性哈希函数简单匹配。

表的不同行可以被分配给不同的物理分区，称为**水平分区**；在**垂直分区**中，表的不同列被分配给不同的物理分区，MySQL不支持垂直分区。

对一个表做分区有很多种方法：
* RANGE：这种类型的分区根据落在给定范围内的列值，将行分配给分区；
* LIST：类似于按RANGE分区，不同的是其分区是基于与一组离散值匹配的列来选择的；
* HASH：在这种类型的分区操作中，一个分区时根据用户定义的表达式返回来的值来选择的，该表达式对插入到表的行中的列值进行操作。HASH函数可以包含任何在MySQL中具有非负整数值的有效表达式；
* KEY：这种类型的分区类似于HASH分区，只是它仅提供一个或多个列，而且MySQL服务器提供自己的哈希函数。这些列可以包含除整数值意外的其他值，因为MySQL提供的哈希函数保证不管列数据是什么类型，结果都是整数；

---

#### 1.RANGE分区

**示例：**

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN (21)
);
```

在这个例子中，所有在1~5号商场工作的员工将被分到p0分区；在6~10号商场工作的员工将被分到p1分区，依次类推。但是当插入一条商场编号大于20的数据时将会抛出错误，因为这里并没有分区可以覆盖到编号大于20的商场。我们可以用一个“捕获所有”的方法来处理小于最大数值的情况：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN  MAXVALUE
);
```

其中，**MAXVALUE**是一个永远大于可能的最大整数值的整数。

这样，所有商场编号大于16的员工的数据将被分配到p3分区。若商场数量增加到较大的数值，我们可以使用ALTER TABLE语句为21~25，26~30等的商场编号分区。

同样的，我们也可以根据职位编号范围来分区。假设，两位数的职位编号是普通员工的编号，三位数的职位编号对应的是办公室和人事部门的员工，四位数的职位编号是管理层的编号，这样，我们可以根据上述划分分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
	PARTITION p0 VALUES LESS THAN (100),
	PARTITION p1 VALUES LESS THAN (1000),
	PARTITION p2 VALUES LESS THAN (10000)
);
```

如果不想根据商店数量来划分分区，也可以根据时间来作为划分依据。例如，我们希望根据每个员工的离职年份作为划分依据，则我们可以这样划分：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (YEAR(separated)) (
	PARTITION p0 VALUES LESS THAN (1991),
	PARTITION p1 VALUES LESS THAN (1996),
	PARTITION p2 VALUES LESS THAN (2001),
	PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

在这种划分方案中，所有在1991年之前离职的员工将被分配到p0分区中；在1991年到1995年之间离职的员工将被分配到p1分区中；在1996年到2000年之间离职的员工将被分配到p2分区中，在2001年之后离职的员工将被分配到p3分区。

也可以用UNIX_TIMESTAMP()函数，根据数据类型为时间戳的列的值来划分分区，如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY VALUE (UNIX_TIMESTAMP(report_updated)) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
	PARTITION p0 VALUES LESS THAN ( MAXVALUE )
)
```

RANGE分区在以下几种情况下会十分高效：
* 当你想要或者需要删除一些“旧”数据。如果你之前在表上应用了分区方案，你只需要使用`ALTER TABLE xxxx DROP PARTITION xx;`语句就可以简单地将某个分区中的所有数据都删除。当某个表中的数据量很大时，使用分区会比`DELETE`语句更加高效；
* 当你想要使用包含日期或时间戳或者来自其他值；
* 你经常查询依赖于作为表分区依据的列。例如，当执行查询语句`EXPLAIN SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND '2000-12-31' GROUP BY store_id;`，MySQL会快速确定只需要扫描p2分区，因为剩下的分区没办法满足`WHERE`后面的条件；

RANGE分区的一个变型是RANGE COLUMNS分区。

RANGE COLUMNS分区可以使用多个列值来确定分区的范围，该范围即可以适用分区中行的放置，也可以用于执行分区整理时确定包含或排除特定分区。

**基于时间间隔的分区方案**

如果想在MySQL8.0中应用基于时间范围或时间间隔的分区方案，你有两个选择方案：

**1.** 用RANGE分区方法对表进行分区，对于分区表达式，可以使用一个函数处理DATE，TIME或者DATETIME列并且返回一个整数数值，例如：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY VALUE ( YEAR(joined) ) (
	PARTITION p0 VALUES LESS THAN (1960),
	PARTITION p1 VALUES LESS THAN (1970),
	PARTITION p2 VALUES LESS THAN (1980),
	PARTITION p3 VALUES LESS THAN (1990),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

在MySQL8.0中，也可以使UNIX_TIMESTAMP()函数处理时间戳列按RANGE分区对表进行分区，例如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
);
```

**2.** 用RANGE COLUMNS对表进行分区，用DATE或DATETIME列作为分区列。例如，members表可以直接用joined列作为分区的依据，如下所示：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS (joined) (
	PARTITION p0 VALUES LESS THAN ('1960-01-01'),
	PARTITION p1 VALUES LESS THAN ('1970-01-01'),
	PARTITION p2 VALUES LESS THAN ('1980-01-01'),
	PARTITION p3 VALUES LESS THAN ('1990-01-01'),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

---

#### 2.LIST分区

MySQL中的LIST分区和RANGE分区在很多方面的很相似。与RANGE分区一样，必须明确定义每一个分区。LIST分区和RANGE分区最主要的不同就是，在LIST分区方法中，每一个分区是基于一组列表中的列值元素而不是一组连续范围内的值来定义和选择的。

这些由`PARTITION BY LIST(expr)`语句来定义，其中expr是一个列的值或者是一个基于列值并且返回一个整数数值的表达式。然后通过`VALUES IN (value_list)`定义每一个分区，其中value_list是用逗号分隔的整数列表。

#### 提示： 

在MySQL8.0中，使用LIST分区时可以只与一列整数（或者是NULL）匹配。但在LIST COLUMNS分区时，值列表中也可以使用其他的列值类型。

与通过范围定义分区的情况不同，列表分区不需要定义任何明确的顺序。

在下面的例子中，我们假设要被分区的表的基础定义由以下的`CREATE TABLE`语句提供：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
);
```

假设一共由有20家影音商店分布在如下4个专营权中：

|地区|商店编号|
|:---|:---|
|NORTH|3,5,6,9,17|
|EAST|1,2,10,11,19,20&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|WEST|4,12,13,14,18|
|CENTRAL&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|7,8,15,16|

为了能将属于同一地区的商店的数据行存储到相同的分区中，可以使用如下的`CREATE TABLE`语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY LIST(store_id) (
	PARTITION pNORTH VALUES IN (3,5,6,9,17),
	PARTITION pEAST VALUES IN (1,2,10,11,19,20),
	PARTITION pWEST VALUES IN (4,12,13,14,18),
	PARTITION pCENTRAL VALUES IN (7,8,15,16)
);
```

这样就可以很容易地添加或删除与特定地区相关的某个员工的纪录。例如，假设所有西部地区的商店都被出售给另外一个公司。在MySQL8.0中，所有与在那个地区的商店中工作的员工的数据行都可以用`ALTER TABLE employees TRUNCATE PARTITION pWEST`语句删除，这比使用相应的DELETE语句`DELETE FROM employees WHERE store_id IN (4,12,13,14,18);`更加高效。（使用`ALTER TABLE employees DROP PARTITION pWEST`语句不仅会删除所有的西部商场员工的数据行，还会从表定义中删除pWEST这个分区，你还需要使用` ALTER TABLE ... ADD PARTITION`声明恢复表原始分区方案。）

与RANGE分区相同，可以将LIST分区与哈希或键分区结合起来产生复合分区（子分区）。

与RANGE分区不同的是，LIST分区没有类似MAXVALUE的"catch-all"语句。所有的分区表达式的期望值必须包含在`PARTITION...VALUES IN (...)`语句中。

如果一个INSERT语句包含了一个未匹配的分区列值将会抛出一个错误，如下：

```
mysql> CREATE TABLE h2 (
    -> c1 INT,
    -> c2 INT
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (1,4,7),
    -> PARTITION p1 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.13 sec)

mysql> INSERT INTO h2 VALUES (3,5);
ERROR 1526 (HY000): Table has no partition for value 3
```

当使用INSERT语句向InnoDB表中一次性插入多条数据时，InnoDB引擎会认为这个语句是单个事务，因此当出现任何未能匹配到的值都会使得这个语句的执行完全失败，不会插入任何行。

可以通过使用IGNORE关键字忽略这类错误。若这样操作，包含未能匹配到分区的列值的行将不会被插入到表中，但是会插入正常匹配到分区的行到表中，并且不会报任何错误：

```
mysql> TRUNCATE h2;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT * FROM h2;
Empty set (0.01 sec)

mysql> INSERT IGNORE INTO h2 VALUES (2,5), (6,10), (7,5), (3,1), (1,9);
Query OK, 3 rows affected, 2 warnings (0.05 sec)
Records: 5  Duplicates: 2  Warnings: 2

mysql> SELECT * FROM h2;
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
```

MySQL8.0也支持LIST COLUMNS分区，一种允许使用整数类型以外的其他列的类型作为分区，并且使用多个列作为分区键的LIST分区。

---

#### 3.COLUMNS分区

COLUMNS分区可以使用多个列作为分区键。为了能将行放置在分区中以及确定在分区修整时为了匹配行哪些分区需要检查，所有这些列都会被纳入考虑的范围。

此外，RANGE COLUMNS分区和LIST COLUMNS分区都支持使用非整数列来定义值范围或列元素。允许使用的数据类型如下所示：
* 所有整数类型：TINYINT，SMALLINT，MEDIUMINT，INT(INTEGER)和BIGINT。（这与RANGE和LIST分区相同）；
* DATE和DATETIME，使用其他日期或时间相关的列不能作为分区列；
* 如下的字符串类型：CHAR，VARCHAR，BINARY和VARBINARY，TEXT和BLOB类型的列不能作为分区列；

#### 3.1 RANGE COLUMNS分区

RANGE COLUMNS分区与RNAGE分区相似，但是允许使用基于多个列值的范围定义分区。另外，可以使用非整数类型的列来定义范围。

RANGE COLUMNS分区与RANGE分区显著的差别如下：
* RANGE COLUMNS不接受表达式，只接受列名；
* RANGE COLUMNS接受一个或多个列的列表；RANGE COLUMNS分区是基于元组（列值列表）之间的比较，而不是标量之间的比较。行在RANGE COLUMNS分区中的放置位置也是基于元组之间的比较；
* RANGE COLUMNS分区列不限于整数列，字符串，DATE和DATETIME列也可以被用作分区列；

创建由RANGE COLUMNS分区的表的基本语法如下所示：

```
CREATE TABLE table_name
PARTITION BY RANGE COLUMNS(column_list) （
	PARTITION partition_name VALUES LESS THAN (value_list)[,
	PARTITION partition_name VALUES LESS THAN (value_list)][,...]
)

column_list:
	column_name[, column_name][,...]

value_list:
	value[,value][,...]
```

其中，column_list是包含一个或多个列的列表（有时也称为分区列列表），value_list是值列表（也即分区定义值列表）。

必须为每个分区定义提供一个value_list，而且每个value_list必须拥有与column_list中的列相同数量的值。也就是说，假如在COLUMNS子句中使用N个列，那么VALUES LESS THAN子句中必须提供一个有N个值的列表。

分区定义中列表中的元素与值列表中的值顺序必须相同。另外，值列表中的每个元素必须与分区列列表中相应的拥有相同的数据类型。

但是，分区列列表中列名和值列表的顺序并不一定要与定义表的`CREATE TABLE`语句中的顺序相同。与按照RANGE分区的表相同，我们可以使用MAXVALUE代表一个使得所有插入到给定行的和合法值永远小于MAXVALUE的值。如：

```
mysql> CREATE TABLE rcx (
    -> a INT,
    -> b INT,
    -> c CHAR(3),
    -> d INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,d,c) (
    -> PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    -> PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
    -> PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
Query OK, 0 rows affected (0.14 sec)
```

rcx表包含了a，b，c，d列。提供给COLUMNS的分区列列表中使用了其中的3个值，顺序为a，d，c。每个用于定义分区的值列表也包含了这3个值，且顺序相同。也就是，每个值列表元组的形式都是(INT,INT,CHAR(3))，对应a，d，c列使用的数据类型（按此顺序）。

通过比较要被插入的行的满足COLUMNS子句中列列表匹配的元组与在`VALUES LESS THAN`子句中使用的用于定义表分组的元组来确定行在分区中的放置位置。因为我们是通过比较元组（也即是，列或者值的集合）而不是标量，RANGE COLUMNS分区中使用的`VALUES LESS THAN `语义与简单RANGE分区的情况有所不同。

在RANGE分区中，一行生成的等于VALUES LESS THAN的限制值的表达值永远不会被放到相应的分区中；然而，当使用RANGE COLUMNS分区时，有可能会将分区列列表中的第一个元素与VALUES LESS THAN值列表中的第一个元素相等的行放置到相应的分区中。

如果以下声明创建了RANGE分区表：

```
CREATE TABLE r1 (
	a INT,
	b INT
)
PARTITION BY RANGE (a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果向表中插入3行数据，每条数据中a的值都是5，所有的数据都会被放置到p1分区，因为3条数据行的a列值都不小于5。我们可以通过对INFORMATION_SCHEMA.PARTITIONS表执行适当的查询来查看分区：

```
mysql> INSERT INTO r1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='r1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```
现在考虑一个相似的表rc1，这个表使用了RANGE COLUMNS分区，在COLUMNS子句中引用了列a和b，创建语句为：

```
CREATE TABLE rc1 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (5,12),
	PARTITION p1 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

如果我们向rc1表中插入与r1表完全相同的数据，结果将会有所不同：

```
mysql> INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rc1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          2 |
| p1             |          1 |
+----------------+------------+
```

这是因为我们比较的是行而不是标量。我们可以将插入的行值与VALUES LESS THAN子句中用来限制rc1表中分区p0的行值进行比较，如：

```
mysql> SELECT (5,10)<(5,12),(5,11)<(5,12),(5,12)<(5,12);
+---------------+---------------+---------------+
| (5,10)<(5,12) | (5,11)<(5,12) | (5,12)<(5,12) |
+---------------+---------------+---------------+
|             1 |             1 |             0 |
+---------------+---------------+---------------+
```

(5,10)和(5,11)这两个元组比(5,12)小，所以它们被存放在分区p0中。又因为5不小于5，12不小于12，所以(5,12)被认为不小于(5,12)，因此被放置在分区p1中。

上面例子中的SELECT语句也可以使用显示行构造函数编写，如：

```
SELECT ROW(5,10)<ROW(5,12),ROW(5,11)<ROW(5,12),ROW(5,12)<ROW(5,12);
```

对于一个仅使用一个分区列的RANGE COLUMNS分区的表，分区中行的存储与由RANGE分区的等效表相同。如：

```
CREATE TABLE rx (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS(a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果我们向表中插入行(5,10)，(5,11)和(5,12)，可以看到它们的存放方式与表r1中的存放方式时相同的：

```
mysql> INSERT INTO rx VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rx';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```

也可以创建由RANGE COLUMNS分区的表，其中在连续的分区定义中重复一个或多个列的限制值。只要是用于定义分区的列值是严格递增的，就可以执行此操作。例如，以下的每个CREATE TABLE语句都是有效的：

```
CREATE TABLE rc2 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);

CREATE TABLE rc3 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p2 VALUES LESS THAN (10,35),
	PARTITION p2 VALUES LESS THAN (20,40),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

以下的声明语句也能成功，即使第一眼看到可能会认为它不能成功执行因为p0分区的b列的限制值是25，p1分区的限制值是20，p1分区的c列限制值是100而p2分区的限制值是50：

```
CREATE TABLE rc4 (
	a INT,
	b INT,
 	c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
	PARTITION p0 VALUES LESS THAN (0,25,50),
	PARTITION p1 VALUES LESS THAN (10,20,100),
	PARTITION p2 VALUES LESS THAN (10,30,50),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
```

当设计以RANGE COLUMNS分区的表，你始终可以使用mysql客户端比较所需的元组来测试连续的分区定义，就像：

```
mysql> SELECT (0,25,50)<(10,20,100),(10,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(10,20,100) | (10,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      1 |
+-----------------------+------------------------+
```

如果CREATE TABLE语句中包含的分区定义顺序不是严格递增，将失败并抛出错误，如：

```
mysql> CREATE TABLE rcf (
    -> a INT,
    -> b INT,
    -> c INT
    -> )
    -> PARTITION BY RANGE COLUMNS (a,b,c) (
    -> PARTITION p0 VALUES LESS THAN (0,25,50),
    -> PARTITION p1 VALUES LESS THAN (20,20,100),
    -> PARTITION p2 VALUES LESS THAN (10,30,50),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
```

若看到此类错误，可以通过在列列表中进行“小于”比较推断哪些分区定义语句是无效的。在上面情况下，问题在于p2分区的定义，因为用于定义的元组并不小于用于定义p3分区的元组：

```
mysql> SELECT (0,25,50)<(20,20,100), (20,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(20,20,100) | (20,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      0 |
+-----------------------+------------------------+
```

使用RANGE COLUMNS分区时，MAXVALUE可以多次出现在VALUES LESS THAN子句的同一列中。然而，连续分区定义中各个列的限制值也应该时增加的，在MAXVALUE被作为上限的所有列中不应该定义多个分区，且这种分区应该出现在`PARTITION ... VALUES LESS THAN`子句列的最后。此外，不能使用MAXVALUE作为多个分区定义第一列的限制值。

正如前面所说，可以在RANGE COLUMNS分区中使用非整数列作为分区列。

例如，使用RANGE COLUMNS分区时，可以创建一个可以根据员工的姓氏将每一行存储在四分区中之一的表：

```
COLUMNS TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

可以通过执行如下ALTER TABLE语句使用此方案修改已经创建的employee表的分区：

```
ALTER TABLE employee PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

同样的，你也可以用`ALTER TABLE`语句将employee表基于员工的雇佣年代将数据存放在不同的分区中，语法如下：

```
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired) (
	PARTITION p0 VALUES LESS THAN ('1970-01-01'),
	PARTITION p1 VALUES LESS THAN ('1980-01-01'),
	PARTITION p2 VALUES LESS THAN ('1990-01-01'),
	PARTITION p3 VALUES LESS THAN ('2000-01-01'),
	PARTITION p4 VALUES LESS THAN ('2010-01-01'),
	PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
```

<br>

#### 3.2 LIST COLUMNS分区

MySQL8.0支持LIST COLUMNS分区。这是一种LIST分区的变型，允许使用多个列作为分区键并且支持非整数类型的作为分区列，可以使用DATE和DATETIME列。

假设你的业务在12个城市拥有客户，出于销售或者市场营销的目的，你将它们分在为4个区域，每个区域有3个城市，如下表所示：

|Region&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|Cities|
|:---|:---|
|1|Oskarshamn,Högsby,Mönsterås|
|2|Vimmerby,Hultsfred,Västervik&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|3|Nässjö,Eksjö,Vetlanda|
|4|Uppvidinge,Alvesta,Växjo|

当用LIST COLUMNS分区时，你可以创建一个客户数据表，该表依据客户所在城市的名称将客户数据行分配给这四个区域中匹配的其中一个区域，如下所示：

```
CREATE TABLE customers_1 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
	PARTITION pRegion_1 VALUES IN ('Oskarshamn','Högsby','Mönsterås'),
	PARTITION pRegion_2 VALUES IN ('Vimmerby','Hultsfred','Västervik'),
	PARTITION pRegion_3 VALUES IN ('Nässjö','Eksjö','Vetlanda'),
	PARTITION pRegion_4 VALUES IN ('Uppvidinge','Alvesta','Växjo')
);
```

就像RANGE COLUMNS分区一样，你不需要在COLUMNS()子句中使用表达式将列值转化成为整数。（实际上，COLUMNS()不允许使用除列名之外的其他表达式）。

也可以使用DATE和DATETIME列，在下面的例子中使用与之前customers_1表一样的列和名称，但使用基于renewal列的LIST COLUMNS分区将行存储在4个分区中的其中一个，具体取决于客户账户在2010年2月第几周更新：

```
CREATE TABLE customers_2 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES IN ('2010-02-01','2010-02-02','2010-02-03','2010-02-04','2010-02-05','2010-02-06','2010-02-07'),
	PARTITION pWeek_2 VALUES IN ('2010-02-08','2010-02-09','2010-02-10','2010-02-11','2010-02-12','2010-02-13','2010-02-14'),
	PARTITION pWeek_3 VALUES IN ('2010-02-15','2010-02-16','2010-02-17,'2010-02-18','2010-02-19','2010-02-20','2010-02-21'),
	PARTITION pWeek_4 VALUES IN ('2010-02-22','2010-02-23','2010-02-24','2010-02-25','2010-02-26','2010-02-27','2010-02-28')
);
```

这是可行的，但是如果日期数量增加到很大的数值，则定义和维护这个表会变得很麻烦。这种情况下，更常用的是用RANGE或者RANGE COLUMNS分区方法。在上述例子中，由于希望用作分区键的是DATE列，所以使用RANGE COLUMNS分区方法，如下所示：

```
CREATE TABLE customers_3 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES LESS THAN ('2010-02-08'),
	PARTITION pWeek_2 VALUES LESS THAN ('2010-02-15'),
	PARTITION pWeek_3 VALUES LESS THAN ('2010-02-22'),
	PARTITION pWeek_4 VALUES LESS THAN ('2010-03-01')
);
```

另外，与RANGE COLUMNS分区相同，也可以在COLUMNS()子句中使用多个列。

---

#### 4.HASH分区

用HASH分区主要是为了确保在预定数量之间的分区能够使分数据均匀分布。对于RANGE和LIST分区，我们必须明确指定将给定某个列值或某组列值应该存放在哪个分区中，这个由我们决定，我们仅需要确定列值或基于要散列的列值以及要将划分的分区数的表达式。

使用HASH分区划分表，必须在CREATE TABLE语句后面添加一个PARTITION BY HASH(expr)子句，其中expr使一个能返回整数的表达式。这可以只是列的名，该列的类型是MySQL整数类型中的一种。

另外，你可能很希望在此之后增加一个PARTITIONS num，其中num是代表这个表将被划分为的分区数的正整数。

#### 提示：

为简单起见，下面例子中的表并没有使用任何键。你应该意识到，如果表中拥有唯一键，被用于这个表分区表达式中的每一列都必须是这些唯一键的一部分，包括主键。

下面创建一个在store_id列上使用哈希表的语句将表分成了4个分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(store_id)
PARTITION 4;
```

如果没有包含PARTITION子句，分区的数量将默认是1；使用PARTITION关键字但后面没带数字将出现语法错误。

你也可以使用一个返回整数的SQL表达式expr。例如，你想根据雇佣员工的年份进行分区。可用如下语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(YEAR(hired))
PARTITION 4;
```

其中，expr必须返回一个非恒定，非随机的整数值（也就是说，它应该是变化但是确定的），并且不得包含第6节中“分区的限制”中提到的任何禁止构造。你应该记住，每次插入或更新（或者删除）一行数据时，都会求这个表达式的值，这意味着过于复杂的表达式可能会造成性能问题，特别是在执行能一次性影响很多行数据的操作时（例如批量插入时）。

最高效的散列函数是对单个表的列进行操作的函数，其值与列值一致的增大或减小，因为这允许对分区范围进行“裁剪”。这也就是，表达式随着其所基于的列值的变化越紧密，MySQL越能高效地使用该表达式进行哈希分区。

例如，date_col是类型为DATE的列，则表达式`TO_DAYS(date_col)`随着date_col值的变化而变化，因为对于date_col值的每次更改，表达式的值也相应的做更改。表达式`YEAR(date_col)`相对于date_col的变动相对于`TO_DAYS(date_col)`对于date_col的变动并不是那么直接，因为并不是所有date_col的变动都会使`YEAR(date_col)`产生同样的改变。即便如此，`YEAR(date_col)`也是散列函数的理想选择，因为它能随着date_col的一部分变化而直接变化，并且date_col中的改变不可能在`YEAR(date_col)`中产生不成比例的变化。

相比之下，假如有一个名为int_col的列，数据类型为INT。考虑表达式`POW(5-int_col,3)+6`。这并不是散列方程的理想对象，因为int_col值的改变并不能保证表达式的值能做出相应的变化。用一个给定的数值改变int_col的值可能使得表达式的值产生很大的差别。例如，将int_col的值从5变为6，表达式的值会改变-1，但当int_col的值从6变为7时，表达式的值将改变-7-。

也就是说，列值与表达式值的曲线越接近方程`y=cx`（其中c时一个非零常数）所描绘的直线，表达式更适合作为哈希函数。这与以下事实有关，表达式越是非线性的，它所产生的数据在分区中的分布越不均匀。

理论上讲，也可以对包含多个列值的表达式进行修剪，但是确定哪个表达式更适合可能非常困难且耗时。因此，使用包含多个列的散列表达式并不是十分推荐。

当使用哈希分区时，存储引擎会依据表达式结果的模数来确定要使用num个分区中的哪个分区。也就是说，对于一个给定的表达式expr，记录被存储的分区号为N，其中`N=MOD(expr,num)`。假设表t1被如下语句定义，因此它有4个分区：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY HASH (YEAR(col3))
PARTITION 4;
```

如果向表t1中插入一条col3值为'2005-09-15'的记录，则它被存放的分区取决于以下函数：

```
 MOD(YEAR('2005-09-15'),4)
=MOD(2005,4)
=1
```

MySQL8.0还支持HASH分区一个变型，也就是linear hashing，它采用了更加复杂的算法以确定插入表中的新行应该被存储到哪个分区中。

每次插入或更新一条记录时，都会评估用户提供的表达式。当删除记录时，还可能依据情况对其进行评估。

#### 4.1 LINEAR HASH分区

MySQL也支持线性散列，与常规散列不同的是线性散列采用了线性二乘幂算法而普通散列使用散列函数值的模数。

从语法上讲，线性散列分区与普通散列分区唯一的不同之处仅是在`PARTITION BY`子句中增加了LINEAR关键字，如下所示：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	stored_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITION 4;
```

给定一个表达式expr，使用线性散列时存储记录的分区是num个分区中的N分区号，其中N是根据以下算法产生的：

1. 查找下一个比num大的2的幂值，我们称之为V，它可以由如下计算产生：

	```
	V = POWER(2,CEILING(LOG(2,num)))
	```
	（假设num的值是13，则`LOG(2,13)`的值是3.7004，`CEILING(3.7004)`的值是4，所以`V = POWER(2,4)`是16。）

2. 令`N = F(column_list)&(V-1)`；
3. 当N≥num：
	* 令`V = V/2`；
	* 令`N = N&(V-1)`

假设有表t1，该表使用线性散列分区并拥有6个分区，其创建语句为：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR HASH( YEAR(col3) )
PARTITION 6;
```

假设现在要插入两条记录到t1表中，且两条记录的col3列的值分别为'2003-04-14'和'1998-10-19'。第一条记录的分区号由如下语句定义：

```
V = POWER(2,CEILING(LOG(2,6))) = 8
N = YEAR('2003-04-14') & (8-1)
  = 2003 & 7 (位与运算)
  = 3

(3≥6为假，因此该条记录被分配到3号分区)
```

第二条记录的分区号由下面语句确定：

```
V = 8
N = YEAR('1998-10-19') & (8-1)
  = 1998 & 7
  = 6

(6≥6为真，需要进一步计算)

N = 6 & ((8/2)-1)
  = 6 & 3
  = 2

(2≥6为假，因此该条记录被分配到2号分区)
```

线性散列进行分区的优势在于添加、删除、合并和拆分分区更加快捷，这在于处理存储了极其庞大的数据的表时十分有用。缺点在于，比起常规散列分区，线性散列分区的数据在分区中的分布并不是那么均匀。

----

#### 5.KEY分区

键分区与哈希分区相似，除了哈希分区使用了用户自定义的表达式之外，键分区的散列函数是由MySQL服务器提供的。

`CREATE TABLE ... PARTITION BY KEY`的 语法规则与创建采用哈希分区的表的语法规则相似。最主要的区别是：
* 采用的是KEY而不是HASH；
* KEY只接受零个或多个列名的列表。如表含有一个主键，则任何作为分区键的列都必须包含部分或全部表的主键。如果没有任何指定任何列名作为分区键，则默认使用表的主键（如果含有主键）。下面的`CREATE TABLE`语句在MySQL8.0中是有效的：

	```
	CREATE TABLE k1 (
		id INT NOT NULL PRIMARY KEY,
		name VARCHAR(20)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```
	如果没有主键但拥有一个唯一键，则唯一键将被用作分区键：

	```
	CREATE TABLE k1 (
		id INT NOT NULL,
		name VARCHAR(20),
		UNIQUE KEY (id)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```

	然而，若唯一键列没有被定义为`NOT NULL`，则前面例子中的语句将执行失败。

在这两种情况下，分区键都是id列，即使没有在`SHOW CREATE TABLE`或者在`INFORMATION_SCHEMA.PARTITIONS`表的`PARTITION_EXPRESSION`列中显示出来。

不像其他分区类型，KEY分区使用的列并没有严格限制只能是整数或NULL值。例如，下面的`CREATE TABLE`语句是可行的：

```
CREATE TABLE tm1 (
	s1 CHAR(32) PRIMARY KEY
)
PARITION BY KEY(s1)
PARITION 10;
```

若指定其他分区类型，上述例子中的语句将是无效的。（在这种请款下，只使用`PARTITION BY KEY()`也是可行的，与使用`PARTITION BY KEY(s1)`效果一样，因为s1是表的主键。）

#### 重要：

对于一个使用键分区的表，不能执行`ALTER TABLE DROP PRIMARY KEY`，如果这样做会产生错误：`ERROR 1466 (HY000): Field in list of fields for partition function not found in table.`

也可以使用线性键对表进行分区。如下所示：

```
CREATE TABLE tk (
	col1 INT NOT NULL,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR KEY(col1)
PARTITION 3;
```

LINEAR关键字对KEY分区的作用与对HASH分区的作用一样，使用二乘幂算法而不是取模运算产生分区号。

---

#### 6.细分

细分，也成为复合分区，是对分区表中每个表的进一步划分。考虑如下`CREATE TABLE`语句：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased))
SUBPARTITION 2 (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

表ts有3个RANGE分区。p0，p1和p2分区都被进一步划分为2个子分区。实际上，整个表被划分成`3*2=6`个分区。然而，因为`PARTITION BY RANGE`子句的作用，其中的前两个值只存储那些purchased列的值小于1990的记录。

可以通过对使用RANGE或LIST分区的表进行细分。子分区可以使用HASH或KEY分区。这也就是复合分区。

#### 注意：

`SUBPARTITION BY HASH`和`SUBPARTITION BY KEY`通常分别遵循`PARTITION BY HASH`和`PARTITION BY KEY`的语法规则。唯一的区别就是`SUBPARTITION BY KEY`（不像`PARTITION BY KEY`）并不支持默认列，因此，即使表拥有显示的主键，也必须指定用于此语法的列。

可以是使用`SUBPARTITION`子句来明确定义子分区，以指定每个子分区的选项。例如，创建前面例子中的ts表的更加冗长的方式为：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased)) (
	PARTITION p0 VALUES LESS THAN (1990) (
		SUBPARTITION s0,
		SUBPARTITION s1
	),
	PARTITION p1 VALUES LESS THAN (2000) (
		SUBPARTITION s2,
		SUBPARTITION s3
	),
	PARTITION p2 VALUES LESS THAN MAXVALUE (
		SUBPARTITION s4,
		SUBPARTITION s5
	)
);
```

这里列出了一些语法上的注意事项：
* 每个分区都应拥有相同数量的子分区；
* 如果在一个分区表中明使用`SUBPARTITION`确定义了任何子分区，必须完整地定义它们。否则将失败：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s2,
			SUBPARTITION s3
		)
	);
	```
	如果使用到SUBPARTITIONS 2将会出错；
* 每个`SUBPARTITION`子句必须包含（至少）一个子分区的名称。否则，你可以为子分区设置任何所需的选项或者允许其采用该选项的默认设置；
* 子分区的名称在整个表中应该是唯一的。如下的`CREATE TABLE`语法是有效的：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000) (
			SUBPARTITION s2,
			SUBPARTITION s3
		),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s4,
			SUBPARTITION s5
		)
	);
	```

---

#### 7.MySQL分区如何处理NULL值

MySQL中的分区允许NULL作为分区表达式的值，不论它是列值还是用户提供的表达式的值。虽然允许使用NULL值作为其他必须产生整数的表达式的值，也必须记住NULL不是一个数字。MySQL的分区实现将NULL视为小于任何非NULL值的值，就如`ORDER BY`一样。

这意味着对NULL的处理随着分区类型的不同而变化，而且可能产生意想不到的结果。在这种情况下，我们将在本节中讨论在确定应存储行的分区时每种MySQL分区类型如何处理NULL值，并提供每种示例。


#### RANGE分区处理NULL值

如果向一个由RANGE分区的表中插入一行数据，其中决定分区的列值是NULL，则这行数据将被插入到最低的分区中。考虑以下两个在p数据库中的表：

```
mysql> CREATE TABLE t1
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (0),
    -> PARTITION p1 VALUES LESS THAN (10),
    -> PARTITION p2 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.40 sec)

mysql> CREATE TABLE t2
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (-5),
    -> PARTITION p1 VALUES LESS THAN (0),
    -> PARTITION p2 VALUES LESS THAN (10),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.31 sec)
```

可以使用如下查询语句查询INFORMATION_SCHEMA数据库中的PARTITIONS表，查看上述两`CREATE TABLE`语句创建的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          0 |              0 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.09 sec)
```

现在，向每个表中填充一行被用作分区键的列中带有NULL的数据，并使用`SELECT`语句验证数据行已被插入到表中：

```
mysql> INSERT INTO t1 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> INSERT INTO t2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> SELECT * FROM t1;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
```

可以通过前面查询INORMATIONS_SCHEMA.PARTITIONS表的语句查看那个分区被用来存储被插入的数据行：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          1 |          16384 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          1 |          16384 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
```

你也可以通过删除最低的分区以证明这两行数据都被存放在这些分区中，并重新执行`SELECT`语句：

```
mysql> ALTER TABLE t1 DROP PARTITION p0;
Query OK, 0 rows affected (0.14 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE t2 DROP PARTITION p0;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM t1;
Empty set (0.05 sec)

mysql> SELECT * FROM t2;
Empty set (0.05 sec)
```

使用SQL函数的分区表达式也这样处理NULL值。假设我们使用如下的`CREATE TABLE`语句定义一个表：

```
CREATE TABLE tndate (
	id INT,
	dt DATE
)
PARTITION BY RANGE(YEAR(dt)) (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

正如其他的MySQL函数，`YEAR(NULL)`返回NULL值。一行dt列值为NULL的数据被分区表达式认为是一个小于任何其他值的方式处理，因此这行数据被插入p0分区。

#### LIST分区处理NULL值

当且仅当分区定义中使用了包含NULL值的列表时，使用LIST分区的表才允许有NULL值。相反的，当一个使用LIST分区的表没有在值列表里明确使用了NULL值时，它将拒绝在分区表达式中会产生NULL值的数据行。例如：

```
mysql> CREATE TABLE ts1 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.25 sec)

mysql> INSERT INTO ts1 VALUES (9,'mothra');
ERROR 1526 (HY000): Table has no partition for value 9

mysql> INSERT INTO ts1 VALUES (NULL,'mothra');
ERROR 1526 (HY000): Table has no partition for value NULL
```

只有c1列的值在0到8之间的数据行可以被插入到表中ts1中。NULL在这个范围之外，就像数字9一样。我们可以创建值列表中包含NULL值的ts2和ts3表：

```
mysql> CREATE TABLE ts2 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8),
    -> PARTITION p3 VALUES IN (NULL)
    -> );
Query OK, 0 rows affected (0.23 sec)

mysql> CREATE TABLE ts3 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7,NULL),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.27 sec)
```

当定义分区列值时，可以（也应该）像处理其他值一样处理NULL值。例如，`VALUES IN (NULL)`和`VALUES IN (1,4,7,NULL)`是可行的，`VALUES IN (1,NULL,4,7)`、`VALUES IN (NULL,1,4,7)`等也同样有效。可以向ts2和ts3表中插入一行c1列带有NULL值的数据行：

```
mysql> INSERT INTO ts2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)

mysql> INSERT INTO ts3 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)
```

通过对INFORMATION_SCHEMA.PARTITIONS的查询，可以确定刚刚插入表中的数据行被存储在哪个分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME LIKE 'ts_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts1        | p0             |          0 |              0 |       16384 |
| ts1        | p1             |          0 |              0 |       16384 |
| ts1        | p2             |          0 |              0 |       16384 |
| ts2        | p0             |          0 |              0 |       16384 |
| ts2        | p1             |          0 |              0 |       16384 |
| ts2        | p2             |          0 |              0 |       16384 |
| ts2        | p3             |          1 |          16384 |       16384 |
| ts3        | p0             |          0 |              0 |       16384 |
| ts3        | p1             |          1 |          16384 |       16384 |
| ts3        | p2             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
10 rows in set (0.05 sec)
```

正如前面章节所示的那样，可以通过删除分区并使用`SELECT`语句来验证哪些分区用来存储数据行。

#### HASH分区和KEY分区处理NULL值

对于使用HASH分区和LIST分区的表，处理的NULL值的方法有所不同。在这些情况下，任何产生NULL值的分区表达式都将被视作其返回值为0。通过检测创建使用HASH分区的表和向其中填充包含适当值的记录的文件系统的影响可以验证这点。假设有一个表th使用如下语句创建：

```
mysql> CREATE TABLE th (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY HASH(c1)
    -> PARTITIONS 2;
Query OK, 0 rows affected (0.20 sec)
```

可是使用如下语句查询这个表的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.06 sec)
```

每个分区中的`TABLE_ROWS`列的值都是0。现在分别向th表中插入两条c1列的值为NULL和0的数据行，并且验证这两行数据都被插入到表中：

```
mysql> INSERT INTO th VALUES (NULL,'mothra'),(0,'gigan');
Query OK, 2 rows affected (0.05 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM th;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
|    0 | gigan  |
+------+--------+
2 rows in set (0.00 sec)
```

回想以下，对于任何整数N，`NULL MOD N`的值永远是NULL。对于使用HASH和KEY分区的表，将使用此结果来确定正确的分区应该是0。查看INFORMATION_SCHEMA.PARTITIONS表，可以看到两条数据都被插入到p0分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          2 |           8192 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
```

重复最后一个例子，但在定义表的语句中用`PARTITION BY KEY`代替`PARTITION BY HASH`，可以证明这种分区方式处理NULL值也如同处理0一样。

---

## 分区管理

使用SQL语句来修改分区表的方法有很多种，可以使用`ALTER TABLE`语句扩展来新增，删除，重定义，合并或者拆分已有的分区。还有一些方法可以获取分区表和分区信息。

#### 注意：

所有分区表的分区都必须拥有相同数量的子分区，一旦表创建之后就不能修改子分区。

更改表分区的方案，只需要使用带有`partition_options`选项的`ALTER TABLE`的语句，此语句与创建分区表的`CREATE TABLE`的语法一样；选项（也）通常以关键字`PARTITION BY`开头。假设下面如下的`CREATE TABLE`语句用于创建一个使用range分区的表：

```
CREATE TABLE trb3 (
	id INT,
	name VARCHAR(50),
	purchases DATE
)
PARTITION BY RANGE(YEAR(purchased)) (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (1995),
	PARTITION p2 VALUES LESS THAN (2000),
	PARTITION p3 VALUES LESS THAN (2005)
);
```

对此表重新分区，以便通过使用id列值作为基的础键将表分为两个分区，可以使用如下语句：

```
ALTER TABLE tb3 PARTITION BY KEY(id) PARTITIONS 2;
```

这对表结构的影响如同使用如下语句删除表然后重新创建一样：

```
CRAETE TABLE tb3 PARTITION BY KEY(id) PARTITIONS 2;
```

`ALTER TABLE ... ENGINE = ...`仅仅改变表使用的存储引擎但完整地保留了表的分区方案。这个语句只有在目标存储引擎提供分区支持时才能成功。你也可以使用`ALTER TABLE ... REMOVE PARTITIONING`移除表分区。

#### 重要：

在给定的`ALTER TABLE`语句中，仅能使用一个`PARTITION BY`，`ADD PARTITION`，`DROP PARTITION`，`REORGANIZE PARTITION`或`COALESCE PARTITION`子句。例如你想删除一个分区并且重新组织表剩余的分区，你必须在两条单读的`ALTER TABLE`语句中（其中一条语句使用`DROP PARTITION`，第二条语句使用`REORGANIZE PARTITION`）。

你可以使用`ALTER TABLE ... TRUNCATE PARTITION`语句一次性删除一个或者多个选中的分区。

### 1.管理RANGE和LIST分区

添加或者删除RANGE和LIST分区的操作相似，本章中将讨论两种分区的管理。

从由RANGE或者LIST分区的表中删除分区可以由带`DROP PARTITIION`选项的`ALTER TABLE`语句完成。假设你使用下面的`CREATE TABLE`和`INSERT`语句创建了一个RANGE分区的表并且填充了10条数据：

```
mysql> CREATE TABLE tr (
    -> id INT,
    -> name VARCHAR(50),
    -> purchased DATE
    -> )
    -> PARTITION BY RANGE (YEAR(purchased)) (
    -> PARTITION p0 VALUES LESS THAN (1990),
    -> PARTITION p1 VALUES LESS THAN (1995),
    -> PARTITION p2 VALUES LESS THAN (2000),
    -> PARTITION p3 VALUES LESS THAN (2005),
    -> PARTITION p4 VALUES LESS THAN (2010),
    -> PARTITION p5 VALUES LESS THAN (2015)
    -> );
Query OK, 0 rows affected (0.31 sec)

mysql> INSERT INTO tr VALUES
    -> (1,'desk organiser','2003-10-15'),
    -> (2,'alarm clock','1997-11-05'),
    -> (3,'chair','2009-03-10'),
    -> (4,'bookcase','1989-01-10'),
    -> (5,'exercise bike','2014-05-09'),
    -> (6,'sofa','1987-06-05'),
    -> (7,'espresso maker','2011-11-22'),
    -> (8,'aquarium','1992-08-04'),
    -> (9,'study desk','2006-09-16'),
    -> (10,'lava lamp','1998-12-25');
Query OK, 10 rows affected (0.06 sec)
Records: 10  Duplicates: 0  Warnings: 0
```

可以看到应该被插入到p2分区的记录如下所示：

```
mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.05 sec)
```

也可以通过使用分区查询得到这些信息：

```
mysql> SELECT * FROM tr PARTITION (p2);
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.00 sec)
```

通过执行如下命令可以删除名为p2的分区：

```
mysql> ALTER TABLE tr DROP PARTITION p2;
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

#### 注意：

NDBCLUSTER存储引擎并不支持`ALTER TABLE ... DROP PARTITION`。然而，它支持这一节中介绍的其他分区相关的`ALTER TABLE`扩展。

需要记住，当删除分区时同时也删除了此分区存储的所有的数据。重新运行之前的`SELECT`查询，可以看到这种情况：

```
mysql> SELECT * FROM tr
    -> WHERE purchased
    -> BETWEEN '1995-01-01' AND '1999-12-31';
Empty set (0.00 sec)
```

#### 注意：

本地分区的API支持`DROP PARTITION`，并且可能与`ALGORITHM={COPY|INPLACE}`一起使用。使用`ALGORITHM=INPLACE`的`DROP PARTITION`会删除分区中存储的数据和删除分区。然而，使用`ALGORITHM=COPY`的`DROP PARTITION`会重新建立分区表，并尝试用一个兼容的`PARTITION ... VALUES`的定义将数据从被删除的分区移动到另外一个分区中。不能移动到另外一个分区的数据将被删除。

正因如此，你在对数据表执行`ALTER TABLE ... DROP PARTITION`前应该首先拥有对该表的`DROP`权限。

如果想要从所有分区中删除所有数据但是保留表的定义和分区方案，使用`TRUNCATE TABLE`语句。

如果你想要改变表的分区同时不丢失数据，可以使用`ALTER TABLE ... REORGANIZE PARTITION`。

如果执行`SHOW CREATE TABLE`语句，可以看到组成表的分区是如何改变的：

```
mysql> SHOW CREATE TABLE tr \G;
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`purchased`))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (2010) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN (2015) ENGINE = InnoDB) */
1 row in set (0.06 sec)
```

当向已经改变的表中插入新的数据，这些数据的purchased列的值在'1995-01-01'和'2004-12-31'时，这些数据会被放在p3分区中。你可以使用以下语句中证明：

```
mysql> INSERT INTO tr VALUES (11,'pencil holder','1995-07-12');
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
+------+---------------+------------+
| id   | name          | purchased  |
+------+---------------+------------+
|   11 | pencil holder | 1995-07-12 |
+------+---------------+------------+
1 row in set (0.00 sec)

mysql> ALTER TABLE tr DROP PARTITION p3;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
Empty set (0.00 sec)
```

服务器不会像等效的DELETE查询语句那样报告由于`ALTER TABLE ... DROP PARTITION`而从表中删除的行数。

删除LIST分区使用与删除RANGE分区完全一样的`ALTER TABLE ... DROP PARTITION`语法。然而，对于以后使用数据表的影响有一点不同的是：无法再将已被删除的分区定义的数据列表包含的数据插入到数据表中。

使用`ALTER TABLE ... ADD PARTITION`可以在之前已经分好区的表中新增一个范围分区或列分区。对于使用RANGE分区的表，也可以在已经存在的分区列表后面添加一个范围。假设你有一个已经分区好的表，里面包含了你的社团的成员信息：

```
mysql> CREATE TABLE members (
    -> id INT,
    -> fname VARCHAR(25),
    -> lname VARCHAR(25),
    -> dob DATE
    -> )
    -> PARTITION BY RANGE(YEAR(dob)) (
    -> PARTITION p0 VALUES LESS THAN (1980),
    -> PARTITION p1 VALUES LESS THAN (1990),
    -> PARTITION p2 VALUES LESS THAN (2000)
    -> );
Query OK, 0 rows affected (0.10 sec)
```

进一步假设，最小成员的年龄是16岁。到2015年年底时，你意识到很快你将接收2000年（或之后）出生的成员。可以使用以下语句修改表members以适应在2000年至2010年间出生的新成员：

```
mysql> ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2010));
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

对于范围分区的数据表，你只用使用`ADD PARTITION`语句在高的一端分区列表添加分区。尝试向在已存在的分区之间或之前添加新的分区将产生错误：

```
mysql> ALTER TABLE members
    -> ADD PARTITION (
    -> PARTITION n VALUES LESS THAN (1970));
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly »   increasing for each partition
```

你可以通过将第一个分区拆分成两个分区（将它们之间的范围划分开）来解决这个问题：

```
mysql> ALTER TABLE members
    -> REORGANIZE PARTITION p0 INTO (
    -> PARTITION n0 VALUES LESS THAN (1970),
    -> PARTITION n1 VALUES LESS THAN (1980)
    -> );
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

使用`SHOW CREATE TABLE`可以查看`ALTER TABLE`语句已经产生了期望的效果：

```
mysql> SHOW CREATE TABLE members \G;
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`dob`))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.01 sec)
```

也可以使用`ALTER TABLE ... ADD PARTITION`向使用LIST分区的表新增分区。假设有数据表tt由以下`CREATE TABLE`语句定义：

```
mysql> CREATE TABLE tt (
    -> id INT,
    -> data INT
    -> )
    -> PARTITION BY LIST(data) (
    -> PARTITION p0 VALUES IN (5,10,15),
    -> PARTITION p1 VALUES IN (6,12,18)
    -> );
Query OK, 0 rows affected (0.12 sec)
```

可以添加一个新的分区，这个分区存储data列的值为7，14和21：

```
mysql> ALTER TABLE tt ADD PARTITION (
    -> PARTITION p2 VALUES IN (7,14,21)
    -> );
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

必须记住，不能添加一个新的LIST分区，这个分区包含的值已经被包含在已有的分区的值列表里中。如果尝试这么做将会产生错误：

```
mysql> ALTER TABLE tt ADD PARTITION (
    -> PARTITION np VALUES IN (4,8,12)
    -> );
ERROR 1495 (HY000): Multiple definition of same constant in list partitioning
```

因为任何data列的值为12的数据行已经被分配到p1分区了，不能再在表tt中创建一个新的值列表中包含12的分区。为了能成功实现，可以先删除p1，添加np和重定义的p1.然而，正如前面提到的，这会导致存储在p1分区中的所有数据丢失，这通常是我们所不想要的。

另一种解决方法是使用`CREATE TABLE ... SELECT ...`复制带有新分区的表并且将数据复制进去，然后删除旧的表并重命名新表，但这个方法在处理大量数据时可能非常耗时。在要求高可用性的情况下这也是不可行的。

可以在单个`ALTER TABLE ... ADD PARTITION`语句中添加多个分区，如下所示：

```
mysql> CREATE TABLE employee
s (
    -> id INT NOT NULL,
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> hired DATE NOT NULL
    -> )
    -> PARTITION BY RANGE (YEAR(hired)) (
    -> PARTITION p1 VALUES LESS THAN (1991),
    -> PARTITION p2 VALUES LESS THAN (1996),
    -> PARTITION p3 VALUES LESS THAN (2001),
    -> PARTITION p4 VALUES LESS THAN (2005)
    -> );
Query OK, 0 rows affected (0.32 sec)

mysql> ALTER TABLE employees ADD PARTITION (
    -> PARTITION p5 VALUES LESS THAN (2010),
    -> PARTITION p6 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.21 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

MySQL分区实现提供了不丢失数据的重定义分区方法。先看几个涉及RANGE分区的简单例子。调用如下定义的members表：

```
mysql> SHOW CREATE TABLE members\G;
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`dob`))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.01 sec)
```

假设你希望将在1960年前出生的成员的数据移动到一个独立的分区中。正如你所看到的一样，这个操作不能使用`ALTER TABLE ... ADD PARTITION`完成。然而，你可以使用另外一个与分区有关的`ALTER TABLE`扩展来实现：

```
mysql> ALTER TABLE members REORGANIZE PARTITION n0 INTO (
    -> PARTITION s0 VALUES LESS THAN (1960),
    -> PARTITION s1 VALUES LESS THAN (1970)
    -> );
Query OK, 0 rows affected (0.24 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

实际上，这条命令将分区p0拆分为两个新的分区s0和s1。它将存储在s0中的数据依据包含在两个`PARTITION ... VALUES ...`子句中的规则移动到新的分区中，因此s0分区值保留了那些YEAR(dob)的值小于1960的记录，s1分区保留了YEAR(dob)的值大于1960但小于1970的值的记录。

`REORGANIZE PARTITION`子句也可以用于合并两个相邻的分区。以下语句可以抵消之前的语句对表members的影响：

```
mysql> ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO
    -> ( PARTITION p0 VALUES LESS THAN (1970)
    -> );
Query OK, 0 rows affected (0.21 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
使用`REORGANIZE PARITION`拆分和合并分区不会造成数据丢失。在执行上述语句的时候，MySQL将s0和s1分区中的所有记录移动到p0分区中。

`REORGANIZE PARTITION`的通用语法如下：

```
ALTER TABLE tbl_name
	REORGANIZE PARTITION partition_list
	INTO (partition_definitions);
```

其中，tbl_name时分区表的名称，partition_list是一列用用逗号分隔的要更改的分区的名称，partition_definitions是一列用逗号分隔的分区定义，这些定义语句与`CREATE TABLE`中使用的partition_definitions遵循的规则一样。在使用`REORGANIZE PARTITION`语句时，你可以将多个分区合并成一个分区，也可以将一个分区拆分成多个分区。例如，可以将members表中的所有四个分区合并成两个：

```
ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
	PARTITION m0 VALUES LESS THAN (1980),
	PARTITION m1 VALUES LESS THAN (2000)
);
```

对于使用LIST分区的表也可以使用`REORGANIZE PARTITION`。回到向使用列分区的表tt中添加一个分区当失败的问题，因为新分区的值已经出现在一个已经存在的分区的值列表里。通过添加一个不包含冲突值的分区，然后重新组织这个新分区和现有的分区，以存储现有分区中已被移动到新分区的数据来处理这个问题：

```
ALTER TABLE tt ADD PARTITION (
	PARTITION np VALUES IN (4,8)
);

ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
	PARTITION p1 VALUES IN (6,8)
	PARTITION np VALUES IN (4,8,12)
);
```

以下是在使用`ALTER TABLE ... REORGANIZE PARTITION`为已经使用RANGE和LIST分区的表进行重新分区时时应该注意的几点：
* 用于确定新分区方案的PARTITION选项应遵循与`CREATE TABLE`语句相同的规则。新的RANGE分区方案不能有重叠的范围；新的LIST分区不能拥有任何重叠的值集合；
* partition_definitions列中分区的组合应占有与partition_list相同的范围或值结合。例如，分区p1和p2一起覆盖了members表中1980到1990的年份。着两个分区的任何重整都英爱覆盖总体相同的年份范围；
* 对于RANGE分区的表，只可以重整相邻的分区，不能跳过范围分区。例如，不能使用以`ALTER TABLE members REORGANIZE PARTITION p0,p2 INTO ...`语句开头的来重整members表，因为p0分区覆盖了到1970年的年份，而p2分区覆盖了1990到1999的年份，因此这两个分区并不是相邻的分区（在这个情况下，不能跳过分区p1）；
* 不能使用`REORGANIZE PARTITION`来改变表使用的分区类型。例如，不能将RANGE分区改成HASH分区，反之也不行。也不能使用这个语句来改变分区表达式或列。为了不删除或者重建表并完成着两个任务中的任何一个，可以使用`ALTER TABLE ... PARTITION BY...`，如下所示：
	```
	ALTER TABLE members
		PARTITION BY HASH(YEAR(dob))
		PARTITIONS 8;
	```

### 2.管理HASH和KEY分区

使用散列分区或键分区的表在更改分区设置方面非常相似，都与使用范围分区或列分区的表在许多方面不同。因此，此节只介绍散列分区或键分区表的修改。

HASH或KEY分区的表不能像RANGE或LIST分区的表那样删除分区。然而，可以使用`ALTER TABLE ... COALESCE PARTITION`合并HASH或KEY分区。假设有一个包含客户数据的clients表，这个表被分成12个分区：

```
CREATE TABLE clients (
	id INT,
	fname VARCHAR(30),
	lname VARCHAR(30),
	signed DATE
)
PARTITION BY HASH(MONTH(signed))
PARTITIONS 12;
```

为了将分区数从12减至8，可以执行以下的语句：

```
mysql> ALTER TABLE clients COALESCE PARTITION 4;
Query OK, 0 rows affected (0.97 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

COALESCE也同样适用于按HASH、KEY、LINEAR HASH和LINEAR KEY分区的表。以下示例与上个示例相似，唯一的不同就是表按LINEAR KEY分区：

```
mysql> CREATE TABLE clients_lk (
    -> id INT,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30),
    -> signed DATE
    -> )
    -> PARTITION BY HASH(YEAR(signed))
    -> PARTITIONS 12;
Query OK, 0 rows affected (0.68 sec)

mysql> ALTER TABLE clients_lk COALESCE PARTITION 4;
Query OK, 0 rows affected (1.00 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

COALESCE PARTITION后面的数字是要合并到剩余分区的分区数量，换句话说，就是要从表中移除的分区的数量。

删除比表中分区数量还多的分区将导致错误发生：

```
mysql> ALTER TABLE clients COALESCE PARTITION 14;
ERROR 1508 (HY000): Cannot remove all partitions, use DROP TABLE instead
```

为了将表clients的分区数量从12增加到18，可以使用如下`ALTER TABLE ... ADD PARTITION`：

```
mysql> ALTER TABLE clients ADD PARTITION PARTITIONS 10;
Query OK, 0 rows affected (1.32 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

### 3.交换表的分区和子分区

在MySQL8.0中，可以使用`ALTER TABLE pt EXCHANGE PARTITION p WITH TABLE nt`语句交换表的分区或子分区，其中pt是已经分区的表，p是将要与表nt交换的pt表的分区或子分区，前提是满足以下条件：
1. 表nt本身未分区；
2. 表nt不是一个临时表；
3. 表pt和nt的结构相同；
4. 表nt不含有外键引用，也没有任何引用nt的外键；
5. 表nt中没有位于分区定义p之外的数据行。如果使用了`WITHOUT VALIDATION`，则这种情况不适用；
6. 对于InnoDB的表，两个表使用相同的行格式。可以通过查询`INFORMATION_SCHEMA.INNOB_TABLES`确定InnoDB的行格式；

除了`ALTER TABLE`通常需要ALTER、INSERT和CREATE权限，执行`ALTER TABLE ... EXCHANGE PARTITION`语句还需要有DROP权限。

同时也应该记住`ALTER TABLE ... EXCHANGE PARTITION`的以下几点影响：

* 执行`ALTER TABLE ... EXCHANGE PARTITION`时不会调用任何分区表或要交换表的触发器；
* 任何待交换表的`AUTO_INCREMENT`列都会被重置；
* 当使用`ALTER TABLE ... EXCHANGE PARITION`时IGNORE关键字将不会有任何影响；

`ALTER TABLE ... EXCHANGE PARTITION`的语法如下所示，其中pt是已经分区的表，p是待交换的分区（或子分区），nt是一个将与p交换的未分区的表：

```
ALTER TABLE pt
	EXCHANGE PARTITION p
	WITH TABLE nt;
```

也可以添加`WITH VALIDATION`或`WITHOUT VALIDATION`语句。当指定`WITHOUT VALIDATION`时，`ALTER TABLE ... EXCHANGE PARTITION`操作在执行交换非分区表的分区时将不会执行一行一行的验证，允许数据库管理员承担确保数据行在分区定义范围内的责任。`WITH VALIDATION`是默认选项。

在单个`ALTER TABLE EXCHANGE PARTITION`语句中，可以与一个且仅有一个分为去的表交换一个且仅有一个分区或子分区。要交换多个分区或子分区需要使用多条`ALTER TABLE EXCHANGE PARTITION`语句。`EXCHANGE PARTITION`可能不会与其他`ALTER TABLE`选项相结合。分区表使用的父分区和（如果有）子分区可以是MySQL8.0中支持的任何类型。

#### 与一个非分区表交换分区

假设一个分区表e由以下语句定义和填充数据：

```
mysql> CREATE TABLE e (
    -> id INT NOT NULL,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id) (
    -> PARTITION p0 VALUES LESS THAN (50),
    -> PARTITION p1 VALUES LESS THAN (100),
    -> PARTITION p2 VALUES LESS THAN (150),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.34 sec)

mysql> INSERT INTO e VALUES
    -> (1669,'Jim','Smith'),
    -> (337,'Marry','Jones'),
    -> (16,'Frank','White'),
    -> (2005,'Linda','Black');
Query OK, 4 rows affected (0.07 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

现在创建一个未分区的复制了表e的表e2，这个可以使用以下语句创建：

```
mysql> CREATE TABLE e2 LIKE e;
Query OK, 0 rows affected (0.20 sec)

mysql> ALTER TABLE e2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.33 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以通过查询`INFORMATION_SCHEMA.PARTITIONS`表来查看表e中的哪个分区包含了数据行：

```
mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.05 sec)
```

#### 注意：

对于分区的InnoDB表，在`INFORMATION_SCHEMA.PARTITIONS`表中TABLE_ROWS列中给定的行数只是SQL优化中使用的估值，并不是实际的值。

为了与表e2交换表e中的p0分区，可以使用如下`ALTER TABLE`语句：

```
mysql> ALTER  TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.14 sec)
```

准确的说，刚刚发出的语句使分区中找到的任何行与表中找到的行交换。正如前面的例子，可以通过查询`INFORMATION_SCHEMA.PARTITIONS`表观察这是如何发生的。之前在分区p0中查找到的数据已经不存在了：

```
mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
```

如果查询表e2，可以找到“缺失的”行：

```
mysql> SELECT * FROM e2;
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
```

要与分区交换的表不一定是空的。为了证明这点，可以首先向e中插入一条新的数据，使用一条id列值小于50的数据，确保它是被存储到p0分区中的，之后通过查询`PARTITIONS`表验证这点：

```
mysql> INSERT INTO e VALUES (41,'Michael','Green');
Query OK, 1 row affected (0.05 sec)

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
```

现在可以再次使用之前的`ALTER TABLE`语句与e2交换分区p0：

```
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT * FROM e;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Marry | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.05 sec)

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM e2;
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
```

#### 不匹配的行

需要记住，在执行`ALTER TABLE ... EXCHANGE PARTITION`语句之前在未分区的表中找到的任何行必须满足存储它们索要被存储的分区的条件；否则，语句将会失败。要了解这种情况如何发生，首先向表e2中插入一条在表e的p0的分区定义边界外的数据。例如，插入一条id列值很大的数据，然后再尝试互换分区：

```
mysql> INSERT INTO e2 VALUES (51,'Ellen','McDonald');
Query OK, 1 row affected (0.05 sec)

mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
ERROR 1737 (HY000): Found a row that does not match the partition
```

只有`WITHOUT VALIDATION`选线允许这种操作成功：

```
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITHOUT VALIDATION;
Query OK, 0 rows affected (0.11 sec)
```

当分区与包含不符合分区定义的数据的表交换时，数据库管理员有责任修复不匹配的数据行，可以使用`REPAIR TABLE`或`ALTER TABLE ... REPAIR PARTITION`实现。

#### 无逐行验证的分区交换

为了防止分区与包含很多行数据的表进行交换时要花费很多时间进行验证，可以通过在`ALTER TABLE ... EXCHANGE PARTITION`语句后面添加`WITHOUT VALIDATION`跳过逐行验证的步骤

下面的例子比较了与一个未分区的表交换分区时由验证和没有验证的执行时间。已经分区的表（表e）包含两个都含有一百万条数据的分区。在e表p0分区的数据将被移除，p0与未分区表的一百万条数据交换。`WITH VALIDATION`操作花费了0.74秒，相比之下，`WITHOUT VALIDATION`操作花费了0.01秒。

```
# Create a partitioned table with 1 million rows in each partition
CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (1000001),
        PARTITION p1 VALUES LESS THAN (2000001), 
);

mysql> SELECT COUNT(*) FROM e;                                             
| COUNT(*) |
+----------+
|  2000000 | 
+----------+ 
1 row in set (0.27 sec)

# View the rows in each partition
SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+-------------+ 
| PARTITION_NAME | TABLE_ROWS  | 
+----------------+-------------+ 
| p0             |     1000000 | 
| p1             |     1000000 | 
+----------------+-------------+ 
2 rows in set (0.00 sec)

# Create a nonpartitioned table of the same structure and populate it with 1 million rows
CREATE TABLE e2 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30) 
);

mysql> SELECT COUNT(*) FROM e2; 
+----------+
| COUNT(*) | 
+----------+ 
|  1000000 | 
+----------+ 
1 row in set (0.24 sec)

# Create another nonpartitioned table of the same structure and populate it with 1 million rows
CREATE TABLE e3 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30) 
);    

mysql> SELECT COUNT(*) FROM e3; 
+----------+ 
| COUNT(*) | 
+----------+ 
|  1000000 | 
+----------+ 
1 row in set (0.25 sec)

# Drop the rows from p0 of table e
mysql> DELETE FROM e WHERE id < 1000001; 
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |          0 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)    

# Exchange partition p0 of table e with the table e2 'WITH VALIDATION'
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITH VALIDATION; 
Query OK, 0 rows affected (0.74 sec)

# Confirm that the partition was exchanged with table e2
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |    1000000 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)

# Once again, drop the rows from p0 of table e
mysql> DELETE FROM e WHERE id < 1000001; 
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |          0 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e3 'WITHOUT VALIDATION'
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e3 WITHOUT VALIDATION; 
Query OK, 0 rows affected (0.01 sec)

# Confirm that the partition was exchanged with table e3
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |    1000000 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)
```

#### 与未分区的表交换子分区

也可以使用`ALTER TABLE ...EXCHANGE PARTITION`语句使有子分区的表与未分区的表交换子分区。在下面的例子中，首先创建一个有RANGE分区且由KEY子分区表es，与填充表e一样填充这个表，然后创建一个未分区的空表es2：

```
mysql> CREATE TABLE es (
    -> id INT NOT NULL,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id)
    -> SUBPARTITION BY KEY(lname)
    -> SUBPARTITIONS 2 (
    -> PARTITION p0 VALUES LESS THAN (50),
    -> PARTITION p1 VALUES LESS THAN (100),
    -> PARTITION p2 VALUES LESS THAN (150),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.43 sec)

mysql> INSERT INTO es VALUES
    -> (1669,'Jim','Smith'),
    -> (337,'Mary','Jones'),
    -> (16,'Frank','White'),
    -> (2005,'Linda','Black');
Query OK, 4 rows affected (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> CREATE TABLE es2 LIKE es;
Query OK, 0 rows affected (0.45 sec)

mysql> ALTER TABLE es2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.41 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

虽然在创建表es时没有明确地命名任何子分区，但当在选择表中数据时，我们可以通过从
`INFORMATION_SCHEMA`中地`PARTITIONS`表中包含的`SUBPARTITION_NAME`列中获得这些子分区的生成名称，如下：

```
mysql> SELECT PARTITION_NAME,SUBPARTITION_NAME,TABLE_ROWS
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          1 |
| p3             | p3sp1             |          2 |
+----------------+-------------------+------------+
8 rows in set (0.01 sec)
```

下面的`ALTER TABLE`语句将es表中的子分区p3sp0与未分区的es2表交换：

```
mysql> ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;
Query OK, 0 rows affected (0.13 sec)
```

可以通过如下的查询来验证是否交换：

```
mysql> SELECT PARTITION_NAME,SUBPARTITION_NAME,TABLE_ROWS
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          0 |
| p3             | p3sp1             |          2 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql> SELECT * FROM es2;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
+------+-------+-------+
1 row in set (0.00 sec)
```

如果表是有子分区的，只能与未分区的表交换表的一个子分区，而不是整个表，如下表所示：

```
mysql> ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;
ERROR 1734 (HY000): Subpartitioned table, use subpartition instead of partition
```

表结构以一种严格的方式进行比较；分区表与非分区表的列数目，排序，名称和类型以及索引必须完全匹配。另外，两个表必须拥有相同的存储引擎：

```
mysql> CREATE TABLE es3 LIKE e;
Query OK, 0 rows affected (0.28 sec)

mysql> ALTER TABLE es3 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.28 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE es3 \G;
*************************** 1. row ***************************
       Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

ERROR:
No query specified

mysql> ALTER TABLE es3 ENGINE=MyISAM;
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH es3;
ERROR 1497 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL
```

---

### 4.分区维护

可以使用用于维护表和分区的SQL语句对许多表和分区执行维护任务。

分区表的维护可以使用`CHECK TABLE`，`OPTIMIZE TABLE`，`ANALYZE TABLE`和`REPEAT TABLE`语句来完成，这些语句都是支持分区表的。

可以使用`ALTER TABLE`语句的多个扩展直接在一个或多个分区上执行这种类型的操作，如下所示：
* **重建分区：** 这个方法与删除分区中存储的所有数据，然后重新插入数据有相同的作用。这对于碎片整理很有用。示例：
	```
	ALTER TABLE tb_name REBUILD PARTITION partition_list;
	```
* **优化分区：** 如果你从一个分区中删除了大量的数据行，或者对具有可变长度的数据行（即具有VARCHAR，BLOB或TEXT列）的分区表做了大量修改，可以使用`ALTER TABLE ... OPTIMIZE PARTITION`语句来回收未使用的空间以及对分区的数据进行碎片整理。示例：
	```
	ALTER TABLE t1 OPTIMIZE PARTITION p0,p1;
	```
	对一个给定的分区使用`OPTIMIZE PARTITION`与在这个分区上运行`CHECK PARTITION`，`ANALYZE PARTITION`和`REPAIR PARTITION`是等效的。












