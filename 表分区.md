## 表分区类型

可以使用分区将单个表的各部分分散到一个文件系统中。用户所选择的划分数据的规划被称为分区函数（partitioning function），它可以是模量（modulu），与一组范围或值列表、一个内部哈希函数或一个线性哈希函数简单匹配。

表的不同行可以被分配给不同的物理分区，称为**水平分区**；在**垂直分区**中，表的不同列被分配给不同的物理分区，MySQL不支持垂直分区。

对一个表做分区有很多种方法：
* RANGE：这种类型的分区根据落在给定范围内的列值，将行分配给分区；
* LIST：类似于按RANGE分区，不同的是其分区是基于与一组离散值匹配的列来选择的；
* HASH：在这种类型的分区操作中，一个分区时根据用户定义的表达式返回来的值来选择的，该表达式对插入到表的行中的列值进行操作。HASH函数可以包含任何在MySQL中具有非负整数值的有效表达式；
* KEY：这种类型的分区类似于HASH分区，只是它仅提供一个或多个列，而且MySQL服务器提供自己的哈希函数。这些列可以包含除整数值意外的其他值，因为MySQL提供的哈希函数保证不管列数据是什么类型，结果都是整数；

---

#### 1.RANGE分区

**示例：**

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN (21)
);
```

在这个例子中，所有在1~5号商场工作的员工将被分到p0分区；在6~10号商场工作的员工将被分到p1分区，依次类推。但是当插入一条商场编号大于20的数据时将会抛出错误，因为这里并没有分区可以覆盖到编号大于20的商场。我们可以用一个“捕获所有”的方法来处理小于最大数值的情况：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (stored_id)
	PARTITION p0 VALUES LESS THAN (6),
	PARTITION p1 VALUES LESS THAN (11),
	PARTITION p2 VALUES LESS THAN (16),
	PARTITION p3 VALUES LESS THAN  MAXVALUE
);
```

其中，**MAXVALUE**是一个永远大于可能的最大整数值的整数。

这样，所有商场编号大于16的员工的数据将被分配到p3分区。若商场数量增加到较大的数值，我们可以使用ALTER TABLE语句为21~25，26~30等的商场编号分区。

同样的，我们也可以根据职位编号范围来分区。假设，两位数的职位编号是普通员工的编号，三位数的职位编号对应的是办公室和人事部门的员工，四位数的职位编号是管理层的编号，这样，我们可以根据上述划分分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
	PARTITION p0 VALUES LESS THAN (100),
	PARTITION p1 VALUES LESS THAN (1000),
	PARTITION p2 VALUES LESS THAN (10000)
);
```

如果不想根据商店数量来划分分区，也可以根据时间来作为划分依据。例如，我们希望根据每个员工的离职年份作为划分依据，则我们可以这样划分：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	stored_id INT NOT NULL
)
PARTITION BY RANGE (YEAR(separated)) (
	PARTITION p0 VALUES LESS THAN (1991),
	PARTITION p1 VALUES LESS THAN (1996),
	PARTITION p2 VALUES LESS THAN (2001),
	PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

在这种划分方案中，所有在1991年之前离职的员工将被分配到p0分区中；在1991年到1995年之间离职的员工将被分配到p1分区中；在1996年到2000年之间离职的员工将被分配到p2分区中，在2001年之后离职的员工将被分配到p3分区。

也可以用UNIX_TIMESTAMP()函数，根据数据类型为时间戳的列的值来划分分区，如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY VALUE (UNIX_TIMESTAMP(report_updated)) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
	PARTITION p0 VALUES LESS THAN ( MAXVALUE )
)
```

RANGE分区在以下几种情况下会十分高效：
* 当你想要或者需要删除一些“旧”数据。如果你之前在表上应用了分区方案，你只需要使用`ALTER TABLE xxxx DROP PARTITION xx;`语句就可以简单地将某个分区中的所有数据都删除。当某个表中的数据量很大时，使用分区会比`DELETE`语句更加高效；
* 当你想要使用包含日期或时间戳或者来自其他值；
* 你经常查询依赖于作为表分区依据的列。例如，当执行查询语句`EXPLAIN SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND '2000-12-31' GROUP BY store_id;`，MySQL会快速确定只需要扫描p2分区，因为剩下的分区没办法满足`WHERE`后面的条件；

RANGE分区的一个变型是RANGE COLUMNS分区。

RANGE COLUMNS分区可以使用多个列值来确定分区的范围，该范围即可以适用分区中行的放置，也可以用于执行分区整理时确定包含或排除特定分区。

**基于时间间隔的分区方案**

如果想在MySQL8.0中应用基于时间范围或时间间隔的分区方案，你有两个选择方案：

**1.** 用RANGE分区方法对表进行分区，对于分区表达式，可以使用一个函数处理DATE，TIME或者DATETIME列并且返回一个整数数值，例如：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY VALUE ( YEAR(joined) ) (
	PARTITION p0 VALUES LESS THAN (1960),
	PARTITION p1 VALUES LESS THAN (1970),
	PARTITION p2 VALUES LESS THAN (1980),
	PARTITION p3 VALUES LESS THAN (1990),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

在MySQL8.0中，也可以使UNIX_TIMESTAMP()函数处理时间戳列按RANGE分区对表进行分区，例如：

```
CREATE TABLE quarterly_report_status (
	report_id INT NOT NULL,
	report_status VARCHAR(20) NOT NULL,
	report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
	PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') )
);
```

**2.** 用RANGE COLUMNS对表进行分区，用DATE或DATETIME列作为分区列。例如，members表可以直接用joined列作为分区的依据，如下所示：

```
CREATE TABLE members (
	firstname VARCHAR(25) NOT NULL,
	lastname VARCHAR(25) NOT NULL,
	username VARCHAR(16) NOT NULL,
	email VARCHAR(35),
	joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS (joined) (
	PARTITION p0 VALUES LESS THAN ('1960-01-01'),
	PARTITION p1 VALUES LESS THAN ('1970-01-01'),
	PARTITION p2 VALUES LESS THAN ('1980-01-01'),
	PARTITION p3 VALUES LESS THAN ('1990-01-01'),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

---

#### 2.LIST分区

MySQL中的LIST分区和RANGE分区在很多方面的很相似。与RANGE分区一样，必须明确定义每一个分区。LIST分区和RANGE分区最主要的不同就是，在LIST分区方法中，每一个分区是基于一组列表中的列值元素而不是一组连续范围内的值来定义和选择的。

这些由`PARTITION BY LIST(expr)`语句来定义，其中expr是一个列的值或者是一个基于列值并且返回一个整数数值的表达式。然后通过`VALUES IN (value_list)`定义每一个分区，其中value_list是用逗号分隔的整数列表。

#### 提示： 

在MySQL8.0中，使用LIST分区时可以只与一列整数（或者是NULL）匹配。但在LIST COLUMNS分区时，值列表中也可以使用其他的列值类型。

与通过范围定义分区的情况不同，列表分区不需要定义任何明确的顺序。

在下面的例子中，我们假设要被分区的表的基础定义由以下的`CREATE TABLE`语句提供：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
);
```

假设一共由有20家影音商店分布在如下4个专营权中：

|地区|商店编号|
|:---|:---|
|NORTH|3,5,6,9,17|
|EAST|1,2,10,11,19,20&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|WEST|4,12,13,14,18|
|CENTRAL&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|7,8,15,16|

为了能将属于同一地区的商店的数据行存储到相同的分区中，可以使用如下的`CREATE TABLE`语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY LIST(store_id) (
	PARTITION pNORTH VALUES IN (3,5,6,9,17),
	PARTITION pEAST VALUES IN (1,2,10,11,19,20),
	PARTITION pWEST VALUES IN (4,12,13,14,18),
	PARTITION pCENTRAL VALUES IN (7,8,15,16)
);
```

这样就可以很容易地添加或删除与特定地区相关的某个员工的纪录。例如，假设所有西部地区的商店都被出售给另外一个公司。在MySQL8.0中，所有与在那个地区的商店中工作的员工的数据行都可以用`ALTER TABLE employees TRUNCATE PARTITION pWEST`语句删除，这比使用相应的DELETE语句`DELETE FROM employees WHERE store_id IN (4,12,13,14,18);`更加高效。（使用`ALTER TABLE employees DROP PARTITION pWEST`语句不仅会删除所有的西部商场员工的数据行，还会从表定义中删除pWEST这个分区，你还需要使用` ALTER TABLE ... ADD PARTITION`声明恢复表原始分区方案。）

与RANGE分区相同，可以将LIST分区与哈希或键分区结合起来产生复合分区（子分区）。

与RANGE分区不同的是，LIST分区没有类似MAXVALUE的"catch-all"语句。所有的分区表达式的期望值必须包含在`PARTITION...VALUES IN (...)`语句中。

如果一个INSERT语句包含了一个未匹配的分区列值将会抛出一个错误，如下：

```
mysql> CREATE TABLE h2 (
    -> c1 INT,
    -> c2 INT
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (1,4,7),
    -> PARTITION p1 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.13 sec)

mysql> INSERT INTO h2 VALUES (3,5);
ERROR 1526 (HY000): Table has no partition for value 3
```

当使用INSERT语句向InnoDB表中一次性插入多条数据时，InnoDB引擎会认为这个语句是单个事务，因此当出现任何未能匹配到的值都会使得这个语句的执行完全失败，不会插入任何行。

可以通过使用IGNORE关键字忽略这类错误。若这样操作，包含未能匹配到分区的列值的行将不会被插入到表中，但是会插入正常匹配到分区的行到表中，并且不会报任何错误：

```
mysql> TRUNCATE h2;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT * FROM h2;
Empty set (0.01 sec)

mysql> INSERT IGNORE INTO h2 VALUES (2,5), (6,10), (7,5), (3,1), (1,9);
Query OK, 3 rows affected, 2 warnings (0.05 sec)
Records: 5  Duplicates: 2  Warnings: 2

mysql> SELECT * FROM h2;
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
```

MySQL8.0也支持LIST COLUMNS分区，一种允许使用整数类型以外的其他列的类型作为分区，并且使用多个列作为分区键的LIST分区。

---

#### 3.COLUMNS分区

COLUMNS分区可以使用多个列作为分区键。为了能将行放置在分区中以及确定在分区修整时为了匹配行哪些分区需要检查，所有这些列都会被纳入考虑的范围。

此外，RANGE COLUMNS分区和LIST COLUMNS分区都支持使用非整数列来定义值范围或列元素。允许使用的数据类型如下所示：
* 所有整数类型：TINYINT，SMALLINT，MEDIUMINT，INT(INTEGER)和BIGINT。（这与RANGE和LIST分区相同）；
* DATE和DATETIME，使用其他日期或时间相关的列不能作为分区列；
* 如下的字符串类型：CHAR，VARCHAR，BINARY和VARBINARY，TEXT和BLOB类型的列不能作为分区列；

#### 3.1 RANGE COLUMNS分区

RANGE COLUMNS分区与RNAGE分区相似，但是允许使用基于多个列值的范围定义分区。另外，可以使用非整数类型的列来定义范围。

RANGE COLUMNS分区与RANGE分区显著的差别如下：
* RANGE COLUMNS不接受表达式，只接受列名；
* RANGE COLUMNS接受一个或多个列的列表；RANGE COLUMNS分区是基于元组（列值列表）之间的比较，而不是标量之间的比较。行在RANGE COLUMNS分区中的放置位置也是基于元组之间的比较；
* RANGE COLUMNS分区列不限于整数列，字符串，DATE和DATETIME列也可以被用作分区列；

创建由RANGE COLUMNS分区的表的基本语法如下所示：

```
CREATE TABLE table_name
PARTITION BY RANGE COLUMNS(column_list) （
	PARTITION partition_name VALUES LESS THAN (value_list)[,
	PARTITION partition_name VALUES LESS THAN (value_list)][,...]
)

column_list:
	column_name[, column_name][,...]

value_list:
	value[,value][,...]
```

其中，column_list是包含一个或多个列的列表（有时也称为分区列列表），value_list是值列表（也即分区定义值列表）。

必须为每个分区定义提供一个value_list，而且每个value_list必须拥有与column_list中的列相同数量的值。也就是说，假如在COLUMNS子句中使用N个列，那么VALUES LESS THAN子句中必须提供一个有N个值的列表。

分区定义中列表中的元素与值列表中的值顺序必须相同。另外，值列表中的每个元素必须与分区列列表中相应的拥有相同的数据类型。

但是，分区列列表中列名和值列表的顺序并不一定要与定义表的`CREATE TABLE`语句中的顺序相同。与按照RANGE分区的表相同，我们可以使用MAXVALUE代表一个使得所有插入到给定行的和合法值永远小于MAXVALUE的值。如：

```
mysql> CREATE TABLE rcx (
    -> a INT,
    -> b INT,
    -> c CHAR(3),
    -> d INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,d,c) (
    -> PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    -> PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
    -> PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
Query OK, 0 rows affected (0.14 sec)
```

rcx表包含了a，b，c，d列。提供给COLUMNS的分区列列表中使用了其中的3个值，顺序为a，d，c。每个用于定义分区的值列表也包含了这3个值，且顺序相同。也就是，每个值列表元组的形式都是(INT,INT,CHAR(3))，对应a，d，c列使用的数据类型（按此顺序）。

通过比较要被插入的行的满足COLUMNS子句中列列表匹配的元组与在`VALUES LESS THAN`子句中使用的用于定义表分组的元组来确定行在分区中的放置位置。因为我们是通过比较元组（也即是，列或者值的集合）而不是标量，RANGE COLUMNS分区中使用的`VALUES LESS THAN `语义与简单RANGE分区的情况有所不同。

在RANGE分区中，一行生成的等于VALUES LESS THAN的限制值的表达值永远不会被放到相应的分区中；然而，当使用RANGE COLUMNS分区时，有可能会将分区列列表中的第一个元素与VALUES LESS THAN值列表中的第一个元素相等的行放置到相应的分区中。

如果以下声明创建了RANGE分区表：

```
CREATE TABLE r1 (
	a INT,
	b INT
)
PARTITION BY RANGE (a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果向表中插入3行数据，每条数据中a的值都是5，所有的数据都会被放置到p1分区，因为3条数据行的a列值都不小于5。我们可以通过对INFORMATION_SCHEMA.PARTITIONS表执行适当的查询来查看分区：

```
mysql> INSERT INTO r1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='r1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```
现在考虑一个相似的表rc1，这个表使用了RANGE COLUMNS分区，在COLUMNS子句中引用了列a和b，创建语句为：

```
CREATE TABLE rc1 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (5,12),
	PARTITION p1 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

如果我们向rc1表中插入与r1表完全相同的数据，结果将会有所不同：

```
mysql> INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rc1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          2 |
| p1             |          1 |
+----------------+------------+
```

这是因为我们比较的是行而不是标量。我们可以将插入的行值与VALUES LESS THAN子句中用来限制rc1表中分区p0的行值进行比较，如：

```
mysql> SELECT (5,10)<(5,12),(5,11)<(5,12),(5,12)<(5,12);
+---------------+---------------+---------------+
| (5,10)<(5,12) | (5,11)<(5,12) | (5,12)<(5,12) |
+---------------+---------------+---------------+
|             1 |             1 |             0 |
+---------------+---------------+---------------+
```

(5,10)和(5,11)这两个元组比(5,12)小，所以它们被存放在分区p0中。又因为5不小于5，12不小于12，所以(5,12)被认为不小于(5,12)，因此被放置在分区p1中。

上面例子中的SELECT语句也可以使用显示行构造函数编写，如：

```
SELECT ROW(5,10)<ROW(5,12),ROW(5,11)<ROW(5,12),ROW(5,12)<ROW(5,12);
```

对于一个仅使用一个分区列的RANGE COLUMNS分区的表，分区中行的存储与由RANGE分区的等效表相同。如：

```
CREATE TABLE rx (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS(a) (
	PARTITION p0 VALUES LESS THAN (5),
	PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
```

如果我们向表中插入行(5,10)，(5,11)和(5,12)，可以看到它们的存放方式与表r1中的存放方式时相同的：

```
mysql> INSERT INTO rx VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='rx';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```

也可以创建由RANGE COLUMNS分区的表，其中在连续的分区定义中重复一个或多个列的限制值。只要是用于定义分区的列值是严格递增的，就可以执行此操作。例如，以下的每个CREATE TABLE语句都是有效的：

```
CREATE TABLE rc2 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);

CREATE TABLE rc3 (
	a INT,
	b INT
)
PARTITION BY RANGE COLUMNS (a,b) (
	PARTITION p0 VALUES LESS THAN (0,10),
	PARTITION p1 VALUES LESS THAN (10,20),
	PARTITION p2 VALUES LESS THAN (10,30),
	PARTITION p2 VALUES LESS THAN (10,35),
	PARTITION p2 VALUES LESS THAN (20,40),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
```

以下的声明语句也能成功，即使第一眼看到可能会认为它不能成功执行因为p0分区的b列的限制值是25，p1分区的限制值是20，p1分区的c列限制值是100而p2分区的限制值是50：

```
CREATE TABLE rc4 (
	a INT,
	b INT,
 	c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
	PARTITION p0 VALUES LESS THAN (0,25,50),
	PARTITION p1 VALUES LESS THAN (10,20,100),
	PARTITION p2 VALUES LESS THAN (10,30,50),
	PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
```

当设计以RANGE COLUMNS分区的表，你始终可以使用mysql客户端比较所需的元组来测试连续的分区定义，就像：

```
mysql> SELECT (0,25,50)<(10,20,100),(10,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(10,20,100) | (10,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      1 |
+-----------------------+------------------------+
```

如果CREATE TABLE语句中包含的分区定义顺序不是严格递增，将失败并抛出错误，如：

```
mysql> CREATE TABLE rcf (
    -> a INT,
    -> b INT,
    -> c INT
    -> )
    -> PARTITION BY RANGE COLUMNS (a,b,c) (
    -> PARTITION p0 VALUES LESS THAN (0,25,50),
    -> PARTITION p1 VALUES LESS THAN (20,20,100),
    -> PARTITION p2 VALUES LESS THAN (10,30,50),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
```

若看到此类错误，可以通过在列列表中进行“小于”比较推断哪些分区定义语句是无效的。在上面情况下，问题在于p2分区的定义，因为用于定义的元组并不小于用于定义p3分区的元组：

```
mysql> SELECT (0,25,50)<(20,20,100), (20,20,100)<(10,30,50);
+-----------------------+------------------------+
| (0,25,50)<(20,20,100) | (20,20,100)<(10,30,50) |
+-----------------------+------------------------+
|                     1 |                      0 |
+-----------------------+------------------------+
```

使用RANGE COLUMNS分区时，MAXVALUE可以多次出现在VALUES LESS THAN子句的同一列中。然而，连续分区定义中各个列的限制值也应该时增加的，在MAXVALUE被作为上限的所有列中不应该定义多个分区，且这种分区应该出现在`PARTITION ... VALUES LESS THAN`子句列的最后。此外，不能使用MAXVALUE作为多个分区定义第一列的限制值。

正如前面所说，可以在RANGE COLUMNS分区中使用非整数列作为分区列。

例如，使用RANGE COLUMNS分区时，可以创建一个可以根据员工的姓氏将每一行存储在四分区中之一的表：

```
COLUMNS TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT NOT NULL,
	store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

可以通过执行如下ALTER TABLE语句使用此方案修改已经创建的employee表的分区：

```
ALTER TABLE employee PARTITION BY RANGE COLUMNS (lname) (
	PARTITION p0 VALUES LESS THAN ('g'),
	PARTITION p1 VALUES LESS THAN ('m'),
	PARTITION p2 VALUES LESS THAN ('t'),
	PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

同样的，你也可以用`ALTER TABLE`语句将employee表基于员工的雇佣年代将数据存放在不同的分区中，语法如下：

```
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired) (
	PARTITION p0 VALUES LESS THAN ('1970-01-01'),
	PARTITION p1 VALUES LESS THAN ('1980-01-01'),
	PARTITION p2 VALUES LESS THAN ('1990-01-01'),
	PARTITION p3 VALUES LESS THAN ('2000-01-01'),
	PARTITION p4 VALUES LESS THAN ('2010-01-01'),
	PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
```

<br>

#### 3.2 LIST COLUMNS分区

MySQL8.0支持LIST COLUMNS分区。这是一种LIST分区的变型，允许使用多个列作为分区键并且支持非整数类型的作为分区列，可以使用DATE和DATETIME列。

假设你的业务在12个城市拥有客户，出于销售或者市场营销的目的，你将它们分在为4个区域，每个区域有3个城市，如下表所示：

|Region&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|Cities|
|:---|:---|
|1|Oskarshamn,Högsby,Mönsterås|
|2|Vimmerby,Hultsfred,Västervik&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|
|3|Nässjö,Eksjö,Vetlanda|
|4|Uppvidinge,Alvesta,Växjo|

当用LIST COLUMNS分区时，你可以创建一个客户数据表，该表依据客户所在城市的名称将客户数据行分配给这四个区域中匹配的其中一个区域，如下所示：

```
CREATE TABLE customers_1 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
	PARTITION pRegion_1 VALUES IN ('Oskarshamn','Högsby','Mönsterås'),
	PARTITION pRegion_2 VALUES IN ('Vimmerby','Hultsfred','Västervik'),
	PARTITION pRegion_3 VALUES IN ('Nässjö','Eksjö','Vetlanda'),
	PARTITION pRegion_4 VALUES IN ('Uppvidinge','Alvesta','Växjo')
);
```

就像RANGE COLUMNS分区一样，你不需要在COLUMNS()子句中使用表达式将列值转化成为整数。（实际上，COLUMNS()不允许使用除列名之外的其他表达式）。

也可以使用DATE和DATETIME列，在下面的例子中使用与之前customers_1表一样的列和名称，但使用基于renewal列的LIST COLUMNS分区将行存储在4个分区中的其中一个，具体取决于客户账户在2010年2月第几周更新：

```
CREATE TABLE customers_2 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES IN ('2010-02-01','2010-02-02','2010-02-03','2010-02-04','2010-02-05','2010-02-06','2010-02-07'),
	PARTITION pWeek_2 VALUES IN ('2010-02-08','2010-02-09','2010-02-10','2010-02-11','2010-02-12','2010-02-13','2010-02-14'),
	PARTITION pWeek_3 VALUES IN ('2010-02-15','2010-02-16','2010-02-17,'2010-02-18','2010-02-19','2010-02-20','2010-02-21'),
	PARTITION pWeek_4 VALUES IN ('2010-02-22','2010-02-23','2010-02-24','2010-02-25','2010-02-26','2010-02-27','2010-02-28')
);
```

这是可行的，但是如果日期数量增加到很大的数值，则定义和维护这个表会变得很麻烦。这种情况下，更常用的是用RANGE或者RANGE COLUMNS分区方法。在上述例子中，由于希望用作分区键的是DATE列，所以使用RANGE COLUMNS分区方法，如下所示：

```
CREATE TABLE customers_3 (
	first_name VARCHAR(25),
	last_name VARCHAR(25),
	street_1 VARCHAR(30),
	street_2 VARCHAR(30),
	city VARCHAR(15),
	renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
	PARTITION pWeek_1 VALUES LESS THAN ('2010-02-08'),
	PARTITION pWeek_2 VALUES LESS THAN ('2010-02-15'),
	PARTITION pWeek_3 VALUES LESS THAN ('2010-02-22'),
	PARTITION pWeek_4 VALUES LESS THAN ('2010-03-01')
);
```

另外，与RANGE COLUMNS分区相同，也可以在COLUMNS()子句中使用多个列。

---

#### 4.HASH分区

用HASH分区主要是为了确保在预定数量之间的分区能够使分数据均匀分布。对于RANGE和LIST分区，我们必须明确指定将给定某个列值或某组列值应该存放在哪个分区中，这个由我们决定，我们仅需要确定列值或基于要散列的列值以及要将划分的分区数的表达式。

使用HASH分区划分表，必须在CREATE TABLE语句后面添加一个PARTITION BY HASH(expr)子句，其中expr使一个能返回整数的表达式。这可以只是列的名，该列的类型是MySQL整数类型中的一种。

另外，你可能很希望在此之后增加一个PARTITIONS num，其中num是代表这个表将被划分为的分区数的正整数。

#### 提示：

为简单起见，下面例子中的表并没有使用任何键。你应该意识到，如果表中拥有唯一键，被用于这个表分区表达式中的每一列都必须是这些唯一键的一部分，包括主键。

下面创建一个在store_id列上使用哈希表的语句将表分成了4个分区：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(store_id)
PARTITION 4;
```

如果没有包含PARTITION子句，分区的数量将默认是1；使用PARTITION关键字但后面没带数字将出现语法错误。

你也可以使用一个返回整数的SQL表达式expr。例如，你想根据雇佣员工的年份进行分区。可用如下语句：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30)，
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	store_id INT
)
PARTITION BY HASH(YEAR(hired))
PARTITION 4;
```

其中，expr必须返回一个非恒定，非随机的整数值（也就是说，它应该是变化但是确定的），并且不得包含第6节中“分区的限制”中提到的任何禁止构造。你应该记住，每次插入或更新（或者删除）一行数据时，都会求这个表达式的值，这意味着过于复杂的表达式可能会造成性能问题，特别是在执行能一次性影响很多行数据的操作时（例如批量插入时）。

最高效的散列函数是对单个表的列进行操作的函数，其值与列值一致的增大或减小，因为这允许对分区范围进行“裁剪”。这也就是，表达式随着其所基于的列值的变化越紧密，MySQL越能高效地使用该表达式进行哈希分区。

例如，date_col是类型为DATE的列，则表达式`TO_DAYS(date_col)`随着date_col值的变化而变化，因为对于date_col值的每次更改，表达式的值也相应的做更改。表达式`YEAR(date_col)`相对于date_col的变动相对于`TO_DAYS(date_col)`对于date_col的变动并不是那么直接，因为并不是所有date_col的变动都会使`YEAR(date_col)`产生同样的改变。即便如此，`YEAR(date_col)`也是散列函数的理想选择，因为它能随着date_col的一部分变化而直接变化，并且date_col中的改变不可能在`YEAR(date_col)`中产生不成比例的变化。

相比之下，假如有一个名为int_col的列，数据类型为INT。考虑表达式`POW(5-int_col,3)+6`。这并不是散列方程的理想对象，因为int_col值的改变并不能保证表达式的值能做出相应的变化。用一个给定的数值改变int_col的值可能使得表达式的值产生很大的差别。例如，将int_col的值从5变为6，表达式的值会改变-1，但当int_col的值从6变为7时，表达式的值将改变-7-。

也就是说，列值与表达式值的曲线越接近方程`y=cx`（其中c时一个非零常数）所描绘的直线，表达式更适合作为哈希函数。这与以下事实有关，表达式越是非线性的，它所产生的数据在分区中的分布越不均匀。

理论上讲，也可以对包含多个列值的表达式进行修剪，但是确定哪个表达式更适合可能非常困难且耗时。因此，使用包含多个列的散列表达式并不是十分推荐。

当使用哈希分区时，存储引擎会依据表达式结果的模数来确定要使用num个分区中的哪个分区。也就是说，对于一个给定的表达式expr，记录被存储的分区号为N，其中`N=MOD(expr,num)`。假设表t1被如下语句定义，因此它有4个分区：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY HASH (YEAR(col3))
PARTITION 4;
```

如果向表t1中插入一条col3值为'2005-09-15'的记录，则它被存放的分区取决于以下函数：

```
 MOD(YEAR('2005-09-15'),4)
=MOD(2005,4)
=1
```

MySQL8.0还支持HASH分区一个变型，也就是linear hashing，它采用了更加复杂的算法以确定插入表中的新行应该被存储到哪个分区中。

每次插入或更新一条记录时，都会评估用户提供的表达式。当删除记录时，还可能依据情况对其进行评估。

#### 4.1 LINEAR HASH分区

MySQL也支持线性散列，与常规散列不同的是线性散列采用了线性二乘幂算法而普通散列使用散列函数值的模数。

从语法上讲，线性散列分区与普通散列分区唯一的不同之处仅是在`PARTITION BY`子句中增加了LINEAR关键字，如下所示：

```
CREATE TABLE employees (
	id INT NOT NULL,
	fname VARCHAR(30),
	lname VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	separated DATE NOT NULL DEFAULT '9999-12-31',
	job_code INT,
	stored_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITION 4;
```

给定一个表达式expr，使用线性散列时存储记录的分区是num个分区中的N分区号，其中N是根据以下算法产生的：

1. 查找下一个比num大的2的幂值，我们称之为V，它可以由如下计算产生：

	```
	V = POWER(2,CEILING(LOG(2,num)))
	```
	（假设num的值是13，则`LOG(2,13)`的值是3.7004，`CEILING(3.7004)`的值是4，所以`V = POWER(2,4)`是16。）

2. 令`N = F(column_list)&(V-1)`；
3. 当N≥num：
	* 令`V = V/2`；
	* 令`N = N&(V-1)`

假设有表t1，该表使用线性散列分区并拥有6个分区，其创建语句为：

```
CREATE TABLE t1 (
	col1 INT,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR HASH( YEAR(col3) )
PARTITION 6;
```

假设现在要插入两条记录到t1表中，且两条记录的col3列的值分别为'2003-04-14'和'1998-10-19'。第一条记录的分区号由如下语句定义：

```
V = POWER(2,CEILING(LOG(2,6))) = 8
N = YEAR('2003-04-14') & (8-1)
  = 2003 & 7 (位与运算)
  = 3

(3≥6为假，因此该条记录被分配到3号分区)
```

第二条记录的分区号由下面语句确定：

```
V = 8
N = YEAR('1998-10-19') & (8-1)
  = 1998 & 7
  = 6

(6≥6为真，需要进一步计算)

N = 6 & ((8/2)-1)
  = 6 & 3
  = 2

(2≥6为假，因此该条记录被分配到2号分区)
```

线性散列进行分区的优势在于添加、删除、合并和拆分分区更加快捷，这在于处理存储了极其庞大的数据的表时十分有用。缺点在于，比起常规散列分区，线性散列分区的数据在分区中的分布并不是那么均匀。

----

#### 5.KEY分区

键分区与哈希分区相似，除了哈希分区使用了用户自定义的表达式之外，键分区的散列函数是由MySQL服务器提供的。

`CREATE TABLE ... PARTITION BY KEY`的 语法规则与创建采用哈希分区的表的语法规则相似。最主要的区别是：
* 采用的是KEY而不是HASH；
* KEY只接受零个或多个列名的列表。如表含有一个主键，则任何作为分区键的列都必须包含部分或全部表的主键。如果没有任何指定任何列名作为分区键，则默认使用表的主键（如果含有主键）。下面的`CREATE TABLE`语句在MySQL8.0中是有效的：

	```
	CREATE TABLE k1 (
		id INT NOT NULL PRIMARY KEY,
		name VARCHAR(20)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```
	如果没有主键但拥有一个唯一键，则唯一键将被用作分区键：

	```
	CREATE TABLE k1 (
		id INT NOT NULL,
		name VARCHAR(20),
		UNIQUE KEY (id)
	)
	PARTITION BY KEY()
	PARTITION 2;
	```

	然而，若唯一键列没有被定义为`NOT NULL`，则前面例子中的语句将执行失败。

在这两种情况下，分区键都是id列，即使没有在`SHOW CREATE TABLE`或者在`INFORMATION_SCHEMA.PARTITIONS`表的`PARTITION_EXPRESSION`列中显示出来。

不像其他分区类型，KEY分区使用的列并没有严格限制只能是整数或NULL值。例如，下面的`CREATE TABLE`语句是可行的：

```
CREATE TABLE tm1 (
	s1 CHAR(32) PRIMARY KEY
)
PARITION BY KEY(s1)
PARITION 10;
```

若指定其他分区类型，上述例子中的语句将是无效的。（在这种请款下，只使用`PARTITION BY KEY()`也是可行的，与使用`PARTITION BY KEY(s1)`效果一样，因为s1是表的主键。）

#### 重要：

对于一个使用键分区的表，不能执行`ALTER TABLE DROP PRIMARY KEY`，如果这样做会产生错误：`ERROR 1466 (HY000): Field in list of fields for partition function not found in table.`

也可以使用线性键对表进行分区。如下所示：

```
CREATE TABLE tk (
	col1 INT NOT NULL,
	col2 CHAR(5),
	col3 DATE
)
PARTITION BY LINEAR KEY(col1)
PARTITION 3;
```

LINEAR关键字对KEY分区的作用与对HASH分区的作用一样，使用二乘幂算法而不是取模运算产生分区号。

---

#### 6.细分

细分，也成为复合分区，是对分区表中每个表的进一步划分。考虑如下`CREATE TABLE`语句：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased))
SUBPARTITION 2 (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

表ts有3个RANGE分区。p0，p1和p2分区都被进一步划分为2个子分区。实际上，整个表被划分成`3*2=6`个分区。然而，因为`PARTITION BY RANGE`子句的作用，其中的前两个值只存储那些purchased列的值小于1990的记录。

可以通过对使用RANGE或LIST分区的表进行细分。子分区可以使用HASH或KEY分区。这也就是复合分区。

#### 注意：

`SUBPARTITION BY HASH`和`SUBPARTITION BY KEY`通常分别遵循`PARTITION BY HASH`和`PARTITION BY KEY`的语法规则。唯一的区别就是`SUBPARTITION BY KEY`（不像`PARTITION BY KEY`）并不支持默认列，因此，即使表拥有显示的主键，也必须指定用于此语法的列。

可以是使用`SUBPARTITION`子句来明确定义子分区，以指定每个子分区的选项。例如，创建前面例子中的ts表的更加冗长的方式为：

```
CREATE TABLE ts (
	id INT,
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased)) (
	PARTITION p0 VALUES LESS THAN (1990) (
		SUBPARTITION s0,
		SUBPARTITION s1
	),
	PARTITION p1 VALUES LESS THAN (2000) (
		SUBPARTITION s2,
		SUBPARTITION s3
	),
	PARTITION p2 VALUES LESS THAN MAXVALUE (
		SUBPARTITION s4,
		SUBPARTITION s5
	)
);
```

这里列出了一些语法上的注意事项：
* 每个分区都应拥有相同数量的子分区；
* 如果在一个分区表中明使用`SUBPARTITION`确定义了任何子分区，必须完整地定义它们。否则将失败：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s2,
			SUBPARTITION s3
		)
	);
	```
	如果使用到SUBPARTITIONS 2将会出错；
* 每个`SUBPARTITION`子句必须包含（至少）一个子分区的名称。否则，你可以为子分区设置任何所需的选项或者允许其采用该选项的默认设置；
* 子分区的名称在整个表中应该是唯一的。如下的`CREATE TABLE`语法是有效的：

	```
	CREATE TABLE ts (
		id INT,
		purchased DATE
	)
	PARTITION BY RANGE(YEAR(purchased))
	SUBPARTITION BY HASH(TO_DAYS(purchased)) (
		PARTITION p0 VALUES LESS THAN (1990) (
			SUBPARTITION s0,
			SUBPARTITION s1
		),
		PARTITION p1 VALUES LESS THAN (2000) (
			SUBPARTITION s2,
			SUBPARTITION s3
		),
		PARTITION p2 VALUES LESS THAN MAXVALUE (
			SUBPARTITION s4,
			SUBPARTITION s5
		)
	);
	```

---

#### 7.MySQL分区如何处理NULL值

MySQL中的分区允许NULL作为分区表达式的值，不论它是列值还是用户提供的表达式的值。虽然允许使用NULL值作为其他必须产生整数的表达式的值，也必须记住NULL不是一个数字。MySQL的分区实现将NULL视为小于任何非NULL值的值，就如`ORDER BY`一样。

这意味着对NULL的处理随着分区类型的不同而变化，而且可能产生意想不到的结果。在这种情况下，我们将在本节中讨论在确定应存储行的分区时每种MySQL分区类型如何处理NULL值，并提供每种示例。


#### RANGE分区处理NULL值

如果向一个由RANGE分区的表中插入一行数据，其中决定分区的列值是NULL，则这行数据将被插入到最低的分区中。考虑以下两个在p数据库中的表：

```
mysql> CREATE TABLE t1
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (0),
    -> PARTITION p1 VALUES LESS THAN (10),
    -> PARTITION p2 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.40 sec)

mysql> CREATE TABLE t2
    -> (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY RANGE(c1) (
    -> PARTITION p0 VALUES LESS THAN (-5),
    -> PARTITION p1 VALUES LESS THAN (0),
    -> PARTITION p2 VALUES LESS THAN (10),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.31 sec)
```

可以使用如下查询语句查询INFORMATION_SCHEMA数据库中的PARTITIONS表，查看上述两`CREATE TABLE`语句创建的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          0 |              0 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.09 sec)
```

现在，向每个表中填充一行被用作分区键的列中带有NULL的数据，并使用`SELECT`语句验证数据行已被插入到表中：

```
mysql> INSERT INTO t1 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> INSERT INTO t2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.05 sec)

mysql> SELECT * FROM t1;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
```

可以通过前面查询INORMATIONS_SCHEMA.PARTITIONS表的语句查看那个分区被用来存储被插入的数据行：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA = 'p'AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          1 |          16384 |       16384 |
| t1         | p1             |          0 |              0 |       16384 |
| t1         | p2             |          0 |              0 |       16384 |
| t2         | p0             |          1 |          16384 |       16384 |
| t2         | p1             |          0 |              0 |       16384 |
| t2         | p2             |          0 |              0 |       16384 |
| t2         | p3             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
```

你也可以通过删除最低的分区以证明这两行数据都被存放在这些分区中，并重新执行`SELECT`语句：

```
mysql> ALTER TABLE t1 DROP PARTITION p0;
Query OK, 0 rows affected (0.14 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE t2 DROP PARTITION p0;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM t1;
Empty set (0.05 sec)

mysql> SELECT * FROM t2;
Empty set (0.05 sec)
```

使用SQL函数的分区表达式也这样处理NULL值。假设我们使用如下的`CREATE TABLE`语句定义一个表：

```
CREATE TABLE tndate (
	id INT,
	dt DATE
)
PARTITION BY RANGE(YEAR(dt)) (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (2000),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

正如其他的MySQL函数，`YEAR(NULL)`返回NULL值。一行dt列值为NULL的数据被分区表达式认为是一个小于任何其他值的方式处理，因此这行数据被插入p0分区。

#### LIST分区处理NULL值

当且仅当分区定义中使用了包含NULL值的列表时，使用LIST分区的表才允许有NULL值。相反的，当一个使用LIST分区的表没有在值列表里明确使用了NULL值时，它将拒绝在分区表达式中会产生NULL值的数据行。例如：

```
mysql> CREATE TABLE ts1 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.25 sec)

mysql> INSERT INTO ts1 VALUES (9,'mothra');
ERROR 1526 (HY000): Table has no partition for value 9

mysql> INSERT INTO ts1 VALUES (NULL,'mothra');
ERROR 1526 (HY000): Table has no partition for value NULL
```

只有c1列的值在0到8之间的数据行可以被插入到表中ts1中。NULL在这个范围之外，就像数字9一样。我们可以创建值列表中包含NULL值的ts2和ts3表：

```
mysql> CREATE TABLE ts2 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7),
    -> PARTITION p2 VALUES IN (2,5,8),
    -> PARTITION p3 VALUES IN (NULL)
    -> );
Query OK, 0 rows affected (0.23 sec)

mysql> CREATE TABLE ts3 (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY LIST(c1) (
    -> PARTITION p0 VALUES IN (0,3,6),
    -> PARTITION p1 VALUES IN (1,4,7,NULL),
    -> PARTITION p2 VALUES IN (2,5,8)
    -> );
Query OK, 0 rows affected (0.27 sec)
```

当定义分区列值时，可以（也应该）像处理其他值一样处理NULL值。例如，`VALUES IN (NULL)`和`VALUES IN (1,4,7,NULL)`是可行的，`VALUES IN (1,NULL,4,7)`、`VALUES IN (NULL,1,4,7)`等也同样有效。可以向ts2和ts3表中插入一行c1列带有NULL值的数据行：

```
mysql> INSERT INTO ts2 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)

mysql> INSERT INTO ts3 VALUES (NULL,'mothra');
Query OK, 1 row affected (0.06 sec)
```

通过对INFORMATION_SCHEMA.PARTITIONS的查询，可以确定刚刚插入表中的数据行被存储在哪个分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME LIKE 'ts_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts1        | p0             |          0 |              0 |       16384 |
| ts1        | p1             |          0 |              0 |       16384 |
| ts1        | p2             |          0 |              0 |       16384 |
| ts2        | p0             |          0 |              0 |       16384 |
| ts2        | p1             |          0 |              0 |       16384 |
| ts2        | p2             |          0 |              0 |       16384 |
| ts2        | p3             |          1 |          16384 |       16384 |
| ts3        | p0             |          0 |              0 |       16384 |
| ts3        | p1             |          1 |          16384 |       16384 |
| ts3        | p2             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
10 rows in set (0.05 sec)
```

正如前面章节所示的那样，可以通过删除分区并使用`SELECT`语句来验证哪些分区用来存储数据行。

#### HASH分区和KEY分区处理NULL值

对于使用HASH分区和LIST分区的表，处理的NULL值的方法有所不同。在这些情况下，任何产生NULL值的分区表达式都将被视作其返回值为0。通过检测创建使用HASH分区的表和向其中填充包含适当值的记录的文件系统的影响可以验证这点。假设有一个表th使用如下语句创建：

```
mysql> CREATE TABLE th (
    -> c1 INT,
    -> c2 VARCHAR(20)
    -> )
    -> PARTITION BY HASH(c1)
    -> PARTITIONS 2;
Query OK, 0 rows affected (0.20 sec)
```

可是使用如下语句查询这个表的分区：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.06 sec)
```

每个分区中的`TABLE_ROWS`列的值都是0。现在分别向th表中插入两条c1列的值为NULL和0的数据行，并且验证这两行数据都被插入到表中：

```
mysql> INSERT INTO th VALUES (NULL,'mothra'),(0,'gigan');
Query OK, 2 rows affected (0.05 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM th;
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
|    0 | gigan  |
+------+--------+
2 rows in set (0.00 sec)
```

回想以下，对于任何整数N，`NULL MOD N`的值永远是NULL。对于使用HASH和KEY分区的表，将使用此结果来确定正确的分区应该是0。查看INFORMATION_SCHEMA.PARTITIONS表，可以看到两条数据都被插入到p0分区中：

```
mysql> SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_SCHEMA='p' AND TABLE_NAME = 'th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          2 |           8192 |       16384 |
| th         | p1             |          0 |              0 |       16384 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
```

重复最后一个例子，但在定义表的语句中用`PARTITION BY KEY`代替`PARTITION BY HASH`，可以证明这种分区方式处理NULL值也如同处理0一样。

---

## 分区管理

使用SQL语句来修改分区表的方法有很多种，可以使用`ALTER TABLE`语句扩展来新增，删除，重定义，合并或者拆分已有的分区。还有一些方法可以获取分区表和分区信息。

#### 注意：

所有分区表的分区都必须拥有相同数量的子分区，一旦表创建之后就不能修改子分区。

更改表分区的方案，只需要使用带有`partition_options`选项的`ALTER TABLE`的语句，此语句与创建分区表的`CREATE TABLE`的语法一样；选项（也）通常以关键字`PARTITION BY`开头。假设下面如下的`CREATE TABLE`语句用于创建一个使用range分区的表：

```
CREATE TABLE trb3 (
	id INT,
	name VARCHAR(50),
	purchased DATE
)
PARTITION BY RANGE(YEAR(purchased)) (
	PARTITION p0 VALUES LESS THAN (1990),
	PARTITION p1 VALUES LESS THAN (1995),
	PARTITION p2 VALUES LESS THAN (2000),
	PARTITION p3 VALUES LESS THAN (2005)
);
```

对此表重新分区，以便通过使用id列值作为基的础键将表分为两个分区，可以使用如下语句：

```
ALTER TABLE tb3 PARTITION BY KEY(id) PARTITIONS 2;
```

这对表结构的影响如同使用如下语句删除表然后重新创建一样：

```
CRAETE TABLE tb3 PARTITION BY KEY(id) PARTITIONS 2;
```

`ALTER TABLE ... ENGINE = ...`仅仅改变表使用的存储引擎但完整地保留了表的分区方案。这个语句只有在目标存储引擎提供分区支持时才能成功。你也可以使用`ALTER TABLE ... REMOVE PARTITIONING`移除表分区。

#### 重要：

在给定的`ALTER TABLE`语句中，仅能使用一个`PARTITION BY`，`ADD PARTITION`，`DROP PARTITION`，`REORGANIZE PARTITION`或`COALESCE PARTITION`子句。例如你想删除一个分区并且重新组织表剩余的分区，你必须在两条单读的`ALTER TABLE`语句中（其中一条语句使用`DROP PARTITION`，第二条语句使用`REORGANIZE PARTITION`）。

你可以使用`ALTER TABLE ... TRUNCATE PARTITION`语句一次性删除一个或者多个选中的分区。

### 1.管理RANGE和LIST分区

添加或者删除RANGE和LIST分区的操作相似，本章中将讨论两种分区的管理。

从由RANGE或者LIST分区的表中删除分区可以由带`DROP PARTITIION`选项的`ALTER TABLE`语句完成。假设你使用下面的`CREATE TABLE`和`INSERT`语句创建了一个RANGE分区的表并且填充了10条数据：

```
mysql> CREATE TABLE tr (
    -> id INT,
    -> name VARCHAR(50),
    -> purchased DATE
    -> )
    -> PARTITION BY RANGE (YEAR(purchased)) (
    -> PARTITION p0 VALUES LESS THAN (1990),
    -> PARTITION p1 VALUES LESS THAN (1995),
    -> PARTITION p2 VALUES LESS THAN (2000),
    -> PARTITION p3 VALUES LESS THAN (2005),
    -> PARTITION p4 VALUES LESS THAN (2010),
    -> PARTITION p5 VALUES LESS THAN (2015)
    -> );
Query OK, 0 rows affected (0.31 sec)

mysql> INSERT INTO tr VALUES
    -> (1,'desk organiser','2003-10-15'),
    -> (2,'alarm clock','1997-11-05'),
    -> (3,'chair','2009-03-10'),
    -> (4,'bookcase','1989-01-10'),
    -> (5,'exercise bike','2014-05-09'),
    -> (6,'sofa','1987-06-05'),
    -> (7,'espresso maker','2011-11-22'),
    -> (8,'aquarium','1992-08-04'),
    -> (9,'study desk','2006-09-16'),
    -> (10,'lava lamp','1998-12-25');
Query OK, 10 rows affected (0.06 sec)
Records: 10  Duplicates: 0  Warnings: 0
```

可以看到应该被插入到p2分区的记录如下所示：

```
mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.05 sec)
```

也可以通过使用分区查询得到这些信息：

```
mysql> SELECT * FROM tr PARTITION (p2);
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.00 sec)
```

通过执行如下命令可以删除名为p2的分区：

```
mysql> ALTER TABLE tr DROP PARTITION p2;
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

#### 注意：

NDBCLUSTER存储引擎并不支持`ALTER TABLE ... DROP PARTITION`。然而，它支持这一节中介绍的其他分区相关的`ALTER TABLE`扩展。

需要记住，当删除分区时同时也删除了此分区存储的所有的数据。重新运行之前的`SELECT`查询，可以看到这种情况：

```
mysql> SELECT * FROM tr
    -> WHERE purchased
    -> BETWEEN '1995-01-01' AND '1999-12-31';
Empty set (0.00 sec)
```

#### 注意：

本地分区的API支持`DROP PARTITION`，并且可能与`ALGORITHM={COPY|INPLACE}`一起使用。使用`ALGORITHM=INPLACE`的`DROP PARTITION`会删除分区中存储的数据和删除分区。然而，使用`ALGORITHM=COPY`的`DROP PARTITION`会重新建立分区表，并尝试用一个兼容的`PARTITION ... VALUES`的定义将数据从被删除的分区移动到另外一个分区中。不能移动到另外一个分区的数据将被删除。

正因如此，你在对数据表执行`ALTER TABLE ... DROP PARTITION`前应该首先拥有对该表的`DROP`权限。

如果想要从所有分区中删除所有数据但是保留表的定义和分区方案，使用`TRUNCATE TABLE`语句。

如果你想要改变表的分区同时不丢失数据，可以使用`ALTER TABLE ... REORGANIZE PARTITION`。

如果执行`SHOW CREATE TABLE`语句，可以看到组成表的分区是如何改变的：

```
mysql> SHOW CREATE TABLE tr \G;
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`purchased`))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (2010) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN (2015) ENGINE = InnoDB) */
1 row in set (0.06 sec)
```

当向已经改变的表中插入新的数据，这些数据的purchased列的值在'1995-01-01'和'2004-12-31'时，这些数据会被放在p3分区中。你可以使用以下语句中证明：

```
mysql> INSERT INTO tr VALUES (11,'pencil holder','1995-07-12');
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
+------+---------------+------------+
| id   | name          | purchased  |
+------+---------------+------------+
|   11 | pencil holder | 1995-07-12 |
+------+---------------+------------+
1 row in set (0.00 sec)

mysql> ALTER TABLE tr DROP PARTITION p3;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM tr WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
Empty set (0.00 sec)
```

服务器不会像等效的DELETE查询语句那样报告由于`ALTER TABLE ... DROP PARTITION`而从表中删除的行数。

删除LIST分区使用与删除RANGE分区完全一样的`ALTER TABLE ... DROP PARTITION`语法。然而，对于以后使用数据表的影响有一点不同的是：无法再将已被删除的分区定义的数据列表包含的数据插入到数据表中。

使用`ALTER TABLE ... ADD PARTITION`可以在之前已经分好区的表中新增一个范围分区或列分区。对于使用RANGE分区的表，也可以在已经存在的分区列表后面添加一个范围。假设你有一个已经分区好的表，里面包含了你的社团的成员信息：

```
mysql> CREATE TABLE members (
    -> id INT,
    -> fname VARCHAR(25),
    -> lname VARCHAR(25),
    -> dob DATE
    -> )
    -> PARTITION BY RANGE(YEAR(dob)) (
    -> PARTITION p0 VALUES LESS THAN (1980),
    -> PARTITION p1 VALUES LESS THAN (1990),
    -> PARTITION p2 VALUES LESS THAN (2000)
    -> );
Query OK, 0 rows affected (0.10 sec)
```

进一步假设，最小成员的年龄是16岁。到2015年年底时，你意识到很快你将接收2000年（或之后）出生的成员。可以使用以下语句修改表members以适应在2000年至2010年间出生的新成员：

```
mysql> ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2010));
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

对于范围分区的数据表，你只用使用`ADD PARTITION`语句在高的一端分区列表添加分区。尝试向在已存在的分区之间或之前添加新的分区将产生错误：

```
mysql> ALTER TABLE members
    -> ADD PARTITION (
    -> PARTITION n VALUES LESS THAN (1970));
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly »   increasing for each partition
```

你可以通过将第一个分区拆分成两个分区（将它们之间的范围划分开）来解决这个问题：

```
mysql> ALTER TABLE members
    -> REORGANIZE PARTITION p0 INTO (
    -> PARTITION n0 VALUES LESS THAN (1970),
    -> PARTITION n1 VALUES LESS THAN (1980)
    -> );
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

使用`SHOW CREATE TABLE`可以查看`ALTER TABLE`语句已经产生了期望的效果：

```
mysql> SHOW CREATE TABLE members \G;
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`dob`))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.01 sec)
```

也可以使用`ALTER TABLE ... ADD PARTITION`向使用LIST分区的表新增分区。假设有数据表tt由以下`CREATE TABLE`语句定义：

```
mysql> CREATE TABLE tt (
    -> id INT,
    -> data INT
    -> )
    -> PARTITION BY LIST(data) (
    -> PARTITION p0 VALUES IN (5,10,15),
    -> PARTITION p1 VALUES IN (6,12,18)
    -> );
Query OK, 0 rows affected (0.12 sec)
```

可以添加一个新的分区，这个分区存储data列的值为7，14和21：

```
mysql> ALTER TABLE tt ADD PARTITION (
    -> PARTITION p2 VALUES IN (7,14,21)
    -> );
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

必须记住，不能添加一个新的LIST分区，这个分区包含的值已经被包含在已有的分区的值列表里中。如果尝试这么做将会产生错误：

```
mysql> ALTER TABLE tt ADD PARTITION (
    -> PARTITION np VALUES IN (4,8,12)
    -> );
ERROR 1495 (HY000): Multiple definition of same constant in list partitioning
```

因为任何data列的值为12的数据行已经被分配到p1分区了，不能再在表tt中创建一个新的值列表中包含12的分区。为了能成功实现，可以先删除p1，添加np和重定义的p1.然而，正如前面提到的，这会导致存储在p1分区中的所有数据丢失，这通常是我们所不想要的。

另一种解决方法是使用`CREATE TABLE ... SELECT ...`复制带有新分区的表并且将数据复制进去，然后删除旧的表并重命名新表，但这个方法在处理大量数据时可能非常耗时。在要求高可用性的情况下这也是不可行的。

可以在单个`ALTER TABLE ... ADD PARTITION`语句中添加多个分区，如下所示：

```
mysql> CREATE TABLE employee
s (
    -> id INT NOT NULL,
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> hired DATE NOT NULL
    -> )
    -> PARTITION BY RANGE (YEAR(hired)) (
    -> PARTITION p1 VALUES LESS THAN (1991),
    -> PARTITION p2 VALUES LESS THAN (1996),
    -> PARTITION p3 VALUES LESS THAN (2001),
    -> PARTITION p4 VALUES LESS THAN (2005)
    -> );
Query OK, 0 rows affected (0.32 sec)

mysql> ALTER TABLE employees ADD PARTITION (
    -> PARTITION p5 VALUES LESS THAN (2010),
    -> PARTITION p6 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.21 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

MySQL分区实现提供了不丢失数据的重定义分区方法。先看几个涉及RANGE分区的简单例子。调用如下定义的members表：

```
mysql> SHOW CREATE TABLE members\G;
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`dob`))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.01 sec)
```

假设你希望将在1960年前出生的成员的数据移动到一个独立的分区中。正如你所看到的一样，这个操作不能使用`ALTER TABLE ... ADD PARTITION`完成。然而，你可以使用另外一个与分区有关的`ALTER TABLE`扩展来实现：

```
mysql> ALTER TABLE members REORGANIZE PARTITION n0 INTO (
    -> PARTITION s0 VALUES LESS THAN (1960),
    -> PARTITION s1 VALUES LESS THAN (1970)
    -> );
Query OK, 0 rows affected (0.24 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

实际上，这条命令将分区p0拆分为两个新的分区s0和s1。它将存储在s0中的数据依据包含在两个`PARTITION ... VALUES ...`子句中的规则移动到新的分区中，因此s0分区值保留了那些YEAR(dob)的值小于1960的记录，s1分区保留了YEAR(dob)的值大于1960但小于1970的值的记录。

`REORGANIZE PARTITION`子句也可以用于合并两个相邻的分区。以下语句可以抵消之前的语句对表members的影响：

```
mysql> ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO
    -> ( PARTITION p0 VALUES LESS THAN (1970)
    -> );
Query OK, 0 rows affected (0.21 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
使用`REORGANIZE PARITION`拆分和合并分区不会造成数据丢失。在执行上述语句的时候，MySQL将s0和s1分区中的所有记录移动到p0分区中。

`REORGANIZE PARTITION`的通用语法如下：

```
ALTER TABLE tbl_name
	REORGANIZE PARTITION partition_list
	INTO (partition_definitions);
```

其中，tbl_name时分区表的名称，partition_list是一列用用逗号分隔的要更改的分区的名称，partition_definitions是一列用逗号分隔的分区定义，这些定义语句与`CREATE TABLE`中使用的partition_definitions遵循的规则一样。在使用`REORGANIZE PARTITION`语句时，你可以将多个分区合并成一个分区，也可以将一个分区拆分成多个分区。例如，可以将members表中的所有四个分区合并成两个：

```
ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
	PARTITION m0 VALUES LESS THAN (1980),
	PARTITION m1 VALUES LESS THAN (2000)
);
```

对于使用LIST分区的表也可以使用`REORGANIZE PARTITION`。回到向使用列分区的表tt中添加一个分区当失败的问题，因为新分区的值已经出现在一个已经存在的分区的值列表里。通过添加一个不包含冲突值的分区，然后重新组织这个新分区和现有的分区，以存储现有分区中已被移动到新分区的数据来处理这个问题：

```
ALTER TABLE tt ADD PARTITION (
	PARTITION np VALUES IN (4,8)
);

ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
	PARTITION p1 VALUES IN (6,8)
	PARTITION np VALUES IN (4,8,12)
);
```

以下是在使用`ALTER TABLE ... REORGANIZE PARTITION`为已经使用RANGE和LIST分区的表进行重新分区时时应该注意的几点：
* 用于确定新分区方案的PARTITION选项应遵循与`CREATE TABLE`语句相同的规则。新的RANGE分区方案不能有重叠的范围；新的LIST分区不能拥有任何重叠的值集合；
* partition_definitions列中分区的组合应占有与partition_list相同的范围或值结合。例如，分区p1和p2一起覆盖了members表中1980到1990的年份。着两个分区的任何重整都英爱覆盖总体相同的年份范围；
* 对于RANGE分区的表，只可以重整相邻的分区，不能跳过范围分区。例如，不能使用以`ALTER TABLE members REORGANIZE PARTITION p0,p2 INTO ...`语句开头的来重整members表，因为p0分区覆盖了到1970年的年份，而p2分区覆盖了1990到1999的年份，因此这两个分区并不是相邻的分区（在这个情况下，不能跳过分区p1）；
* 不能使用`REORGANIZE PARTITION`来改变表使用的分区类型。例如，不能将RANGE分区改成HASH分区，反之也不行。也不能使用这个语句来改变分区表达式或列。为了不删除或者重建表并完成着两个任务中的任何一个，可以使用`ALTER TABLE ... PARTITION BY...`，如下所示：
	```
	ALTER TABLE members
		PARTITION BY HASH(YEAR(dob))
		PARTITIONS 8;
	```

### 2.管理HASH和KEY分区

使用散列分区或键分区的表在更改分区设置方面非常相似，都与使用范围分区或列分区的表在许多方面不同。因此，此节只介绍散列分区或键分区表的修改。

HASH或KEY分区的表不能像RANGE或LIST分区的表那样删除分区。然而，可以使用`ALTER TABLE ... COALESCE PARTITION`合并HASH或KEY分区。假设有一个包含客户数据的clients表，这个表被分成12个分区：

```
CREATE TABLE clients (
	id INT,
	fname VARCHAR(30),
	lname VARCHAR(30),
	signed DATE
)
PARTITION BY HASH(MONTH(signed))
PARTITIONS 12;
```

为了将分区数从12减至8，可以执行以下的语句：

```
mysql> ALTER TABLE clients COALESCE PARTITION 4;
Query OK, 0 rows affected (0.97 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

COALESCE也同样适用于按HASH、KEY、LINEAR HASH和LINEAR KEY分区的表。以下示例与上个示例相似，唯一的不同就是表按LINEAR KEY分区：

```
mysql> CREATE TABLE clients_lk (
    -> id INT,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30),
    -> signed DATE
    -> )
    -> PARTITION BY HASH(YEAR(signed))
    -> PARTITIONS 12;
Query OK, 0 rows affected (0.68 sec)

mysql> ALTER TABLE clients_lk COALESCE PARTITION 4;
Query OK, 0 rows affected (1.00 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

COALESCE PARTITION后面的数字是要合并到剩余分区的分区数量，换句话说，就是要从表中移除的分区的数量。

删除比表中分区数量还多的分区将导致错误发生：

```
mysql> ALTER TABLE clients COALESCE PARTITION 14;
ERROR 1508 (HY000): Cannot remove all partitions, use DROP TABLE instead
```

为了将表clients的分区数量从12增加到18，可以使用如下`ALTER TABLE ... ADD PARTITION`：

```
mysql> ALTER TABLE clients ADD PARTITION PARTITIONS 10;
Query OK, 0 rows affected (1.32 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

### 3.交换表的分区和子分区

在MySQL8.0中，可以使用`ALTER TABLE pt EXCHANGE PARTITION p WITH TABLE nt`语句交换表的分区或子分区，其中pt是已经分区的表，p是将要与表nt交换的pt表的分区或子分区，前提是满足以下条件：
1. 表nt本身未分区；
2. 表nt不是一个临时表；
3. 表pt和nt的结构相同；
4. 表nt不含有外键引用，也没有任何引用nt的外键；
5. 表nt中没有位于分区定义p之外的数据行。如果使用了`WITHOUT VALIDATION`，则这种情况不适用；
6. 对于InnoDB的表，两个表使用相同的行格式。可以通过查询`INFORMATION_SCHEMA.INNOB_TABLES`确定InnoDB的行格式；

除了`ALTER TABLE`通常需要ALTER、INSERT和CREATE权限，执行`ALTER TABLE ... EXCHANGE PARTITION`语句还需要有DROP权限。

同时也应该记住`ALTER TABLE ... EXCHANGE PARTITION`的以下几点影响：

* 执行`ALTER TABLE ... EXCHANGE PARTITION`时不会调用任何分区表或要交换表的触发器；
* 任何待交换表的`AUTO_INCREMENT`列都会被重置；
* 当使用`ALTER TABLE ... EXCHANGE PARITION`时IGNORE关键字将不会有任何影响；

`ALTER TABLE ... EXCHANGE PARTITION`的语法如下所示，其中pt是已经分区的表，p是待交换的分区（或子分区），nt是一个将与p交换的未分区的表：

```
ALTER TABLE pt
	EXCHANGE PARTITION p
	WITH TABLE nt;
```

也可以添加`WITH VALIDATION`或`WITHOUT VALIDATION`语句。当指定`WITHOUT VALIDATION`时，`ALTER TABLE ... EXCHANGE PARTITION`操作在执行交换非分区表的分区时将不会执行一行一行的验证，允许数据库管理员承担确保数据行在分区定义范围内的责任。`WITH VALIDATION`是默认选项。

在单个`ALTER TABLE EXCHANGE PARTITION`语句中，可以与一个且仅有一个分为去的表交换一个且仅有一个分区或子分区。要交换多个分区或子分区需要使用多条`ALTER TABLE EXCHANGE PARTITION`语句。`EXCHANGE PARTITION`可能不会与其他`ALTER TABLE`选项相结合。分区表使用的父分区和（如果有）子分区可以是MySQL8.0中支持的任何类型。

#### 与一个非分区表交换分区

假设一个分区表e由以下语句定义和填充数据：

```
mysql> CREATE TABLE e (
    -> id INT NOT NULL,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id) (
    -> PARTITION p0 VALUES LESS THAN (50),
    -> PARTITION p1 VALUES LESS THAN (100),
    -> PARTITION p2 VALUES LESS THAN (150),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.34 sec)

mysql> INSERT INTO e VALUES
    -> (1669,'Jim','Smith'),
    -> (337,'Marry','Jones'),
    -> (16,'Frank','White'),
    -> (2005,'Linda','Black');
Query OK, 4 rows affected (0.07 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

现在创建一个未分区的复制了表e的表e2，这个可以使用以下语句创建：

```
mysql> CREATE TABLE e2 LIKE e;
Query OK, 0 rows affected (0.20 sec)

mysql> ALTER TABLE e2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.33 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以通过查询`INFORMATION_SCHEMA.PARTITIONS`表来查看表e中的哪个分区包含了数据行：

```
mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.05 sec)
```

#### 注意：

对于分区的InnoDB表，在`INFORMATION_SCHEMA.PARTITIONS`表中TABLE_ROWS列中给定的行数只是SQL优化中使用的估值，并不是实际的值。

为了与表e2交换表e中的p0分区，可以使用如下`ALTER TABLE`语句：

```
mysql> ALTER  TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.14 sec)
```

准确的说，刚刚发出的语句使分区中找到的任何行与表中找到的行交换。正如前面的例子，可以通过查询`INFORMATION_SCHEMA.PARTITIONS`表观察这是如何发生的。之前在分区p0中查找到的数据已经不存在了：

```
mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
```

如果查询表e2，可以找到“缺失的”行：

```
mysql> SELECT * FROM e2;
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
```

要与分区交换的表不一定是空的。为了证明这点，可以首先向e中插入一条新的数据，使用一条id列值小于50的数据，确保它是被存储到p0分区中的，之后通过查询`PARTITIONS`表验证这点：

```
mysql> INSERT INTO e VALUES (41,'Michael','Green');
Query OK, 1 row affected (0.05 sec)

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
```

现在可以再次使用之前的`ALTER TABLE`语句与e2交换分区p0：

```
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.10 sec)

mysql> SELECT * FROM e;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Marry | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.05 sec)

mysql> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM e2;
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
```

#### 不匹配的行

需要记住，在执行`ALTER TABLE ... EXCHANGE PARTITION`语句之前在未分区的表中找到的任何行必须满足存储它们索要被存储的分区的条件；否则，语句将会失败。要了解这种情况如何发生，首先向表e2中插入一条在表e的p0的分区定义边界外的数据。例如，插入一条id列值很大的数据，然后再尝试互换分区：

```
mysql> INSERT INTO e2 VALUES (51,'Ellen','McDonald');
Query OK, 1 row affected (0.05 sec)

mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
ERROR 1737 (HY000): Found a row that does not match the partition
```

只有`WITHOUT VALIDATION`选线允许这种操作成功：

```
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITHOUT VALIDATION;
Query OK, 0 rows affected (0.11 sec)
```

当分区与包含不符合分区定义的数据的表交换时，数据库管理员有责任修复不匹配的数据行，可以使用`REPAIR TABLE`或`ALTER TABLE ... REPAIR PARTITION`实现。

#### 无逐行验证的分区交换

为了防止分区与包含很多行数据的表进行交换时要花费很多时间进行验证，可以通过在`ALTER TABLE ... EXCHANGE PARTITION`语句后面添加`WITHOUT VALIDATION`跳过逐行验证的步骤

下面的例子比较了与一个未分区的表交换分区时由验证和没有验证的执行时间。已经分区的表（表e）包含两个都含有一百万条数据的分区。在e表p0分区的数据将被移除，p0与未分区表的一百万条数据交换。`WITH VALIDATION`操作花费了0.74秒，相比之下，`WITHOUT VALIDATION`操作花费了0.01秒。

```
# Create a partitioned table with 1 million rows in each partition
CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (1000001),
        PARTITION p1 VALUES LESS THAN (2000001), 
);

mysql> SELECT COUNT(*) FROM e;                                             
| COUNT(*) |
+----------+
|  2000000 | 
+----------+ 
1 row in set (0.27 sec)

# View the rows in each partition
SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+-------------+ 
| PARTITION_NAME | TABLE_ROWS  | 
+----------------+-------------+ 
| p0             |     1000000 | 
| p1             |     1000000 | 
+----------------+-------------+ 
2 rows in set (0.00 sec)

# Create a nonpartitioned table of the same structure and populate it with 1 million rows
CREATE TABLE e2 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30) 
);

mysql> SELECT COUNT(*) FROM e2; 
+----------+
| COUNT(*) | 
+----------+ 
|  1000000 | 
+----------+ 
1 row in set (0.24 sec)

# Create another nonpartitioned table of the same structure and populate it with 1 million rows
CREATE TABLE e3 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30) 
);    

mysql> SELECT COUNT(*) FROM e3; 
+----------+ 
| COUNT(*) | 
+----------+ 
|  1000000 | 
+----------+ 
1 row in set (0.25 sec)

# Drop the rows from p0 of table e
mysql> DELETE FROM e WHERE id < 1000001; 
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |          0 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)    

# Exchange partition p0 of table e with the table e2 'WITH VALIDATION'
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITH VALIDATION; 
Query OK, 0 rows affected (0.74 sec)

# Confirm that the partition was exchanged with table e2
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |    1000000 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)

# Once again, drop the rows from p0 of table e
mysql> DELETE FROM e WHERE id < 1000001; 
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |          0 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e3 'WITHOUT VALIDATION'
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e3 WITHOUT VALIDATION; 
Query OK, 0 rows affected (0.01 sec)

# Confirm that the partition was exchanged with table e3
mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e'; 
+----------------+------------+ 
| PARTITION_NAME | TABLE_ROWS | 
+----------------+------------+ 
| p0             |    1000000 | 
| p1             |    1000000 | 
+----------------+------------+ 
2 rows in set (0.00 sec)
```

#### 与未分区的表交换子分区

也可以使用`ALTER TABLE ...EXCHANGE PARTITION`语句使有子分区的表与未分区的表交换子分区。在下面的例子中，首先创建一个有RANGE分区且由KEY子分区表es，与填充表e一样填充这个表，然后创建一个未分区的空表es2：

```
mysql> CREATE TABLE es (
    -> id INT NOT NULL,
    -> fname VARCHAR(30),
    -> lname VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id)
    -> SUBPARTITION BY KEY(lname)
    -> SUBPARTITIONS 2 (
    -> PARTITION p0 VALUES LESS THAN (50),
    -> PARTITION p1 VALUES LESS THAN (100),
    -> PARTITION p2 VALUES LESS THAN (150),
    -> PARTITION p3 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.43 sec)

mysql> INSERT INTO es VALUES
    -> (1669,'Jim','Smith'),
    -> (337,'Mary','Jones'),
    -> (16,'Frank','White'),
    -> (2005,'Linda','Black');
Query OK, 4 rows affected (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> CREATE TABLE es2 LIKE es;
Query OK, 0 rows affected (0.45 sec)

mysql> ALTER TABLE es2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.41 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

虽然在创建表es时没有明确地命名任何子分区，但当在选择表中数据时，我们可以通过从
`INFORMATION_SCHEMA`中地`PARTITIONS`表中包含的`SUBPARTITION_NAME`列中获得这些子分区的生成名称，如下：

```
mysql> SELECT PARTITION_NAME,SUBPARTITION_NAME,TABLE_ROWS
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          1 |
| p3             | p3sp1             |          2 |
+----------------+-------------------+------------+
8 rows in set (0.01 sec)
```

下面的`ALTER TABLE`语句将es表中的子分区p3sp0与未分区的es2表交换：

```
mysql> ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;
Query OK, 0 rows affected (0.13 sec)
```

可以通过如下的查询来验证是否交换：

```
mysql> SELECT PARTITION_NAME,SUBPARTITION_NAME,TABLE_ROWS
    -> FROM INFORMATION_SCHEMA.PARTITIONS
    -> WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          0 |
| p3             | p3sp1             |          2 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql> SELECT * FROM es2;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
+------+-------+-------+
1 row in set (0.00 sec)
```

如果表是有子分区的，只能与未分区的表交换表的一个子分区，而不是整个表，如下表所示：

```
mysql> ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;
ERROR 1734 (HY000): Subpartitioned table, use subpartition instead of partition
```

表结构以一种严格的方式进行比较；分区表与非分区表的列数目，排序，名称和类型以及索引必须完全匹配。另外，两个表必须拥有相同的存储引擎：

```
mysql> CREATE TABLE es3 LIKE e;
Query OK, 0 rows affected (0.28 sec)

mysql> ALTER TABLE es3 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.28 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE es3 \G;
*************************** 1. row ***************************
       Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)

ERROR:
No query specified

mysql> ALTER TABLE es3 ENGINE=MyISAM;
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH es3;
ERROR 1497 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL
```

---

### 4.分区维护

可以使用用于维护表和分区的SQL语句对许多表和分区执行维护任务。

分区表的维护可以使用`CHECK TABLE`，`OPTIMIZE TABLE`，`ANALYZE TABLE`和`REPEAT TABLE`语句来完成，这些语句都是支持分区表的。

可以使用`ALTER TABLE`语句的多个扩展直接在一个或多个分区上执行这种类型的操作，如下所示：
* **重建分区：** 这个方法与删除分区中存储的所有数据，然后重新插入数据有相同的作用。这对于碎片整理很有用。示例：
	```
	ALTER TABLE tb_name REBUILD PARTITION partition_list;
	```
* **优化分区：** 如果你从一个分区中删除了大量的数据行，或者对具有可变长度的数据行（即具有VARCHAR，BLOB或TEXT列）的分区表做了大量修改，可以使用`ALTER TABLE ... OPTIMIZE PARTITION`语句来回收未使用的空间以及对分区的数据进行碎片整理。示例：
	```
	ALTER TABLE t1 OPTIMIZE PARTITION p0,p1;
	```
	对一个给定的分区使用`OPTIMIZE PARTITION`与在这个分区上运行`CHECK PARTITION`，`ANALYZE PARTITION`和`REPAIR PARTITION`是等效的。
	
	有些MySQL存储引擎，包括InnoDB，并不支持按分区优化；这种情况下，`ALTER TABLE ... OPTIMIZE PARTITION`分析并重建整个表，并发出适当的警告（Bug#11751825,Bug#42822）。使用`ALTER TABLE ...  REBUILD PARTITION`和`ALTER TABLE ... ANALYZE PARTITION`可以避免出现这种问题。
* **分析分区：** 这个操作会读取并存储分区中的密钥分布。示例：
	```
	ALTER TABLE t1 ANALYZE PARTITION p3;
	```
* **修复分区：** 修复坏掉的分区。示例：
	```
	ALTER TABLE t1 REPAIR PARTITION p0,p1;
	```
	通常，当分区含有重复键错误的时候，`REPAIR PARTITION`语句会失败。可以使用带有此选项的`ALTER IGNORE TABLE`，在这种情况下，因为重复键出现而不能被移除的所有行将从分区中删除（Bug#16900947）。

* **检查分区：** 你可以使用与对分区表使用`CHECK TABLE`几乎相同的方式来检查分区中的错误。示例：
	```
	ALTER TABLE trb3 CHECK PARTITION p1;
	```
	这条命令会告诉你表tb1的分区p1的数据或者索引是否有已损坏。如果是这种情况，可以使用`ALTER TABLE ... REPAIR PARTITION`来修复分区。
	通常，当分区中含有重复键失败的时候`CHECK PARTITION`会失败。可以使用带有此选项的`ALTER IGNORE TABLE`语句，在这种情况下，这条语句将返回分区中发现重复键冲突的每一行的内容。只报告分区表达式中列的值。

列出来的每一条语句都支持关键字ALL以替代分区名的列。使用ALL子句的语句可以作用在表中的所有分区。

也可以使用`ALTER TABLE ... TRUNCATE PARTITION`截短分区。这个语句可以用来从一个或多个分区中删除所有行，与`TRUNCATE TABLE`删除表中所有行一样的方式。

`ALTER TABLE ... TRUNCATE PARTITION ALL`可以裁剪表中的所有分区。

---

### 5.获取分区信息

这一节将讨论获取已经存在的表的信息，可以通过几种方式实现。获取这类信息的方法包括以下几种：
* 使用`SHOW CREATE TABLE`语句查看用于创建分区表的分区语句；
* 使用`SHOW TABLE STATUS`语句确定表是否为分区表；
* 查询`INFORMATION_SCHEMA.PARTITIONS`表；
* 使用`EXPLAIN SELECT`语句查看给定SELECT使用哪个分区；

`SHOW CREATE TABLE`在其输出中包含了用来创建分区表的`PARTITION BY`子句。例如：

```
mysql> SHOW CREATE TABLE trb3 \G;
*************************** 1. row ***************************
       Table: trb3
Create Table: CREATE TABLE `trb3` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(30) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (year(`purchased`))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB) */
1 row in set (0.07 sec)
```

分区表的`SHOW TABLE STATUS`输出与非分区表的输出一致，除了`Create_options`列包含了已分区的字符串。Engine列包含了表中所有存储引擎的名称。

也可以从`INFORMATION_SCHEMA`的`PARTITIONS`表中获取有关分区的信息。

可以使用`EXPLAIN`确定在给定的SELECT语句中涉及了分区表中的哪个分区。`EXPALIN`输出中的partitions列列出了与查询匹配的记录的分区。

假设trb1表由如下语句创建和填充：

```
mysql> CREATE TABLE trb1 (
    -> id INT,
    -> name VARCHAR(50),
    -> purchased DATE
    -> )
    -> PARTITION BY RANGE(id) (
    -> PARTITION p0 VALUES LESS THAN (3),
    -> PARTITION p1 VALUES LESS THAN (7),
    -> PARTITION p2 VALUES LESS THAN (9),
    -> PARTITION p3 VALUES LESS THAN (11)
    -> );
Query OK, 0 rows affected (0.30 sec)

mysql> INSERT INTO trb1 VALUES
    -> (1,'desk organiser','2003-10-15'),
    -> (2,'CD player','1993-11-05'),
    -> (3,'TV set','1982-01-10'),
    -> (4,'bookcase','2004-05-09'),
    -> (5,'exercise bike','2004-05-09'),
    -> (6,'sofa','1987-06-05'),
    -> (7,'popcorn maker','2001-11-22'),
    -> (8,'aquarium','1992-08-04'),
    -> (9,'study desk','1984-09-16'),
    -> (10,'lava lamp','1998-12-25');
Query OK, 10 rows affected (0.06 sec)
Records: 10  Duplicates: 0  Warnings: 0
```

可以通过使用查询语句`SELECT * FROM trb1`查看使用了哪个分区：

```
mysql> EXPLAIN SELECT * FROM trb1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1,p2,p3
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

在这种情况下，所有四个分区都被搜索到。然而，但有查询语句增加了一个使用分区键的限制条件时，只有包含了匹配值的分区能被扫描到，如下所示：

```
mysql> EXPLAIN SELECT * FROM trb1 WHERE id<5 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

`EXPLAIN`还提供使用键和可能键的信息：

```
mysql> ALTER TABLE trb1 ADD PRIMARY KEY (id);
Query OK, 0 rows affected (0.69 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> EXPLAIN SELECT * FROM trb1 WHERE id<5 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

当使用`EXPLAIN`检查针对未分区表的查询时，不会有错误产生，但partitions列的值总是NULL。

EXPLAIN输出的rows类显示的是表中总的行数。

---

## 分区裁剪

被称为分区裁剪的优化是基于一个相对简单的概念概念，该概念可以被描述为“不要扫描没有匹配值的分区”。假设分区表t1由以下语句创建：

```
mysql> CREATE TABLE t1(
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> region_code TINYINT UNSIGNED NOT NULL,
    -> dob DATE NOT NULL
    -> )
    -> PARTITION BY RANGE (region_code) (
    -> PARTITION p0 VALUES LESS THAN (64),
    -> PARTITION p1 VALUES LESS THAN (128),
    -> PARTITION p2 VALUES LESS THAN (192),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.26 sec)
```

假设你想要获得如下SELECT语句的结果：

```
SELECT fname,lname,region_code,dob
FROM t1
WHERE region_code >125 AND region_code < 130;
```

很容易看出，应该返回的数据行没有一个来自分区p0或p3中。也就是说，我们只需要在p1和p2分区中寻找匹配的行。通过限制查询，与扫描所有分区相比，查询匹配行可以花费更少的精力和时间。这种“切掉”不需要的分区的方式称为*修剪*。当优化程序在执行此查询时使用分区修剪时，对于包含相同列定义的数据的未分区表，查询的执行速度可以比同样的查询快一个数量级。

只要WHERE条件能被减少到以下两种情况之一，优化程序就可以执行：
* partition_column = constant
* partition_column IN (constant1,constant2,...,constantN)

在第一中情况下，优化程序只是简单地评估分区表达式的给定值，确定哪个分区包含了这个值，并且仅扫描这个分区。许多情况下，等号可以用其他算数符号代替，包括<，>，<=，>=和<>。一些在`WHERE`子句中使用`BETWEEN`的查询也可以利用分区修剪功能。

在第二种情况下，优化程序评估了分区表达式列表中每一个值，生成一个匹配的分区列，然后仅扫描这个列中的分区。

`SELECT`，`DELETE`和`UPDATE`语句都支持分区修剪。`INSERT`语句目前不支持。

修剪现在也可以应用在短范围中，优化程序可以将其转换为等效的值列表。例如，在前面的例子中，`WHERE`子句可以转化为`WHERE region_code IN (126,127,128,129)`。然后优化程序可以确定前两个值是在p1分区中找到的，剩下的两个值是在p2分区中找到的，其他的分区并不包含相关的值，因此不需要扫描匹配行。

无论分区表达式包含一个等于或可以减少到一组等式的范围，或者分区表达式表示增加或减少的关系时，这种类型的优化可以应用。当分区表达式使用了`YEAR()`或`TO_DAYS()`函数时，修剪可以应用于使用DATE列或DATETIME列分区的表上。当分区表达式使用了`TO_SECONDS()`函数时，修剪也可以引用在这类表上。

假设有表t2由以下语句创建，表依据DATE列分区：

```
mysql> CREATE TABLE t2 (
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> region_code TINYINT UNSIGNED NOT NULL,
    -> dob DATE NOT NULL
    -> )
    -> PARTITION BY RANGE(YEAR(dob)) (
    -> PARTITION d0 VALUES LESS THAN (1970),
    -> PARTITION d1 VALUES LESS THAN (1975),
    -> PARTITION d2 VALUES LESS THAN (1980),
    -> PARTITION d3 VALUES LESS THAN (1985),
    -> PARTITION d4 VALUES LESS THAN (1990),
    -> PARTITION d5 VALUES LESS THAN (2000),
    -> PARTITION d6 VALUES LESS THAN (2005),
    -> PARTITION d7 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.56 sec)
```

下面使用t2的语句可以使用分区修剪：

```
SELECT * FROM t2 WHERE dob='1982-06-23';

UPDATE t2 SET region_code = 8 WHERE dob BETWEEN '1991-02-15' AND '1997-04-25';

DELETE FROM t2 WHERE dob >= '1984-06-21' AND dob <= '1999-06-21';
```

对于最后一条语句，优化语句也可如以下执行：
1. 查找包含范围下限的分区。`YEAR('1984-06-21')`产生的值为1984，能在d3分区中找到；
2. 查找包含范围上线的分区。`YEAR('1999-06-21')`产生的值是1999，能在d5分区中找到；
3. 只扫描这两个分区和任何在这两个分区之间的分区；

在这种情况下，这意味着只有d3，d4和d5分区被扫描到。其他的分区可能安全地忽略（也被忽略）。

#### 重要：

对于分区表语句的`WHERE`条件中引用的无效DATE和DATETIME值都被认为是NULL值。这意味着诸如`SELECT * FROM partitioned_table WHERE date_column < '2008-12-00'`的查询语句不会返回任何值。

到目前为止，我们仅查看使用RANGE分区的例子，但裁剪也可以应用在其他分区类型中。

考虑一个由LIST分区的表，其中分区表达式是增加或减少的，例如下面所示的表t3：

```
mysql> CREATE TABLE t3 (
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> region_code TINYINT UNSIGNED NOT NULL,
    -> dob DATE NOT NULL
    -> )
    -> PARTITION BY LIST(region_code) (
    -> PARTITION r0 VALUES IN (1,3),
    -> PARTITION r1 VALUES IN (2,5,8),
    -> PARTITION r2 VALUES IN (4,9),
    -> PARTITION r3 VALUES IN (6,7,10)
    -> );
Query OK, 0 rows affected (0.13 sec)
```

对于诸如`SELECT * FROM t3 WHERE region_code BETWEEN 1 AND 3`的语句，优化程序决定哪个分区（r0和r1）可以找到值1，2和3然后跳过其他的分区（r2和r3）。

对于由HASH或[LINEAR] KEY分区的表，如果WHERE子句中对分区表达式中使用的列用了简单的=关系，分区裁剪也是可用的。考虑如下表：

```
mysql> CREATE TABLE t4 (
    -> fname VARCHAR(50) NOT NULL,
    -> lname VARCHAR(50) NOT NULL,
    -> region_code TINYINT UNSIGNED NOT NULL,
    -> dob DATE NOT NULL
    -> )
    -> PARTITION BY KEY(region_code)
    -> PARTITIONS 8;
Query OK, 0 rows affected (0.20 sec)
```

可以删除将列值和常数比较的语句：

```
UPDATE t4 WHERE region_code = 7;
```

修剪也可以应用于短范围，因为优化程序可以将这类情况转变成`IN`关系。例如，如下的查询将被删除：

```
SELECT * FROM t4 WHERE region_code > 2 AND region_code < 6;

SELECT * FROM t4 WHERE region_code BETWEEN 3 AND 5；
```

这两种情况下，`WHERE`子句都可以被优化程序转换成`WHERE region_code IN (3,4,5)`。

#### 重要：

仅当范围大小小于分区数时才使用此优化。考虑如下语句：

```
DELETE FROM t4 WHERE region_code BETWEEN 4 AND 12;
```

`WHERE`子句的范围包含了9个数值（4，5，6，7，8，9，10，11，12），但t4仅有8个分区。这就意味着`DELETE`没办法修剪。

当表由HASH或[LINEAR] KEY分区时，修剪只能用于整数类型的列。例如，如下语句不能使用修剪，因为dob时一个DATE类型的列：

```
SELECT * FROM t4 WHERE dob >= '2001-04-14' AND dob <= '2005-10-15';
```

然而，如果表将年份数据存储在INT类型的列中，那么使用`WHERE year_col >= 2001 AND year_col <= 2005`查询可以被修剪。

使用提供自动分区的存储引擎（例如MySQL客户端使用的NDB存储引擎）的表，如果已经由明确的分区，也可以修剪。

---

## 分区选择

为匹配给定`WHERE`条件的行显示选择分区或子分区是支持的。分区选择与分区修剪相似，因为只检查特定的分区是否匹配，但在两个关键地方有所不同：
1. 要检查的分区是由语句的发布者指定的，不像分区修剪，是自动的；
2. 分区修剪只适用于查询语句，而明确选择分区适用于查询和其他许多DML语句都；

支持显示分区选择的SQL如下所示：
* SELECT
* DELETE
* INSERT
* REPLACE
* UPDATE
* LOAD DATA
* LOAD XML

接下来的章节将讨论显示分区选择并提供一些例子，因为它通常用于上面列出来的语句。

显示分区选择是使用`PARTITION`选项实现的。对于所有支持的语句，使用这个选项的语法如下所示：

```
PARTITION (partition_names)

partition_names:partition_name,...
```

这个选项后面通常跟着分区所属表的名称。partition_names是一个由逗号分开的将被使用的分区或子分区列表。列表中的每个名称必须是指定表中存在的分区或子分区；如果任何一个分区或子分区没有被找到，这个语句将执行失败（partition 'partition_name' doesn't exist）。partition_names中的分区和子分区名称可以以任意顺序排列，也可以重复。

使用`PARTITION`选项时，只会检查被列出来的分区和子分区是否由匹配行。这个选项可以在为确定哪些行属于给定分区的`SELECT`语句中使用。考虑由以下语句创建和填充的名为employees的分区表：

```
mysql> SET @@SQL_MODE = '';
Query OK, 0 rows affected (0.06 sec)

mysql> CREATE TABLE employees (
    -> id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -> fname VARCHAR(25) NOT NULL,
    -> lname VARCHAR(25) NOT NULL,
    -> store_id INT NOT NULL,
    -> department_id INT NOT NULL
    -> )
    -> PARTITION BY RANGE(id) (
    -> PARTITION p0 VALUES LESS THAN (5),
    -> PARTITION p1 VALUES LESS THAN (10),
    -> PARTITION p2 VALUES LESS THAN (15),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.20 sec)

mysql> INSERT INTO employees VALUES
    -> ('','Bob','Taylor',3,2),
    -> ('','Frank','Williams',1,2),
    -> ('','Ellen','Johnson',3,4),
    -> ('','Jim','Smith',2,4),
    -> ('','Mary','Jones',1,1),
    -> ('','Linda','Black',2,3),
    -> ('','Ed','Jones',2,1),
    -> ('','June','Wilson',3,1),
    -> ('','Andy','Smith',1,3),
    -> ('','Lou','Waters',2,4),
    -> ('','Jill','Stone',1,4),
    -> ('','Roger','White',3,2),
    -> ('','Howard','Andrews',1,2),
    -> ('','Fred','Goldberg',3,3),
    -> ('','Barbara','Brown',2,3),
    -> ('','Alice','Rogers',2,2),
    -> ('','Mark','Morgan',3,3),
    -> ('','Karen','Cole',3,2);
Query OK, 18 rows affected, 18 warnings (0.07 sec)
Records: 18  Duplicates: 0  Warnings: 18
```

可以看到存储在分区p1中的数据行为：

```
mysql> SELECT * FROM employees PARTITION (p1);
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  |        1 |             1 |
|  6 | Linda | Black  |        2 |             3 |
|  7 | Ed    | Jones  |        2 |             1 |
|  8 | June  | Wilson |        3 |             1 |
|  9 | Andy  | Smith  |        1 |             3 |
+----+-------+--------+----------+---------------+
5 rows in set (0.05 sec)
```

查询的结果于通过`SELECT * FROM employees WHERE id BETWEEN 5 AND 9`查询获得的结果相同。

在以逗号分隔的列表中提供它们的名字可以获取多个分区中的数据行。例如，`SELECT * FROM employees PARTITION (p1,p2)`将返回所有p1分区和p2分区的数据行但排除其他分区的数据行。

任何针对分区表的有效查询可以使用`PARTITION`选项将结果限制在一个或多个期望的分区中。你可以使用`WHERE`条件，`ORDER BY`和`LIMIT`选项等等。也可以使用带`HAVING`和`GROUP BY`选项的聚合函数。在前面定义的employees表中运行时，以下每个查询产生一个有效的结果：

```
mysql> SELECT * FROM employees PARTITION (p0,p2) WHERE lname LIKE 'S%';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith |        2 |             4 |
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+

mysql> SELECT id, CONCAT(fname,' ',lname) AS name
    -> FROM employees PARTITION (p0) ORDER BY lname;
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.05 sec)

mysql> SELECT store_id,COUNT(department_id) AS c
    -> FROM employees PARTITION (p1,p2,p3)
    -> GROUP BY store_id HAVING c>4;
+----------+---+
| store_id | c |
+----------+---+
|        2 | 5 |
|        3 | 5 |
+----------+---+
2 rows in set (0.05 sec)
```

使用分区选择的语句可以与使用任何一种支持分区类型的表一起使用。当表是使用[LINEAR] HASH或[LINEAR] KEY分区创建而且分区名称没有确定时，MySQL将自动将分区命名为p0，p1，p2，……，pN-1，其中N是分区的数量。对于没有明确命名的子分区，MySQL将自动为每个分区pX的子分区命名为pXsp0，pXsp1，pXsp2，……，pXspM-1，其中M是子分区的数量。当对表执行`SELECT`语句（或其他允许显示分区选择的SQL语句）时，你可以在`PARTITION`选项中使用这些自动生成的名字，如下所示：

```
mysql> CREATE TABLE employee_sub (
    -> id INT NOT NULL AUTO_INCREMENT,
    -> fname VARCHAR(25) NOT NULL,
    -> lname VARCHAR(25) NOT NULL,
    -> store_id INT NOT NULL,
    -> department_id INT NOT NULL,
    -> PRIMARY KEY pk (id,lname)
    -> )
    -> PARTITION BY RANGE(id)
    -> SUBPARTITION BY KEY(lname)
    -> SUBPARTITIONS 2 (
    -> PARTITION p0 VALUES LESS THAN (5),
    -> PARTITION p1 VALUES LESS THAN (10),
    -> PARTITION p2 VALUES LESS THAN (15),
    -> PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.45 sec)

mysql> INSERT INTO employee_sub SELECT * FROM employees;
Query OK, 18 rows affected (0.07 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql> SELECT id, CONCAT(fname,' ',lname) AS name
    -> FROM employee_sub PARTITION(p2sp1);
+----+------------+
| id | name       |
+----+------------+
| 10 | Lou Waters |
+----+------------+
```

也可以在`INSERT ... SELECT`语句的`SELECT`部分中使用`PARTITION`选项，如下所示：

```
mysql> CREATE TABLE employee_copy LIKE employees;
Query OK, 0 rows affected (0.28 sec)

mysql> INSERT INTO employee_copy SELECT * FROM employees PARTITION(p2);
Query OK, 5 rows affected (0.06 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM employee_copy;
+----+--------+----------+----------+---------------+
| id | fname  | lname    | store_id | department_id |
+----+--------+----------+----------+---------------+
| 10 | Lou    | Waters   |        2 |             4 |
| 11 | Jill   | Stone    |        1 |             4 |
| 12 | Roger  | White    |        3 |             2 |
| 13 | Howard | Andrews  |        1 |             2 |
| 14 | Fred   | Goldberg |        3 |             3 |
+----+--------+----------+----------+---------------+
5 rows in set (0.00 sec)
```

分区选择也可以与联合一起使用。假设我们使用以下的语句创建和填充两个表：

```
mysql> CREATE TABLE stores (
    -> id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -> city VARCHAR(30) NOT NULL
    -> )
    -> PARTITION BY HASH(id)
    -> PARTITIONS 2;
Query OK, 0 rows affected (0.19 sec)

mysql> INSERT INTO stores VALUES
    -> ('','Nambucca'),
    -> ('','Uranga'),
    -> ('','Bellingen'),
    -> ('','Grafton');
Query OK, 4 rows affected, 4 warnings (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 4

mysql> CREATE TABLE departments (
    -> id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -> name VARCHAR(30) NOT NULL
    -> )
    -> PARTITION BY KEY(id)
    -> PARTITIONS 2;
Query OK, 0 rows affected (0.19 sec)

mysql> INSERT INTO departments VALUES
    -> ('','Sales'),
    -> ('','Customer Service'),
    -> ('','Delivery'),
    -> ('','Accounting');
Query OK, 4 rows affected, 4 warnings (0.06 sec)
Records: 4  Duplicates: 0  Warnings: 4
```

你可以从联接中的任何表或全部表中显示地选择分区（或子分区，或同时选择两者）。（用于从给定表中选择分区而使用的`PARTITION`选项在其他选项之前紧跟着表的名称，包括表的其他别名。）例如， 如下的查询语句获取在Nambucca和Bellingen的商店（stores表的p0分区）的销售和运输部门的所有员工的名称，ID，部门以及城市（departments表的p1分区）：

```
mysql> SELECT e.id AS 'Employee ID', CONCAT(e.fname,' ',e.lname) AS Name, s.city AS City, d.name AS department 
    -> FROM employees AS e 
    -> JOIN stores PARTITION (p1) AS s ON e.store_id = s.id 
    -> JOIN departments PARTITION (p0) AS d ON e.department_id = d.id 
    -> ORDER BY e.lname;
+-------------+---------------+-----------+------------+
| Employee ID | Name          | City      | department |
+-------------+---------------+-----------+------------+
|          14 | Fred Goldberg | Bellingen | Delivery   |
|           5 | Mary Jones    | Nambucca  | Sales      |
|          17 | Mark Morgan   | Bellingen | Delivery   |
|           9 | Andy Smith    | Nambucca  | Delivery   |
|           8 | June Wilson   | Bellingen | Sales      |
+-------------+---------------+-----------+------------+
```

当`DELETE`语句中使用`PARTITION`选项时，只有在选项中列出的分区（和子分区，若存在）会检查将被删除的行。其他分区将被忽略，如下所示：

```
mysql> SELECT * FROM employees WHERE fname LIKE 'j%';
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  4 | Jim   | Smith  |        2 |             4 |
|  8 | June  | Wilson |        3 |             1 |
| 11 | Jill  | Stone  |        1 |             4 |
+----+-------+--------+----------+---------------+
3 rows in set (0.00 sec)

mysql> DELETE FROM employees PARTITION (p0,p1)
    -> WHERE fname LIKE 'j%';
Query OK, 2 rows affected (0.05 sec)

mysql> SELECT * FROM employees WHERE fname LIKE 'j%';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
```

仅有p0分区和p1分区中匹配到`WHERE`条件的两行数据被删除。正如第二次执行`SELECT`语句时的结果中看到的，表中仍然存在一条满足`WHERE`条件的数据，但是这条数据存储在不同的分区（p2）中。

在`UPDATE`语句中使用显示分区选择执行的效果相同；当决定哪些行要更新时只考虑`PARTITION`选项中涉及的分区中的数据行，执行以下语句可以看出：

```
mysql> UPDATE employees PARTITION (p0)
    -> SET store_id = 2 WHERE fname = 'Jill';
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql> SELECT * FROM employees WHERE fname = 'Jill';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)

mysql> UPDATE employees PARTITION (p2)
    -> SET store_id = 2 WHERE fname = 'Jill';
Query OK, 1 row affected (0.05 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM employees WHERE fname = 'Jill';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        2 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
```

同样，当`DELETE`语句使用`PARTITION`选项时，只有在分区列表中的分区的行才会被检查是否删除。

对于插入数据行的语句，因为查找不到合适的分区造成语句失败的行为有所不同。对于`INSERT`和`REPLACE`语句都是如此：

```
mysql> INSERT INTO employees PARTITION (p2) VALUES (20,'Jan','Jones',1,3);
ERROR 1748 (HY000): Found a row not matching the given partition set
mysql> INSERT INTO employees PARTITION (p3) VALUES (20,'Jan','Jones',1,3);
Query OK, 1 row affected (0.05 sec)

mysql> REPLACE INTO employees PARTITION (p0) VALUES (20,'Jan','Jones',3,2);
ERROR 1748 (HY000): Found a row not matching the given partition set
mysql> REPLACE INTO employees PARTITION (p3) VALUES (20,'Jan','Jones',3,2);
Query OK, 2 rows affected (0.04 sec)
```

对于使用InnoDB引擎将多条行写入一个分区表的语句：如果VALUES之后的列中的行无法被写入到partition_names列中的指定的任意一个分区，则整个语句将失败并且没有写入任何行。下面的例子中的`INSERT`语句将展示这种情况：

```
mysql> ALTER TABLE employees REORGANIZE PARTITION p3 INTO (
    -> PARTITION p3 VALUES LESS THAN (20),
    -> PARTITION p4 VALUES LESS THAN (25),
    -> PARTITION p5 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.16 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE employees \G;
*************************** 1. row ***************************
       Table: employees
Create Table: CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fname` varchar(25) NOT NULL,
  `lname` varchar(25) NOT NULL,
  `store_id` int(11) NOT NULL,
  `department_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE (`id`)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (15) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (20) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (25) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
1 row in set (0.01 sec)


mysql> INSERT INTO employees PARTITION (p3,p4) VALUES
    -> (24,'Tim','Greene',3,1),
    -> (26,'Linda','Mills',2,1);
ERROR 1748 (HY000): Found a row not matching the given partition set
mysql> INSERT INTO employees PARTITION (p3,p4,p5) VALUES
    -> (24,'Tim','Greene',3,1),
    -> (26,'Linda','Mills',2,1);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

对于写入多行的`INSERT`语句和`REPLACE`语句，上述条件均适用。

分区选择对于使用提供自动分区的存储引擎（例如NDB）的表是不可用的。

---

## 分区限制

这一节将讨论当前MySQL分区支持的限制。

**禁止构造：** 分区表达式不允许有以下构造
* 存储过程，存储函数，UDFs或插件；
* 声明的变量或用户变量；

**算数运算和逻辑运算符：** 分区表达式允许使用算是运算符+，-和*号。然而，输出的结果必须为整数值或NULL值（除了[LINEAR] KEY分区）。分区表达式也支持`DIV`运算符，但是不允许有/号。

分区表达式不允许有|，&，^，<<，>>和~位运算符。

**服务器SQL模式：** 使用用户定义分区的表在创建时不会保留有效的SQL模式。很多MySQL方程和运算符的结果可能根据服务器SQL模式而变化。因此，在创建分区表之后的任意时间改变SQL模式可能导致此类表行为的重大变化，而且很容易导致数据的丢失或损坏。正因如此，强烈建议你在创建分区表之后不要改变服务器SQL模式。

**示例：** 以下例子展示了由于服务器SQL模式变化导致的分区表行为的变化：

1. 错误处理。正如其他地方讨论过的，处理类似0或NULL的“特殊”值在服务器SQL模式的不同而不同。例如，`ERROR_FOR_DIVISION_BY_ZERO`会影响是否可以将0插入到分区表达式使用了`column DIV value`或`column MOD value`的表。
2. 表的可访问性。有时候服务器SQL模式的改变可能导致分区表的不可用。下面的`CREATE TABLE`语句只有在`NO_UNSIGNED_SUBTRACTION`模式有效时才能成功执行：

```
mysql> SELECT @@sql_mode;
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql> CREATE TABLE tu (
    -> c1 BIGINT UNSIGNED
    -> )
    -> PARTITION BY RANGE(c1-10) (
    -> PARTITION p0 VALUES LESS THAN (-5),
    -> PARTITION p1 VALUES LESS THAN (0),
    -> PARTITION p2 VALUES LESS THAN (5),
    -> PARTITION p3 VALUES LESS THAN (10),
    -> PARTITION p4 VALUES LESS THAN (MAXVALUE)
    -> );
ERROR 1563 (HY000): Partition constant is out of partition function domain

mysql> SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @@sql_mode;
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql> CREATE TABLE tu (
    -> c1 BIGINT UNSIGNED
    -> )
    -> PARTITION BY RANGE(c1-10) (
    -> PARTITION p0 VALUES LESS THAN (-5),
    -> PARTITION p1 VALUES LESS THAN (0),
    -> PARTITION p2 VALUES LESS THAN (5),
    -> PARTITION p4 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.12 sec)
```

如果在创建tu表之后移除了`NO_UNSIGNED_SUBTRACTION`的服务器SQL模式，你将没办法访问这个表：

```
mysql> SET @@sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM tu;
ERROR 1563 (HY000): Partition constant is out of partition function domain

mysql> INSERT INTO tu VALUES (20);
ERROR 1563 (HY000): Partition constant is out of partition function domain
```

服务器SQL模式同样也会影响分区表的复制。主从服务器上不同SQL模式会导致分区表达式求值的方式不同，这会造成数据在给定表的主副本和从副本中的分布有所不同，甚至可能造成在主服务器中插入分区表成功而从服务器中失败。为了获得最佳结果，应该始终在主服务器和从服务器上使用相同的服务器SQL模式。

**性能考量：** 下面列出了分区操作对性能的影响：

* 文件系统操作。分区和重分区操作（例如带有`PARTITION BY ...`，`REORGANIZE PARTITION`或者`REMOVE PARTITIONING`的`ALTER TABLE`）依赖于文件系统操作的实现。这意味着这些操作的速度会受到诸如文件系统类型和特征，磁盘速度，交换空间，操作系统的文件处理效率和与文件处理有关的MySQL服务选项和变量等因素的影响。特别是，你应确保`large_files_support`是启用的，并且正确设置`open_files_limit`。通过启用`innodb_file_per_table`，可以提高涉及InnoDB表的分区和重分区操作操作的效率。
* 表锁。通常，对表执行分区操作的进程会对表进行写锁定。从此类表中读取不相互影响。当分区操作结束之后，将立刻执行挂起`INSERT`和`UPDATE`操作。
* 索引；分区修剪。与未分区表一样，适当使用索引可以明显提高分区表的查询速度。另外，利用分区裁剪设计分区表和查询这些表可以极大提高性能。
* LOAD DATA的性能。在MySQL 8.0中，`LOAD DATA`使用缓冲来提高性能。应该意识到，缓冲为每个分区使用130KB的内存来实现这个。

**分区的最大数值**

在MySQL 8.0中，给定表的分区最大的可能数值是8192。这个数值包含了子分区。

当创建一个分区数值很大（但小于最大数值）的表时，会遇到诸如'Got error ... from storage engine: Out of resources when opening file'的错误信息，可以通过增加系统值`open_files_limit`的值来解决这个问题。然而，这取决于操作系统，而且可能并非在所有平台都可行和不可行。在某些情况下，出于其他的考量，并不推荐使用大量（数百）的分区，所以使用更多的分区并不相应的产生好的结果。

**分区的InnoDB表不支持外键**

使用InnoDB存储引擎的分区表并不支持外键。更具体地说，这意味着如下两条陈述是正确的：
1. 使用用户定义的分区的InnoDB表不得包含外键引用；定义中包含外键引用的InnoDB表不能分区。
2. InnoDB表定义不能包含对用户分区表的外键引用；使用用户定义分区的InnoDB表不能包含有外键引用的列。

刚刚列出限制范围包含了所有使用InnoDB存储引擎的表。不允许使用可能导致表违反这些限制的`CREATE TABLE`和`ALTER TABLE`语句。

**ALTER TABLE ... ORDER BY** 对分区表运行的`ALTER TABLE ... ORDER BY column`语句只会在每个分区中进行行排序。

**主键修改对REPLACE语句的影响** 记住，如果应用使用了`REPLACE`语句并且你执行了此操作，这些语句的结果可能会发生重大的变化。

**FULLTEXT索引** 分区表不支持`FULLTEXT`索引或搜索。

**空间列** 具有空间数据类型的列不能在分区表中使用，例如`POINT`和`GEOMETRY`。

**临时表** 临时表不能分区。

**日志表** 不能对日志表分区。对这种表使用`ALTER TABLE ... PARTITION BY ...`语句将会出现错误。

**分区键的数据类型**

分区键必须是一个整数列或解析为整数的表达式。使用`ENUM`列的表达式不能使用。

这个显示有两个例外：
1. 当使用[LINEAR] KEY分区时，可以使用除TEXT和BLOB外的任何有效的MySQL数据类型作为分区键，因为内部键散列函数会从这些数据类型中产生正确的数据类型。下面的`CREATE TABLE`语句是有效的：
	```
	CREATE TABLE tkc (c1 CHAR)
	PARTITION BY KEY(c1)
	PARTITIONS 4;
	
	CREATE TABLE tke (
		c1 ENUM('red','orange','yellow','green','blue','indigo','violet')
	)
	PARTITION BY LINEAR KEY(c1)
	PARTITIONS 6;
	```
2. 当使用`RANGE COLUMNS`或`LIST COLUMNS`分区时，可以使用string，DATE和DATETIME列。下面的`CREATE TABLE`语句是有效的：
	```
	CREATE TABLE rc (c1 INT, c2 DATE)
	PARTITION BY RANGE COLUMNS(c2) (
		PARTITION p0 VALUES LESS THAN ('1990-01-01'),
		PARTITION p1 VALUES LESS THAN ('1995-01-01'),
		PARTITION p2 VALUES LESS THAN ('2000-01-01'),
		PARTITION p3 VALUES LESS THAN ('2005-01-01'),
		PARTITION p4 VALUES LESS THAN (MAXVALUE)
	);
	
	CREATE TABLE lc (c1 INT, c2 CHAR(1))
	PARTITION BY LIST COLUMNS(c2) (
		PARTITION p0 VALUES IN ('a','d','g','j','m','p','s','v','y'),
		PARTITION p1 VALUES IN ('b','e','h','k','n','q','t','w','z'),
		PARTITION p2 VALUES IN ('c','f','i','l','o','r','u','x',NULL)
	);
	```
	上面的两个例子中都没有使用BLOB或TEXT列类型。

**子查询** 分区键并不是一个子查询，即使子查询解析值为整数值或NULL。

**子分区的问题**

子分区必须使用HASH或KEY进行分区。只能对RANGE和LIST分区进行细分；不能对HASH和KEY分区细分。

`SUBPARTITION BY KEY`要求显示地指定细分列，这与`PARTITION BY KEY`的情况不同，后者可以忽略（默认情况下使用表的主键）。考虑以下创建表的语句：

```
CREATE TABLE ts (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(30)
);
```

你可以创建一个带有相同列的由KEY分区的表，使用如下语句创建：

```
CREATE TABLE ts (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(30)
)
PARTITION BY KEY(id)
PARTITIONS 4;
```

然而，下面尝试用默认列作为细分列创建子分区表的语句会失败，并且只有为语句指定该列才会成功：

```
mysql> CREATE TABLE ts (
    -> id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -> name VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id)
    -> SUBPARTITION BY KEY()
    -> SUBPARTITIONS 4
    -> (
    -> PARTITION p0 VALUES LESS THAN (100),
    -> PARTITION p1 VALUES LESS THAN (MAXVALUE)
    -> );
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ')
SUBPARTITIONS 4
(
PARTITION p0 VALUES LESS THAN (100),
PARTITION p1 VALUES LES' at line 6

mysql> CREATE TABLE ts (
    -> id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -> name VARCHAR(30)
    -> )
    -> PARTITION BY RANGE(id)
    -> SUBPARTITION BY KEY(id)
    -> SUBPARTITIONS 4
    -> (
    -> PARTITION p0 VALUES LESS THAN (100),
    -> PARTITION p1 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.61 sec)
```

**DATE DIRECTORY和INDEX DIRECTORY选项** 表级`DATA DIRECTORY`和`INDEX DIRECTORY`选项将被忽略。你可以将这些选项用于InnoDB表的单个分区或子分区。

**修复和重建分区表** 分区表支持`CHECK TABLE`，`OPTIMIZE TABLE`，`ANALYZE TABLE`和`REPAIR TABLE`语句。

另外，可以使用`ALTER TABLE ... REBUILD PARTITION`来重建分区表的一个或多个分区；`ALTER TABLE ... REORGANIZE PARTITION`也可以重建分区。
 
子分区支持`CHECK`，`OPTIMIZE`，`ANALYZE`，`REPAIR`和`TRUNCATE`操作。

### 1.分区键，主键和唯一键













